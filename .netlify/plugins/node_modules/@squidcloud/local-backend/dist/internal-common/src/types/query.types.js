"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseQuerySubscriptionId = exports.getQuerySubscriptionId = exports.replaceSpecialCharacters = exports.compareOperator = exports.QueryMappingManager = exports.encodeCondition = void 0;
const serialization_1 = require("../utils/serialization");
const object_1 = require("../utils/object");
const assertic_1 = require("assertic");
function encodeCondition(condition) {
    return (0, serialization_1.normalizeJsonAsString)(condition);
}
exports.encodeCondition = encodeCondition;
class QueryMappingManager {
}
exports.QueryMappingManager = QueryMappingManager;
function compareOperator(conditionValue, valueInDocument, operator) {
    conditionValue = conditionValue instanceof Date ? conditionValue.getTime() : conditionValue !== null && conditionValue !== void 0 ? conditionValue : null;
    valueInDocument = valueInDocument instanceof Date ? valueInDocument.getTime() : valueInDocument !== null && valueInDocument !== void 0 ? valueInDocument : null;
    if (operator === '==') {
        return (0, object_1.isEqual)(conditionValue, valueInDocument);
    }
    if (operator === '!=') {
        return !(0, object_1.isEqual)(conditionValue, valueInDocument);
    }
    switch (operator) {
        case '<':
            if ((0, object_1.isNil)(conditionValue))
                return false;
            if ((0, object_1.isNil)(valueInDocument))
                return true;
            return valueInDocument < conditionValue;
        case '<=':
            if ((0, object_1.isNil)(valueInDocument)) {
                return true;
            }
            if ((0, object_1.isNil)(conditionValue)) {
                return false;
            }
            return valueInDocument <= conditionValue;
        case '>':
            if ((0, object_1.isNil)(valueInDocument))
                return false;
            if ((0, object_1.isNil)(conditionValue))
                return true;
            return valueInDocument > conditionValue;
        case '>=':
            if ((0, object_1.isNil)(conditionValue)) {
                return true;
            }
            if ((0, object_1.isNil)(valueInDocument)) {
                return false;
            }
            return valueInDocument >= conditionValue;
        case 'like':
            return (typeof valueInDocument === 'string' &&
                typeof conditionValue === 'string' &&
                isStringMatch(valueInDocument, conditionValue, false));
        case 'not like':
            return !(typeof valueInDocument === 'string' &&
                typeof conditionValue === 'string' &&
                isStringMatch(valueInDocument, conditionValue, false));
        case 'like_cs':
            return (typeof valueInDocument === 'string' &&
                typeof conditionValue === 'string' &&
                isStringMatch(valueInDocument, conditionValue, true));
        case 'not like_cs':
            return !(typeof valueInDocument === 'string' &&
                typeof conditionValue === 'string' &&
                isStringMatch(valueInDocument, conditionValue, true));
        case 'array_includes_some': {
            const valArray = valueInDocument;
            return (Array.isArray(valueInDocument) &&
                Array.isArray(conditionValue) &&
                conditionValue.some(val => (0, assertic_1.truthy)(valArray, 'VALUE_CANNOT_BE_NULL').some(docVal => (0, object_1.isEqual)(docVal, val))));
        }
        case 'array_includes_all': {
            const valArray = valueInDocument;
            return (Array.isArray(conditionValue) &&
                Array.isArray(valueInDocument) &&
                conditionValue.every(val => (0, assertic_1.truthy)(valArray, 'VALUE_CANNOT_BE_NULL').some(docVal => (0, object_1.isEqual)(docVal, val))));
        }
        case 'array_not_includes': {
            const valArray = valueInDocument;
            return (Array.isArray(valueInDocument) &&
                Array.isArray(conditionValue) &&
                conditionValue.every(val => !(0, assertic_1.truthy)(valArray, 'VALUE_CANNOT_BE_NULL').some(docVal => (0, object_1.isEqual)(docVal, val))));
        }
        default:
            throw new Error(`Unsupported operator comparison: ${operator}`);
    }
}
exports.compareOperator = compareOperator;
function isStringMatch(str, pattern, caseSensitive) {
    if (!caseSensitive) {
        str = str.toLowerCase();
        pattern = pattern.toLowerCase();
    }
    const regexPattern = replaceSpecialCharacters(pattern);
    const regex = new RegExp(`^${regexPattern}$`);
    return regex.test(str);
}
function replaceSpecialCharacters(input) {
    let result = '';
    for (let i = 0; i < input.length; ++i) {
        if (input[i] === '\\') {
            if (i + 1 < input.length && ['%', '_'].includes(input[i + 1])) {
                result += input[i + 1];
                i++;
            }
            else if (i + 1 < input.length && input[i + 1] === '\\') {
                result += '\\\\';
                i++;
            }
            else {
                result += '\\';
            }
        }
        else if (input[i] === '%') {
            result += '[\\s\\S]*';
        }
        else if (input[i] === '_') {
            result += '[\\s\\S]';
        }
        else {
            if ('/-\\^$*+?.()[]{}|'.includes(input[i])) {
                result += '\\';
            }
            result += input[i];
        }
    }
    return result;
}
exports.replaceSpecialCharacters = replaceSpecialCharacters;
function getQuerySubscriptionId(clientId, clientRequestId) {
    return `${clientId}_${clientRequestId}`;
}
exports.getQuerySubscriptionId = getQuerySubscriptionId;
function parseQuerySubscriptionId(querySubscriptionId) {
    const splitString = querySubscriptionId.split('_');
    return {
        clientId: splitString[0],
        clientRequestId: splitString[1],
    };
}
exports.parseQuerySubscriptionId = parseQuerySubscriptionId;
//# sourceMappingURL=query.types.js.map