"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.range = exports.invert = exports.pick = exports.groupBy = exports.mapValues = exports.compareValues = exports.cloneShallow = exports.cloneDeep = exports.omit = exports.isEmpty = exports.isEqual = exports.isNil = exports.replaceKeyInRecord = exports.replaceKeyInMap = exports.deleteInPath = exports.setInPath = exports.isDateObject = exports.getInPath = void 0;
const assertic_1 = require("assertic");
const SPLIT_REGEX_FOR_GET_IN_PATH = /[.\[\]]/;
function getInPath(obj, path) {
    if (!obj) {
        return undefined;
    }
    const splitPath = path.split(SPLIT_REGEX_FOR_GET_IN_PATH);
    let value = undefined;
    let currentObj = obj;
    while (currentObj && splitPath.length) {
        const key = splitPath.shift();
        if (!key) {
            continue;
        }
        if (typeof currentObj !== 'object' || !(key in currentObj)) {
            return undefined;
        }
        value = currentObj[key];
        currentObj = value;
    }
    return value;
}
exports.getInPath = getInPath;
function isJsObject(obj) {
    return obj !== null && typeof obj === 'object' && !Array.isArray(obj);
}
function isDateObject(value) {
    return Object.prototype.toString.call(value) === '[object Date]';
}
exports.isDateObject = isDateObject;
function setInPath(obj, path, value, delimiter = '.') {
    var _a;
    const splitPath = path.split(delimiter);
    let currentObj = obj;
    while (splitPath.length) {
        const key = (0, assertic_1.truthy)(splitPath.shift());
        if (splitPath.length) {
            const fieldValue = currentObj[key];
            const newCurrentObj = isJsObject(fieldValue) ? (_a = cloneShallow(fieldValue)) !== null && _a !== void 0 ? _a : {} : {};
            currentObj[key] = newCurrentObj;
            currentObj = newCurrentObj;
        }
        else {
            currentObj[key] = value;
        }
    }
}
exports.setInPath = setInPath;
function deleteInPath(obj, path, delimiter = '.') {
    var _a;
    const splitPath = path.split(delimiter);
    let currentObj = obj;
    while (splitPath.length) {
        const key = (0, assertic_1.truthy)(splitPath.shift());
        if (splitPath.length) {
            const newCurrentObj = isJsObject(currentObj[key]) ? (_a = cloneShallow(currentObj[key])) !== null && _a !== void 0 ? _a : {} : {};
            currentObj[key] = newCurrentObj;
            currentObj = newCurrentObj;
        }
        else {
            delete currentObj[key];
        }
    }
}
exports.deleteInPath = deleteInPath;
function replaceKeyInMap(map, a, b) {
    if (map.has(a)) {
        const value = map.get(a);
        map.delete(a);
        map.set(b, value);
    }
}
exports.replaceKeyInMap = replaceKeyInMap;
function replaceKeyInRecord(record, a, b) {
    const value = record[a];
    if (typeof value !== 'undefined') {
        record[b] = value;
        delete record[a];
    }
}
exports.replaceKeyInRecord = replaceKeyInRecord;
function isNil(obj) {
    return obj === undefined || obj === null;
}
exports.isNil = isNil;
function isEqual(a, b) {
    if (a === b)
        return true;
    if (a === null || b === null)
        return false;
    const typeOfA = typeof a;
    if (typeOfA !== typeof b)
        return false;
    if (typeOfA !== 'object')
        return a === b;
    if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
    }
    const keysA = Object.keys(a);
    const keysB = Object.keys(b);
    if (keysA.length !== keysB.length)
        return false;
    for (const key of keysA) {
        if (!keysB.includes(key) || !isEqual(a[key], b[key]))
            return false;
    }
    return true;
}
exports.isEqual = isEqual;
function isEmpty(a) {
    if (a === null || a === undefined) {
        return true;
    }
    if (typeof a === 'function') {
        return Object.keys(a).length === 0;
    }
    if (ArrayBuffer.isView(a) && !(a instanceof DataView)) {
        return a.byteLength === 0;
    }
    if (typeof a !== 'object' && !Array.isArray(a) && typeof a !== 'string') {
        return true;
    }
    if (Array.isArray(a) || typeof a === 'string' || (typeof a === 'object' && 'length' in a)) {
        return a.length === 0;
    }
    if (a instanceof Map || a instanceof Set) {
        return a.size === 0;
    }
    if (typeof a === 'object') {
        return Object.keys(a).length === 0;
    }
    return false;
}
exports.isEmpty = isEmpty;
function omit(object, ...fieldsToRemove) {
    if (object === null || object === undefined) {
        return {};
    }
    if (fieldsToRemove.length === 0) {
        return object;
    }
    const result = Object.assign({}, object);
    for (const fieldToRemove of fieldsToRemove) {
        if (result.hasOwnProperty(fieldToRemove)) {
            delete result[fieldToRemove];
        }
    }
    return result;
}
exports.omit = omit;
function cloneDeepArray(array, customizer) {
    const resultArray = new Array(array.length);
    for (let i = 0; i < array.length; i++) {
        resultArray[i] = cloneDeep(array[i], customizer);
    }
    return resultArray;
}
function copyBuffer(bufferLike) {
    if (bufferLike instanceof Buffer) {
        return Buffer.from(bufferLike);
    }
    return new bufferLike.constructor(bufferLike.buffer.slice(), bufferLike.byteOffset, bufferLike.length);
}
function cloneDeep(value, customizer) {
    const customized = customizer ? customizer(value) : undefined;
    if (customized !== undefined)
        return customized;
    if (typeof value !== 'object' || value === null)
        return value;
    if (value instanceof Date)
        return new Date(value);
    if (Array.isArray(value))
        return cloneDeepArray(value, customizer);
    if (value instanceof Map)
        return new Map(cloneDeepArray(Array.from(value), customizer));
    if (value instanceof Set)
        return new Set(cloneDeepArray(Array.from(value), customizer));
    if (ArrayBuffer.isView(value))
        return copyBuffer(value);
    const result = {};
    for (const k in value) {
        if (!Object.hasOwnProperty.call(value, k))
            continue;
        result[k] = cloneDeep(value[k], customizer);
    }
    return result;
}
exports.cloneDeep = cloneDeep;
function cloneShallow(value) {
    if (typeof value !== 'object' || value === null)
        return value;
    if (value instanceof Date)
        return new Date(value);
    if (Array.isArray(value))
        return [...value];
    if (value instanceof Map)
        return new Map(Array.from(value));
    if (value instanceof Set)
        return new Set(Array.from(value));
    return Object.assign({}, value);
}
exports.cloneShallow = cloneShallow;
function compareValues(v1, v2) {
    if (v1 === v2 || (isNil(v1) && isNil(v2))) {
        return 0;
    }
    else if (isNil(v1)) {
        return -1;
    }
    else if (isNil(v2)) {
        return 1;
    }
    const v1Type = typeof v1;
    const v2Type = typeof v2;
    if (v1Type !== v2Type) {
        return v1Type < v2Type ? -1 : 1;
    }
    if (typeof v1 === 'number') {
        (0, assertic_1.assertTruthy)(typeof v2 === 'number');
        if (isNaN(v1) && isNaN(v2))
            return 0;
        if (isNaN(v1))
            return -1;
        if (isNaN(v2))
            return 1;
        return v1 < v2 ? -1 : 1;
    }
    if (typeof v1 === 'boolean') {
        (0, assertic_1.assertTruthy)(typeof v2 === 'boolean');
        return v1 < v2 ? -1 : 1;
    }
    if (typeof v1 === 'bigint') {
        (0, assertic_1.assertTruthy)(typeof v2 === 'bigint');
        return v1 < v2 ? -1 : 1;
    }
    if (typeof v1 === 'string') {
        (0, assertic_1.assertTruthy)(typeof v2 === 'string');
        return v1 < v2 ? -1 : 1;
    }
    if (v1 instanceof Date && v2 instanceof Date) {
        return Math.sign(v1.getTime() - v2.getTime());
    }
    return 0;
}
exports.compareValues = compareValues;
function mapValues(obj, valueMapperFn) {
    const result = {};
    const keys = Object.keys(obj);
    for (const key of keys) {
        const value = obj[key];
        result[key] = valueMapperFn(value, key, obj);
    }
    return result;
}
exports.mapValues = mapValues;
function groupBy(array, getKey) {
    return array.reduce((result, item) => {
        const key = getKey(item);
        if (!result[key]) {
            result[key] = [item];
        }
        else {
            result[key].push(item);
        }
        return result;
    }, {});
}
exports.groupBy = groupBy;
function pick(obj, keys) {
    const result = {};
    for (const key of keys) {
        if (key in obj) {
            result[key] = obj[key];
        }
    }
    return result;
}
exports.pick = pick;
function invert(record) {
    const inverted = {};
    for (const [key, value] of Object.entries(record)) {
        inverted[value] = key;
    }
    return inverted;
}
exports.invert = invert;
function range(start, end, step, maximumNumberOfItems = Infinity) {
    const result = [];
    if (step === 0) {
        throw new Error('Step cannot be zero');
    }
    if ((step > 0 && start >= end) || (step < 0 && start <= end)) {
        return result;
    }
    for (let i = start; (step > 0 ? i < end : i > end) && result.length < maximumNumberOfItems; i += step) {
        result.push(i);
    }
    return result;
}
exports.range = range;
//# sourceMappingURL=object.js.map