"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSquidServiceConfig = exports.setSquidServiceMetadata = exports.getSquidServiceMetadata = exports.getSquidServiceRequestConfig = exports.getOrCreateSquidService = exports.CIRCULAR_DEPENDENCY_ERROR = void 0;
const assertic_1 = require("assertic");
const global_utils_1 = require("./global.utils");
const squidServiceSingletonMap = new Map();
const CURRENT_SQUID_SERVICE_VERSION = 2;
const SQUID_SERVICE_METADATA_KEY = '__squidMetadata';
exports.CIRCULAR_DEPENDENCY_ERROR = 'CIRCULAR_DEPENDENCY';
const instantiationStack = [];
function getOrCreateSquidService(serviceClass, globalConfig, requestConfig) {
    setSquidServiceConfigIfAbsent(globalConfig);
    let service = squidServiceSingletonMap.get(serviceClass);
    if (!service || getSquidServiceMetadata(service).version <= 1) {
        const compatConfig = Object.assign(Object.assign({}, globalConfig), requestConfig);
        (0, assertic_1.assertTruthy)(!instantiationStack.includes(serviceClass), () => { var _a; return `${exports.CIRCULAR_DEPENDENCY_ERROR}: ${(_a = instantiationStack[instantiationStack.length - 1]) === null || _a === void 0 ? void 0 : _a.name} => ${serviceClass.name}`; });
        instantiationStack.push(serviceClass);
        try {
            service = globalConfig.requestLocalStorage.run(requestConfig, () => new serviceClass(compatConfig));
        }
        finally {
            instantiationStack.pop();
        }
        if (getSquidServiceMetadata(service).version > 1) {
            squidServiceSingletonMap.set(serviceClass, service);
        }
    }
    else {
        checkServiceConfigCompatibility(service.config, globalConfig);
        service.config.secrets = globalConfig.secrets;
    }
    return service;
}
exports.getOrCreateSquidService = getOrCreateSquidService;
function getSquidServiceRequestConfig(requestLocalStorage) {
    return (0, assertic_1.truthy)(requestLocalStorage.getStore(), `Failed to access request data outside of the request's scope`);
}
exports.getSquidServiceRequestConfig = getSquidServiceRequestConfig;
function getSquidServiceMetadata(service) {
    const metadata = service[SQUID_SERVICE_METADATA_KEY];
    return metadata || { version: 0 };
}
exports.getSquidServiceMetadata = getSquidServiceMetadata;
function setSquidServiceMetadata(service) {
    service[SQUID_SERVICE_METADATA_KEY] = { version: CURRENT_SQUID_SERVICE_VERSION };
}
exports.setSquidServiceMetadata = setSquidServiceMetadata;
function checkServiceConfigCompatibility(configBefore, configAfter) {
    (0, assertic_1.assertTruthy)(configBefore.backendApiKey === configAfter.backendApiKey, 'backendApiKey does not match.');
    (0, assertic_1.assertTruthy)(configBefore.codeDir === configAfter.codeDir, 'codeDir does not match');
    (0, assertic_1.assertTruthy)(configBefore.environmentId === configAfter.environmentId, 'environmentId does not match');
    (0, assertic_1.assertTruthy)(configBefore.squidDeveloperId === configAfter.squidDeveloperId, 'squidDeveloperId does not match');
    (0, assertic_1.assertTruthy)(configBefore.appId === configAfter.appId, 'appId does not match');
}
const SQUID_GLOBAL_CONFIG_KEY = 'SQUID_GLOBAL_CONFIG';
function getSquidServiceConfig() {
    return (0, assertic_1.truthy)((0, global_utils_1.getGlobal)()[SQUID_GLOBAL_CONFIG_KEY], 'Squid global config is not defined!');
}
exports.getSquidServiceConfig = getSquidServiceConfig;
function setSquidServiceConfigIfAbsent(newConfig) {
    const global = (0, global_utils_1.getGlobal)();
    const oldConfig = global[SQUID_GLOBAL_CONFIG_KEY];
    if (oldConfig) {
        checkServiceConfigCompatibility(oldConfig, newConfig);
    }
    else {
        global[SQUID_GLOBAL_CONFIG_KEY] = newConfig;
    }
}
//# sourceMappingURL=squid-service-utils.js.map