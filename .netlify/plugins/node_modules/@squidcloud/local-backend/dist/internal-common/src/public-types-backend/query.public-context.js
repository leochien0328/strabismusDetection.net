"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryContext = void 0;
const query_public_types_1 = require("../public-types/query.public-types");
const query_types_1 = require("../types/query.types");
const object_1 = require("../utils/object");
const CompareTable = {
    'in:in': (a, b) => a.every((c) => b.includes(c)),
    'in:not in': (a, b) => a.every((c) => !b.includes(c)),
    'not in:not in': (a, b) => b.every((c) => a.includes(c)),
    '>:not in': (a, b) => b.every((c) => a >= c),
    '>=:not in': (a, b) => b.every((c) => a > c),
    '<:not in': (a, b) => b.every((c) => a <= c),
    '<=:not in': (a, b) => b.every((c) => a < c),
    '>:>': (a, b) => a >= b,
    '>=:>': (a, b) => a > b,
    'in:>': (a, b) => a.every((c) => c > b),
    '>:>=': (a, b) => a >= b,
    '>=:>=': (a, b) => a >= b,
    'in:>=': (a, b) => a.every((c) => c >= b),
    '<:<': (a, b) => a <= b,
    '<=:<': (a, b) => a < b,
    'in:<': (a, b) => a.every((c) => c < b),
    '<:<=': (a, b) => a <= b,
    '<=:<=': (a, b) => a <= b,
    'in:<=': (a, b) => a.every((c) => c <= b),
    'like:like': (a, b) => isSubqueryString(a.toLowerCase(), b.toLowerCase()),
    'like_cs:like': (a, b) => isSubqueryString(a.toLowerCase(), b.toLowerCase()),
    'like:like_cs': (a, b) => isSubqueryString(a, b) && containsNoAlphabetical(b),
    'like_cs:like_cs': (a, b) => isSubqueryString(a, b),
    'like:not like': (a, b) => !hasOverlap(a.toLowerCase(), b.toLowerCase()),
    'like_cs:not like': (a, b) => !hasOverlap(a.toLowerCase(), b.toLowerCase()),
    'like:not like_cs': (a, b) => !hasOverlap(a.toLowerCase(), b.toLowerCase()),
    'like_cs:not like_cs': (a, b) => !hasOverlap(a, b),
    'not like:like': (a, b) => notLikeAndLike(a, b),
    'not like_cs:like': (a, b) => notLikeAndLike(a, b),
    'not like:like_cs': (a, b) => notLikeAndLike(a, b),
    'not like_cs:like_cs': (a, b) => notLikeAndLike(a, b),
    'not like:not like': (a, b) => isSubqueryString(b.toLowerCase(), a.toLowerCase()),
    'not like_cs:not like': (a, b) => isSubqueryString(b, a) && containsNoAlphabetical(a),
    'not like:not like_cs': (a, b) => isSubqueryString(b.toLowerCase(), a.toLowerCase()),
    'not like_cs:not like_cs': (a, b) => isSubqueryString(b, a),
    'in:like': (a, b) => a.every(s => (0, query_types_1.compareOperator)(b, s, 'like')),
    'in:like_cs': (a, b) => a.every(s => (0, query_types_1.compareOperator)(b, s, 'like_cs')),
    'in:not like': (a, b) => a.every(s => (0, query_types_1.compareOperator)(b, s, 'not like')),
    'in:not like_cs': (a, b) => a.every(s => (0, query_types_1.compareOperator)(b, s, 'not like_cs')),
    'like:in': (a, b) => !a.includes('%') && !a.includes('_') && !!b.find(s => s.toLowerCase() === a.toLowerCase()),
    'like_cs:in': (a, b) => !a.includes('%') && !a.includes('_') && b.includes(a),
    'not like:in': (a, b) => (a.length > 0 && isStringAllWildcard(a)) || (matchesAllNonEmptyStrings(a) && b.includes('')),
    'not like_cs:in': (a, b) => (a.length > 0 && isStringAllWildcard(a)) || (matchesAllNonEmptyStrings(a) && b.includes('')),
    'not in:like': (a, b) => (b.length > 0 && isStringAllWildcard(b)) || (matchesAllNonEmptyStrings(b) && a.includes('')),
    'not in:like_cs': (a, b) => (b.length > 0 && isStringAllWildcard(b)) || (matchesAllNonEmptyStrings(b) && a.includes('')),
    'not in:not like': (a, b) => !b.includes('%') && !b.includes('_') && !!a.find(s => s.toLowerCase() === b.toLowerCase()),
    'not in:not like_cs': (a, b) => !b.includes('%') && !b.includes('_') && a.includes(b),
    'like:not in': (a, b) => b.every(s => (0, query_types_1.compareOperator)(a, s, 'not like')),
    'like_cs:not in': (a, b) => b.every(s => (0, query_types_1.compareOperator)(a, s, 'not like_cs')),
    'not like:not in': (a, b) => b.every(s => (0, query_types_1.compareOperator)(a, s, 'like')),
    'not like_cs:not in': (a, b) => b.every(s => (0, query_types_1.compareOperator)(a, s, 'like_cs')),
    'array_includes_some:array_includes_some': (a, b) => a.every((c) => b.includes(c)),
    'array_includes_all:array_includes_all': (a, b) => a.every((c) => b.includes(c)),
    'array_not_includes:array_not_includes': (a, b) => b.every((c) => a.includes(c)),
    'array_includes_some:array_not_includes': (a, b) => a.every((c) => !b.includes(c)),
    'array_not_includes:array_includes_some': (a, b) => b.every((c) => !a.includes(c)),
    'array_includes_all:array_includes_some': (a, b) => a.every((c) => b.includes(c)),
    'array_includes_some:array_includes_all': (a, b) => a.every((c) => b.includes(c)),
    'array_not_includes:array_includes_all': (a, b) => b.every((c) => !a.includes(c)),
    'array_includes_all:array_not_includes': (a, b) => a.every((c) => !b.includes(c)),
};
function isSubqueryString(subquery, query, ind1 = 0, ind2 = 0) {
    if (ind2 >= query.length) {
        return ind1 >= subquery.length;
    }
    if (ind1 >= subquery.length) {
        return isStringAllWildcard(query.substring(ind2));
    }
    const char1 = subquery[ind1];
    const char2 = query[ind2];
    if (char1 === '%' && char2 === '%') {
        return isSubqueryString(subquery, query, ind1 + 1, ind2 + 1) || isSubqueryString(subquery, query, ind1 + 1, ind2);
    }
    if (char1 === '%') {
        return false;
    }
    if (char2 === '%') {
        return isSubqueryString(subquery, query, ind1, ind2 + 1) || isSubqueryString(subquery, query, ind1 + 1, ind2);
    }
    return char1 === char2 || char2 === '_' ? isSubqueryString(subquery, query, ind1 + 1, ind2 + 1) : false;
}
function hasOverlap(exp1, exp2, ind1 = 0, ind2 = 0) {
    if (ind1 >= exp1.length && ind2 >= exp2.length) {
        return true;
    }
    if (ind1 >= exp1.length) {
        return isStringAllWildcard(exp2.substring(ind2));
    }
    if (ind2 >= exp2.length) {
        return isStringAllWildcard(exp1.substring(ind1));
    }
    const char1 = ind1 < exp1.length ? exp1[ind1] : '';
    const char2 = ind2 < exp2.length ? exp2[ind2] : '';
    if (char1 === '%' && char2 === '%') {
        return (hasOverlap(exp1, exp2, ind1 + 1, ind2 + 1) ||
            hasOverlap(exp1, exp2, ind1, ind2 + 1) ||
            hasOverlap(exp1, exp2, ind1 + 1, ind2));
    }
    else if (char1 === '%') {
        return hasOverlap(exp1, exp2, ind1, ind2 + 1) || hasOverlap(exp1, exp2, ind1 + 1, ind2);
    }
    else if (char2 === '%') {
        return hasOverlap(exp1, exp2, ind1, ind2 + 1) || hasOverlap(exp1, exp2, ind1 + 1, ind2);
    }
    return char1 === char2 || char1 === '_' || char2 === '_' ? hasOverlap(exp1, exp2, ind1 + 1, ind2 + 1) : false;
}
function containsNoAlphabetical(s) {
    return !/[a-zA-Z]/.test(s);
}
function isStringAllWildcard(s) {
    return s.split('').every(c => c === '%');
}
function notLikeAndLike(subQuery, query) {
    return ((subQuery.length > 0 && isStringAllWildcard(subQuery)) ||
        (query.length > 0 && isStringAllWildcard(query)) ||
        (matchesAllNonEmptyStrings(subQuery) && query.length === 0));
}
function matchesAllNonEmptyStrings(pattern) {
    let seenPercent = false;
    let seenUnderscore = false;
    for (const c of pattern) {
        switch (c) {
            case '%':
                seenPercent = true;
                break;
            case '_':
                if (seenUnderscore) {
                    return false;
                }
                seenUnderscore = true;
                break;
            default:
                return false;
        }
    }
    return seenPercent && seenUnderscore;
}
class QueryContext {
    constructor(query) {
        this.query = query;
        this.query = query;
        this.parsedConditions = this.parseConditions(this.query.conditions.filter(query_public_types_1.isSimpleCondition));
    }
    get integrationId() {
        return this.query.integrationId;
    }
    get collectionName() {
        return this.query.collectionName;
    }
    get limit() {
        return this.query.limit;
    }
    sortedBy(sorts) {
        const mismatch = sorts.find((fieldSort, index) => {
            var _a;
            return !(0, object_1.isEqual)(this.query.sortOrder[index], Object.assign(Object.assign({}, fieldSort), { asc: (_a = fieldSort.asc) !== null && _a !== void 0 ? _a : true }));
        });
        return !mismatch;
    }
    sortedByExact(sorts) {
        if (sorts.length !== this.query.sortOrder.length)
            return false;
        return this.sortedBy(sorts);
    }
    isSubqueryOf(fieldName, operator, value) {
        return this.isSubqueryOfCondition({
            fieldName,
            operator,
            value,
        });
    }
    isSubqueryOfCondition(condition) {
        const conditions = this.parsedConditions.filter(c => c.fieldName === condition.fieldName);
        return !!conditions.find(c => this.evaluateSubset(c, condition));
    }
    isSubqueryOfConditions(conditions) {
        const parsedConditions = this.parseConditions(conditions);
        return parsedConditions.every(c => this.isSubqueryOfCondition(c));
    }
    isSubqueryOfQuery(query) {
        if (query.collectionName !== this.collectionName || query.integrationId !== this.integrationId)
            return false;
        const simpleConditions = query.conditions.filter(query_public_types_1.isSimpleCondition);
        const subsetOfConditions = this.isSubqueryOfConditions(simpleConditions);
        const subsetOfOrder = this.sortedBy(query.sortOrder);
        const withinLimit = query.limit === -1 || (this.limit > -1 && this.limit < query.limit);
        return subsetOfConditions && subsetOfOrder && withinLimit;
    }
    getConditionsFor(...fieldNames) {
        return this.parsedConditions.filter(cond => fieldNames.includes(cond.fieldName));
    }
    getConditionsForField(fieldName) {
        return this.parsedConditions.filter(cond => cond.fieldName === fieldName);
    }
    documentMatchesQuery(doc) {
        for (const contextCondition of this.parsedConditions) {
            const fieldNameOrPath = contextCondition.fieldName;
            const operator = contextCondition.operator;
            const valueInDoc = (0, object_1.getInPath)(doc, fieldNameOrPath);
            if (operator === 'in') {
                if (contextCondition.value.includes(valueInDoc)) {
                    continue;
                }
                return false;
            }
            else if (operator === 'not in') {
                if (contextCondition.value.includes(valueInDoc)) {
                    return false;
                }
                continue;
            }
            if (!(0, query_types_1.compareOperator)(contextCondition.value, valueInDoc, operator)) {
                return false;
            }
        }
        return true;
    }
    evaluateSubset(queryCondition, testCondition) {
        const { operator: queryOperator, value: queryValue } = queryCondition;
        const { operator, value } = this.parseConditions([testCondition])[0];
        const compareFunction = CompareTable[`${queryOperator}:${operator}`];
        if (!compareFunction)
            return false;
        return compareFunction(queryValue, value);
    }
    evaluateIncludes(queryCondition, testCondition) {
        const { operator: queryOperator, value: queryValue } = queryCondition;
        const { operator, value } = this.parseConditions([testCondition])[0];
        const sortedQueryValue = Array.isArray(queryValue) ? queryValue.sort() : queryValue;
        const sortedValue = Array.isArray(value) ? value.sort() : value;
        return operator === queryOperator && (0, object_1.isEqual)(sortedValue, sortedQueryValue);
    }
    parseConditions(conditions) {
        const parsedConditions = [];
        const inMap = new Map();
        const notInMap = new Map();
        conditions.forEach(c => {
            switch (c.operator) {
                case '==':
                case 'in':
                    inMap.set(c.fieldName, (inMap.get(c.fieldName) || []).concat(c.value));
                    break;
                case '!=':
                case 'not in':
                    notInMap.set(c.fieldName, (notInMap.get(c.fieldName) || []).concat(c.value));
                    break;
                default:
                    parsedConditions.push(c);
                    break;
            }
        });
        inMap.forEach((value, fieldName) => {
            parsedConditions.push({
                fieldName: fieldName,
                operator: 'in',
                value: value,
            });
        });
        notInMap.forEach((value, fieldName) => {
            parsedConditions.push({
                fieldName: fieldName,
                operator: 'not in',
                value: value,
            });
        });
        return parsedConditions;
    }
}
exports.QueryContext = QueryContext;
//# sourceMappingURL=query.public-context.js.map