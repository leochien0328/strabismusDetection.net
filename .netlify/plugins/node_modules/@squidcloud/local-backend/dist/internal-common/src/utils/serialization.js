"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeValueForMapping = exports.encodeValueForMapping = exports.deserializeObj = exports.serializeObj = exports.normalizeJsonAsString = void 0;
const object_1 = require("./object");
function sortKeys(json) {
    if (Array.isArray(json)) {
        return json.map(o => sortKeys(o));
    }
    if (typeof json !== 'object' || json === null || json instanceof Date) {
        return json;
    }
    const keys = Object.keys(json);
    const result = {};
    keys.sort().forEach(key => {
        result[key] = sortKeys(json[key]);
    });
    return result;
}
function normalizeJsonAsString(json) {
    return serializeObj(sortKeys(json));
}
exports.normalizeJsonAsString = normalizeJsonAsString;
function serializeObj(obj) {
    if (obj === undefined)
        return null;
    const objWithReplacedDates = (0, object_1.cloneDeep)(obj, value => (0, object_1.isDateObject)(value) ? { $date: value.toISOString() } : undefined);
    return JSON.stringify(objWithReplacedDates);
}
exports.serializeObj = serializeObj;
function deserializeObj(str) {
    const deserializedObj = JSON.parse(str);
    return (0, object_1.cloneDeep)(deserializedObj, value => {
        if (value === null || typeof value !== 'object') {
            return undefined;
        }
        const record = value;
        const date = record['$date'];
        return date && Object.keys(record).length === 1 ? new Date(date) : undefined;
    });
}
exports.deserializeObj = deserializeObj;
function encodeValueForMapping(value) {
    if (value === undefined)
        throw new Error('INVALID_ENCODE_VALUE');
    const serializedValue = serializeObj(value);
    if (typeof Buffer !== 'undefined') {
        return Buffer.from(serializedValue, 'utf8').toString('base64');
    }
    else {
        const bytes = new TextEncoder().encode(serializedValue);
        let binary = '';
        for (let i = 0; i < bytes.length; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    }
}
exports.encodeValueForMapping = encodeValueForMapping;
function decodeValueForMapping(encodedString) {
    let decodedValue;
    if (typeof Buffer !== 'undefined') {
        decodedValue = Buffer.from(encodedString, 'base64').toString('utf8');
    }
    else {
        const binary = atob(encodedString);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < bytes.length; i++) {
            bytes[i] = binary.charCodeAt(i);
        }
        decodedValue = new TextDecoder().decode(bytes);
    }
    return deserializeObj(decodedValue);
}
exports.decodeValueForMapping = decodeValueForMapping;
//# sourceMappingURL=serialization.js.map