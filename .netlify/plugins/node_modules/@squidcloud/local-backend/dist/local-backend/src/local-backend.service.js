"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalBackendService = void 0;
const common_1 = require("@nestjs/common");
const promise_pool_1 = require("@supercharge/promise-pool");
const assertic_1 = require("assertic");
const serialization_1 = require("../../internal-common/src/utils/serialization");
const async_hooks_1 = require("async_hooks");
const backend_transforms_1 = require("../../internal-common/src/utils/backend-transforms");
const squid_service_utils_1 = require("../../internal-common/src/utils/squid-service-utils");
const requestLocalStorage = new async_hooks_1.AsyncLocalStorage();
let LocalBackendService = class LocalBackendService {
    constructor(backendService) {
        this.backendService = backendService;
    }
    async executeActionRequest(actionRequest) {
        const { action } = actionRequest;
        if (action !== 'executeFunction') {
            console.error('UNSUPPORTED ACTION!!! ', action);
            return { ok: false, error: 'INVALID_ACTION', functionName: 'unknown' };
        }
        const payload = actionRequest.payload;
        const functionName = payload.functionName;
        const [serviceName, fnName] = functionName.split(':');
        let fn;
        let service;
        let serviceGlobalConfig;
        let serviceRequestConfig;
        if (serviceName === 'default') {
            fn = this.backendService[serviceName][fnName];
            (0, assertic_1.assertTruthy)(typeof fn === 'function', `${serviceName}.${fnName} is not a function`);
        }
        else {
            const Service = this.backendService[serviceName];
            (0, assertic_1.assertTruthy)(Service, () => `Service not found: ${serviceName}`);
            (0, assertic_1.assertTruthy)(this.secrets, 'Secrets must be defined in executeActionRequest');
            serviceGlobalConfig = {
                secrets: this.secrets.custom,
                backendApiKey: payload.backendApiKey,
                appId: payload.context.appId,
                codeDir: '',
                requestLocalStorage,
            };
            serviceRequestConfig = {
                context: payload.context,
                auth: payload.auth,
            };
            service = (0, squid_service_utils_1.getOrCreateSquidService)(Service, serviceGlobalConfig, serviceRequestConfig);
            const squidServiceMethod = service[fnName];
            (0, assertic_1.assertTruthy)(typeof squidServiceMethod === 'function', `${serviceName}.${fnName} is not a function`);
            fn = squidServiceMethod.bind(service);
        }
        if (!fn) {
            return { ok: false, error: 'FUNCTION_NOT_FOUND', functionName: payload.functionName };
        }
        let lock;
        const lockName = `__squid_internal_lock_fn_exec_${functionName}`;
        const executeFunctionAnnotationType = payload.executeFunctionAnnotationType;
        const params = payload.params;
        try {
            if (executeFunctionAnnotationType === 'scheduler' && params.length && params[0]) {
                (0, assertic_1.assertTruthy)(service, 'service is not defined.');
                try {
                    const { squid } = service;
                    if (squid.acquireLock) {
                        lock = await squid.acquireLock(lockName);
                    }
                }
                catch (err) {
                    return { ok: true, functionResponse: undefined };
                }
            }
            const transformedParams = (0, backend_transforms_1.transformParams)(params, executeFunctionAnnotationType);
            const functionResponse = serviceGlobalConfig && serviceRequestConfig
                ? await serviceGlobalConfig.requestLocalStorage.run(serviceRequestConfig, () => fn(...transformedParams))
                : await fn(...transformedParams);
            const transformedResponse = (0, backend_transforms_1.transformResponse)(functionResponse, executeFunctionAnnotationType);
            return { ok: true, functionResponse: transformedResponse };
        }
        catch (err) {
            if ((0, backend_transforms_1.isWebhookResponse)(err) || (0, backend_transforms_1.isOpenApiResponse)(err)) {
                const transformedResponse = (0, backend_transforms_1.transformResponse)(err, executeFunctionAnnotationType);
                return { ok: true, functionResponse: transformedResponse };
            }
            console.error('Error while invoking function ' + fnName, err);
            return { ok: false, error: 'FUNCTION_ERROR', details: err === null || err === void 0 ? void 0 : err.message, functionName: fnName };
        }
        finally {
            if (lock) {
                lock.release();
            }
        }
    }
    async processRunCodeAndRespond(batchRequest, res) {
        const { responses, errored } = await this.processRunCode(batchRequest);
        res
            .set('Content-Type', 'application/json')
            .status(errored ? 500 : 200)
            .send((0, serialization_1.serializeObj)(responses));
    }
    async processRunCode(batchRequest) {
        const secrets = (0, assertic_1.truthy)(this.secrets, 'Secrets are required');
        const responses = Array(batchRequest.requests.length);
        let stop = false;
        let errored = false;
        await promise_pool_1.PromisePool.for(batchRequest.requests)
            .withConcurrency(10)
            .process(async (request, index) => {
            var _a;
            if (stop) {
                return;
            }
            try {
                const payload = {
                    secrets: secrets.custom,
                    backendApiKey: secrets.backendApiKey,
                    functionName: request.functionName,
                    params: request.params,
                    auth: batchRequest.auth,
                    context: batchRequest.context,
                    codeDir: process.cwd(),
                    executeFunctionAnnotationType: batchRequest.executeFunctionAnnotationType,
                };
                const response = await this.executeActionRequest({
                    action: 'executeFunction',
                    payload,
                });
                if (stop) {
                    return;
                }
                if (!response.ok ||
                    (batchRequest.configuration.isSecurityRules && !response.functionResponse.rulesPassed)) {
                    errored = errored || !response.ok;
                    stop = true;
                    responses.splice(0);
                    responses.push(response);
                    return;
                }
                responses[index] = response;
            }
            catch (e) {
                errored = true;
                stop = true;
                responses.splice(0);
                responses.push({
                    ok: false,
                    error: (_a = e === null || e === void 0 ? void 0 : e.message) !== null && _a !== void 0 ? _a : 'Unexpected error in processRunCode',
                    functionName: request.functionName,
                });
            }
        });
        return { responses, errored };
    }
    async initializeAndGetBackendData(secrets, appId) {
        this.secrets = secrets;
        const { responses } = await this.processRunCode({
            secrets,
            auth: undefined,
            context: { appId },
            configuration: {
                isSecurityRules: false,
                permissions: { hosts: [] },
                codeUrl: '',
                codeUrlId: '',
            },
            requests: [
                {
                    functionName: 'default:metadata',
                    params: [],
                },
            ],
            executeFunctionAnnotationType: 'metadata',
        });
        const response = responses[0];
        return response.functionResponse;
    }
};
exports.LocalBackendService = LocalBackendService;
exports.LocalBackendService = LocalBackendService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, common_1.Inject)('BACKEND_SERVICE')),
    __metadata("design:paramtypes", [Object])
], LocalBackendService);
//# sourceMappingURL=local-backend.service.js.map