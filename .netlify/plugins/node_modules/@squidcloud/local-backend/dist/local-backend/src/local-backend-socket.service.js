"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalBackendSocketService = void 0;
const common_1 = require("@nestjs/common");
const local_backend_service_1 = require("./local-backend.service");
const rxjs_1 = require("rxjs");
const assertic_1 = require("assertic");
const shell_runner_1 = require("./utils/shell-runner");
const fs = __importStar(require("fs/promises"));
const fsSync = __importStar(require("fs"));
const local_dev_types_1 = require("../../internal-common/src/local-dev.types");
const http_1 = require("../../internal-common/src/utils/http");
const websocket_impl_1 = require("../../internal-common/src/websocket.impl");
const global_utils_1 = require("../../internal-common/src/utils/global.utils");
const serialization_1 = require("../../internal-common/src/utils/serialization");
const communication_types_1 = require("../../internal-common/src/types/communication.types");
const logger_types_1 = require("../../internal-common/src/types/logger.types");
const cliBox = require('cli-box');
let LocalBackendSocketService = class LocalBackendSocketService {
    constructor(localBackendService) {
        this.localBackendService = localBackendService;
        this.appId = (0, assertic_1.truthy)(process.env['SQUID_APP_ID'], 'SQUID_APP_ID_MUST_BE_PROVIDED');
        this.region = (0, assertic_1.truthy)(process.env['SQUID_REGION'], 'SQUID_REGION_MUST_BE_PROVIDED');
        this.apiKey = (0, assertic_1.truthy)(process.env['SQUID_API_KEY'], 'SQUID_API_KEY_MUST_BE_PROVIDED');
        this.environmentId = (0, assertic_1.truthy)(process.env['SQUID_ENVIRONMENT_ID'], 'SQUID_ENVIRONMENT_ID_MUST_BE_PROVIDED');
        this.squidDeveloperId = (0, assertic_1.truthy)(process.env['SQUID_DEVELOPER_ID'], 'SQUID_DEVELOPER_ID_MUST_BE_PROVIDED');
        this.connectionReady = new rxjs_1.BehaviorSubject(false);
        this.fullAppId = (0, communication_types_1.appIdWithEnvironmentIdAndDevId)(this.appId, this.environmentId, this.squidDeveloperId);
        this.logTypes = new Set();
        this.readLogTypes();
        if (this.squidDeveloperId === 'prod') {
            console.error('The local backend can only be run using the "dev" environment. Please follow the instructions in: https://docs.squid.cloud/docs/development-tools/local-dev-cli');
            process.exit(1);
        }
        this.socketEndpoint = (0, http_1.getApplicationUrl)(this.region, this.fullAppId, 'ws/localdev')
            .replace('https', 'wss')
            .replace('http', 'ws');
        const query = { apiKey: this.apiKey };
        const queryString = Object.entries(query)
            .map(([key, value]) => `${key}=${value}`)
            .join('&');
        this.socket = (0, websocket_impl_1.createWebSocketWrapper)(`${this.socketEndpoint}?${queryString}`, {
            timeoutMillis: 5000,
            onmessage: (e) => this.onMessage(e.data),
            onopen: () => {
                global_utils_1.DebugLogger.debug(`Connection to socket established. Endpoint: ${this.socketEndpoint}`);
            },
            onreconnect: () => {
                global_utils_1.DebugLogger.debug(`WebSocket reconnect event triggered`);
                this.connectionReady.next(false);
            },
            onclose: () => {
                global_utils_1.DebugLogger.debug(`WebSocket onclose event triggered`);
                this.connectionReady.next(false);
            },
            onerror: (e) => console.error('WebSocket error:', e),
        });
    }
    async onMessage(messageStr) {
        const message = (0, serialization_1.deserializeObj)(messageStr);
        global_utils_1.DebugLogger.debug('Received message from server: ', messageStr);
        switch (message.type) {
            case 'localBackendData':
                this.connectionReady.next(true);
                const bundleData = await this.localBackendService.initializeAndGetBackendData(message.payload.secrets, this.appId);
                const openApiSpecAndControllers = await this.generateOpenApiSpecAndControllers();
                if (openApiSpecAndControllers === null || openApiSpecAndControllers === void 0 ? void 0 : openApiSpecAndControllers.openApiControllersStr) {
                    bundleData.openApiControllers = (0, serialization_1.deserializeObj)(openApiSpecAndControllers.openApiControllersStr);
                }
                const payload = {
                    applicationBundleData: bundleData,
                    openApiSpecStr: openApiSpecAndControllers === null || openApiSpecAndControllers === void 0 ? void 0 : openApiSpecAndControllers.openApiSpecStr,
                };
                const bundleDataMessage = {
                    type: 'bundleData',
                    requestId: message.requestId,
                    payload,
                };
                await this.sendMessageThroughSocket(bundleDataMessage);
                this.printInfoAboutBundleData(bundleData);
                break;
            case 'executeFunction':
                await this.handleExecuteFunctionMessage(message);
                break;
            case 'logMessage':
                await this.handleLogMessage(message);
                break;
            default:
                console.error('Unsupported message type: ', message.type);
                break;
        }
    }
    async handleExecuteFunctionMessage(message) {
        const { responses } = await this.localBackendService.processRunCode(message.payload);
        const response = {
            type: 'response',
            requestId: message.requestId,
            payload: responses,
        };
        await this.sendMessageThroughSocket(response);
    }
    async handleLogMessage(message) {
        if (message.payload.type !== local_dev_types_1.LogType.ERROR &&
            !this.logTypes.has(local_dev_types_1.LogType.ALL) &&
            !this.logTypes.has(message.payload.type)) {
            return;
        }
        const outputMessage = `[${new Date(message.payload.timestamp).toISOString()}][Squid Core][${message.payload.level}][${message.payload.tag}]: ${message.payload.message}`;
        switch (message.payload.level) {
            case logger_types_1.LogLevel.ERROR:
                console.error(outputMessage);
                break;
            case logger_types_1.LogLevel.WARN:
                console.warn(outputMessage);
                break;
            case logger_types_1.LogLevel.DEBUG:
                console.debug(outputMessage);
                break;
            case logger_types_1.LogLevel.TRACE:
                console.trace(outputMessage);
                break;
            case logger_types_1.LogLevel.INFO:
            default:
                console.log(outputMessage);
        }
    }
    async sendMessageThroughSocket(message) {
        global_utils_1.DebugLogger.debug(`Sending local-dev message to server : ${JSON.stringify(message)}`);
        await (0, rxjs_1.firstValueFrom)(this.connectionReady.pipe((0, rxjs_1.filter)(Boolean)));
        this.socket.send((0, serialization_1.serializeObj)(message));
    }
    printInfoAboutBundleData(bundleData) {
        const webhooks = Object.entries(bundleData.webhooks || {});
        if (webhooks.length) {
            let message = 'Available webhooks:';
            for (const [id] of webhooks) {
                message += `\nWebhook URL for ${id}: ${(0, http_1.getApplicationUrl)(this.region, this.fullAppId, `webhooks/${id}`)}`;
            }
            console.log(cliBox({ w: 200, h: webhooks.length + 3, marks: { w: '| ', ne: '─┐', se: '─┘' } }, { text: message, autoEOL: true, vAlign: 'center', hAlign: 'left', stretch: false }));
        }
        const openApiControllers = bundleData.openApiControllers || [];
        if (openApiControllers.length) {
            const baseUrl = (0, http_1.getApplicationUrl)(this.region, this.fullAppId, `openapi`);
            let message = `Available OpenAPI controllers (spec file: ${baseUrl}/spec.json):`;
            let itemCount = openApiControllers.length;
            for (const controller of openApiControllers) {
                message += `\nController ${controller.path}:`;
                for (const action of controller.actions) {
                    itemCount += 1;
                    message += `\n\   ${action.method.toUpperCase()} ${baseUrl}${action.fullPath}`;
                }
            }
            console.log(cliBox({ w: 200, h: itemCount + 3, marks: { w: '| ', ne: '─┐', se: '─┘' } }, { text: message, autoEOL: true, vAlign: 'center', hAlign: 'left', stretch: false }));
        }
    }
    readLogTypes() {
        const logTypes = process.env['SQUID_LOG_TYPES'];
        if (logTypes) {
            const supportedTypes = Object.values(local_dev_types_1.LogType);
            const typeList = logTypes.split(',');
            for (let type of typeList) {
                type = type.trim();
                if (!supportedTypes.includes(type)) {
                    console.error(`Error: Log type "${type}" provided to "SQUID_LOG_TYPES" in '.env' file is not valid.

Expected one of: ${supportedTypes.join(', ')}.`);
                    process.exit(1);
                }
                this.logTypes.add(type);
            }
        }
    }
    async generateOpenApiSpecAndControllers() {
        const tsoaJsonLocation = fsSync.existsSync('tsoa.json')
            ? 'tsoa.json'
            : 'node_modules/@squidcloud/local-backend/dist/local-backend/tsoa.json';
        try {
            await Promise.all([
                (0, shell_runner_1.runInShell)(`npx tsoa spec -c ${tsoaJsonLocation}`, process.cwd()),
                (0, shell_runner_1.runInShell)(`npx tsoa routes -c ${tsoaJsonLocation}`, process.cwd()),
            ]);
        }
        catch (e) {
            return;
        }
        try {
            const swaggerData = await fs.readFile('./dist/swagger.json', { encoding: 'utf8' });
            const routesData = await fs.readFile('./dist/routes.ts', { encoding: 'utf8' });
            return {
                openApiSpecStr: swaggerData,
                openApiControllersStr: routesData,
            };
        }
        catch (e) {
            console.error('Unable to deploy OpenAPI spec and controllers', e);
        }
        return undefined;
    }
};
exports.LocalBackendSocketService = LocalBackendSocketService;
exports.LocalBackendSocketService = LocalBackendSocketService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [local_backend_service_1.LocalBackendService])
], LocalBackendSocketService);
//# sourceMappingURL=local-backend-socket.service.js.map