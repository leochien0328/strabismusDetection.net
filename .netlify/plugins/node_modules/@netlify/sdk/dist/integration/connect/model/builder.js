import { writeFileSync } from "fs";
import { join } from "path";
import { ModelDefinition, builtInTypes, mappedBuiltinTypes, } from "./definition.js";
import { ModelError } from "./error.js";
export class ModelBuilder {
    models = new Map();
    extendedModels = new Map();
    modelDataAPIs;
    complete = false;
    sdl = ``;
    locales = [];
    typePrefix = ``;
    nodesApi;
    createApi;
    createId;
    slug;
    supports;
    // original -> pascal
    pascaledNames = new Map();
    seenTypePaths = new Map();
    shouldAutoRenameFieldsAndModels = true;
    constructor({ nodesApi, createApi, supports, slug, createId, }) {
        this.nodesApi = nodesApi;
        this.createApi = createApi;
        this.supports = supports;
        this.slug = slug;
        this.createId = createId;
        this.reset();
    }
    defineAPI({ isInternalType, isExtendedDefinition, }) {
        const { nodesApi, createApi, shouldAutoRenameFieldsAndModels, supports } = this;
        return {
            /**
             *
             */
            crossReference: (args) => new ModelDefinition({
                ...args,
                createId: this.createId,
                kind: `CrossReference`,
                ModelBuilder: this,
                nodesApi,
                createApi,
                shouldAutoRenameFieldsAndModels,
                supports,
                isInternalType,
                isInlineType: true,
            }),
            /**
             * Defines an enum scalar type. Enum types are used to define fields on node models where the field may only contain one of the values specified as
             * part of the type definition.
             */
            enum: (args) => new ModelDefinition({
                ...args,
                createId: this.createId,
                kind: `Enum`,
                ModelBuilder: this,
                nodesApi,
                createApi,
                shouldAutoRenameFieldsAndModels,
                supports,
                isInternalType,
            }),
            /**
             * Defines an enum scalar type. Enum types are used to define fields on node models where the field may only contain one of the values specified as
             * part of the type definition.
             * Inline enum types are identical to object types, but do not require a name. The name will be generated by hashing the definition.
             */
            inlineEnum: (args) => new ModelDefinition({
                ...args,
                createId: this.createId,
                kind: `Enum`,
                ModelBuilder: this,
                nodesApi,
                createApi,
                shouldAutoRenameFieldsAndModels,
                supports,
                isInternalType,
                isInlineType: true,
            }),
            /**
             * @warning - this is an experimental API. Only use if you know what you're doing
             */
            document: (args) => new ModelDefinition({
                ...args,
                createId: this.createId,
                supports,
                kind: `Node`,
                ModelBuilder: this,
                nodesApi,
                createApi,
                shouldAutoRenameFieldsAndModels,
                isInternalType,
                isExtendedDefinition,
            }),
            /**
             * Defines a node model. Nodes are database records that can be queried by their ID. Defining a type allows you to create and update nodes of that type during the createAllNodes and updateNodes data events.
             */
            nodeModel: (args) => new ModelDefinition({
                ...args,
                createId: this.createId,
                supports,
                kind: `Node`,
                ModelBuilder: this,
                nodesApi,
                createApi,
                shouldAutoRenameFieldsAndModels,
                isInternalType,
            }),
            /**
             * Defines an object type. Object types are used to define fields on node models.
             */
            object: (args) => new ModelDefinition({
                ...args,
                createId: this.createId,
                supports,
                kind: `Object`,
                ModelBuilder: this,
                nodesApi,
                createApi,
                shouldAutoRenameFieldsAndModels,
                isInternalType,
            }),
            /**
             * Defines an inline object type. Object types are used to define fields on node models.
             * Inline object types are identical to object types, but do not require a name. The name will be generated by hashing the definition.
             */
            inlineObject: (args) => new ModelDefinition({
                ...args,
                createId: this.createId,
                supports,
                kind: `Object`,
                ModelBuilder: this,
                nodesApi,
                createApi,
                shouldAutoRenameFieldsAndModels,
                isInternalType,
                isInlineType: true,
            }),
            /**
             * Defines a union type. Union types are used to define fields on node models where the field may be of multiple different types.
             */
            union: (args) => new ModelDefinition({
                ...args,
                createId: this.createId,
                supports: this.supports,
                kind: `Union`,
                ModelBuilder: this,
                nodesApi,
                createApi,
                shouldAutoRenameFieldsAndModels,
                isInternalType,
            }),
            /**
             * Defines a union type. Union types are used to define fields on node models where the field may be of multiple different types.
             * Inline union types are identical to object types, but do not require a name. The name will be generated by hashing the definition.
             */
            inlineUnion: (args) => new ModelDefinition({
                ...args,
                createId: this.createId,
                supports: this.supports,
                kind: `Union`,
                ModelBuilder: this,
                nodesApi,
                createApi,
                shouldAutoRenameFieldsAndModels,
                isInternalType,
                isInlineType: true,
            }),
            /**
             * @warning this is an experimental API. Only use if you know what you're doing :)
             */
            locales: (locales) => {
                this.locales = locales;
            },
        };
    }
    get pluginAPI() {
        return {
            define: this.defineAPI({ isInternalType: false }),
            extend: {
                Asset: (definition) => {
                    // for now only allow extending the builtin Asset model
                    const extended = this.defineAPI({
                        // not an internal type since the connector dev is adding this extended definition
                        isInternalType: false,
                        isExtendedDefinition: true,
                    }).document({
                        name: `Asset`,
                        fields: definition.fields,
                    });
                    // FIXME(ndhoule): Incorrect type (https://github.com/netlify/sdk/pull/1170#discussion_r1556157222)
                    // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression
                    return this.models
                        .get(`Asset`)
                        ?._mergeExtendedDefinition(extended, this);
                },
            },
        };
    }
    get defineInternal() {
        return this.defineAPI({ isInternalType: true });
    }
    defineInternalCreateModels() {
        if (!this.supports.create) {
            return;
        }
        this.defineInternal.enum({
            name: `StatusEnum`,
            values: [`published`, `added`, `modified`],
        });
        this.defineInternal.object({
            name: `Thumbnail`,
            fields: {
                label: {
                    type: `String`,
                    required: true,
                    description: `The label of the thumbnail image in the editor`,
                },
                thumbnail: {
                    type: `url`,
                    required: true,
                    description: `The URL of the thumbnail image`,
                },
                value: {
                    type: `String`,
                    required: true,
                },
            },
        });
        this.defineInternal.document({
            name: `Asset`,
            editor: {
                label: `Asset`,
            },
            fields: {
                title: {
                    type: `String`,
                    required: true,
                },
                url: {
                    type: `String`,
                    required: true,
                },
                fileName: {
                    type: `String`,
                },
                contentType: {
                    type: `String`,
                },
                size: {
                    type: `Int`,
                },
                width: {
                    type: `Int`,
                },
                height: {
                    type: `Int`,
                },
            },
        });
    }
    async build({ modeler, typePrefix, cache, configurationOptions, state, shouldAutoRenameFieldsAndModels, platform, }) {
        this.reset();
        this.typePrefix = typePrefix;
        this.shouldAutoRenameFieldsAndModels =
            typeof shouldAutoRenameFieldsAndModels === `undefined`
                ? true
                : shouldAutoRenameFieldsAndModels;
        this.defineInternalCreateModels();
        try {
            const { define, extend } = this.pluginAPI;
            await modeler({
                define,
                extend,
                cache,
                state,
                platform,
            }, configurationOptions);
        }
        catch (e) {
            console.warn(`Encountered errors while running the connector.model() API:`);
            console.error(e);
            process.exit(1);
        }
        this.validateModelHarmony();
        this.complete = true;
        this.finalizeModels();
        return {
            sdl: this.sdl,
        };
    }
    toCreateModels() {
        const createModels = [];
        if (!this.complete) {
            throw new Error(`Cannot generate Create models before ModelBuilder has built its internal models via ModelBuilder.build()`);
        }
        this.models.forEach((model) => {
            const createModel = model.toCreateModel();
            if (createModel)
                createModels.push(createModel);
        });
        if (process.env.NODE_ENV === `development`) {
            // write out stackbit types to a file for debugging
            writeFileSync(join(process.cwd(), `.ntli/netlify-create-types.json`), JSON.stringify(createModels, null, 2));
        }
        return createModels;
    }
    extendModel(model) {
        const typeName = model.getTypeName();
        this.extendedModels.set(typeName, model);
        return this;
    }
    // called by the ModelDefinition constructor for all new models that are created while modelDefiner is running in this.build()
    addModel(model) {
        const typeName = model.getTypeName();
        const existingDefinition = this.models.get(typeName);
        // inline types are allowed to be redefined any number of times - their type name is a hash of their definition
        // so it's impossible for them to conflict with other types
        if (existingDefinition && existingDefinition?.isInlineType) {
            return this;
        }
        if (existingDefinition &&
            existingDefinition.isInternalType &&
            existingDefinition.getTypeName() === `Asset`) {
            throw new ModelError(`The "Asset" model is a builtin model and cannot be redefined. You can extend it with additional fields using the extend API:
connector.model(({ extend }) => {
  extend.Asset({
    fields: {
      newField: {
        type: "String",
        required: true,
      },
    },
  });
});`);
        }
        else if (existingDefinition && existingDefinition.isInternalType) {
            throw new ModelError(`Model name "${typeName}" is a reserved model name and cannot be redefined. Please choose a different name.`);
        }
        else if (existingDefinition) {
            throw new Error(`Model with name "${typeName}" was defined more than once. Model names must be unique. The first definition was:\n\n${existingDefinition.toSDL()}`);
        }
        this.models.set(typeName, model);
        if (model.isNodeType) {
            this.modelDataAPIs[typeName] = model.dataAPI;
            // add keys with original input name, ie if name was product_categories, the
            // model name is ProductCategories, but the connector will likely need to fetch
            // and insert data with the original product_categories name
            if (model.getOriginalName() !== typeName) {
                this.modelDataAPIs[model.getOriginalName()] = model.dataAPI;
            }
        }
        return this;
    }
    reset() {
        this.locales = [];
        this.pascaledNames = new Map();
        this.models = new Map();
        this.extendedModels = new Map();
        this.seenTypePaths = new Map();
        this.modelDataAPIs = {
            async concurrent(count, modelCallback) {
                if (typeof count !== `number`) {
                    throw new ModelError(`models.concurrent(arg1) must be a number`);
                }
                if (count < 1) {
                    throw new ModelError(`models.concurrent(arg1) must be a positive number`);
                }
                if (Math.round(count) !== count) {
                    throw new ModelError(`models.concurrent(arg1) must be a whole number`);
                }
                const models = Array.from(this);
                const slots = Array(count).fill(null);
                function runNextModelInSlot() {
                    const model = models.pop();
                    if (!model)
                        return;
                    const mbePromise = modelCallback(model);
                    if (mbePromise && `then` in mbePromise) {
                        return mbePromise.then(runNextModelInSlot);
                    }
                    else {
                        return runNextModelInSlot();
                    }
                }
                await Promise.all(slots.map(runNextModelInSlot));
            },
        };
        Object.defineProperty(this.modelDataAPIs, Symbol.iterator, {
            value: function* () {
                for (const [name, model] of Object.entries(this)) {
                    if (typeof model === "function")
                        continue; // skip the iterator
                    if (`concurrent` === name)
                        continue; // skip non-model methods
                    if (name === model?.originalName && model.name !== model.originalName)
                        continue; // skip any original name models, these are duplicates added by original name for convinience
                    yield model;
                }
            },
            enumerable: false,
        });
        this.complete = false;
        this.sdl = ``;
    }
    finalizeModels() {
        this.sdl = ``;
        this.models.forEach((model) => {
            model.buildWalker();
            this.sdl += `${model.toSDL()}\n\n`;
        });
        this.sdl = this.sdl.trim();
    }
    // used to track which types have been referenced by other types so we can throw errors (with helpful paths) for undefined types after building models
    setSeenTypePaths() {
        this.models.forEach((model) => {
            const modelTypeName = model.getTypeName();
            if (!this.seenTypePaths.has(modelTypeName)) {
                this.seenTypePaths.set(modelTypeName, [modelTypeName]);
            }
            for (const compositeType of model?.compositeTypes || []) {
                const compositeTypename = model.getDefinedTypeName(compositeType);
                if (!this.seenTypePaths.has(compositeTypename)) {
                    this.seenTypePaths.set(compositeTypename, []);
                }
                this.seenTypePaths.get(compositeTypename).push(`union ${modelTypeName} = ${compositeTypename} | ...`);
            }
            for (const fieldDefinition of model.getFields()) {
                const fieldName = fieldDefinition.name;
                const typeName = model.getDefinedTypeName(fieldDefinition.type, fieldName);
                if (!this.seenTypePaths.has(typeName)) {
                    this.seenTypePaths.set(typeName, []);
                }
                // store a backreference to this type. IE if the field is One.fieldA and fieldA has type Two, then
                // Two => ['One.fieldA', 'OtherType.fieldSomething'] is stored where we keep a list of every place that references this type
                this.seenTypePaths.get(typeName).push(`${modelTypeName}.${fieldName}`);
            }
        });
    }
    validateModelHarmony() {
        this.renamePascaledFieldTypes();
        this.setSeenTypePaths();
        this.panicOnUndefinedModels();
        this.handleMixedUnionTypes();
        this.throwOnMixedUnionListFields();
        this.throwOnInlineUnionMemberTypes();
    }
    // "inline" types are types where the typename is a hash of the type definition.
    // these types shouldn't be used in unions because the __typename can't be set when inserting documents, and the query isn't predictable when querying (... on InlineObject_432j32kl) as the hash may change - which will then require all client queries to be updated to continue working
    throwOnInlineUnionMemberTypes() {
        for (const model of this.models.values()) {
            if (!model.isUnionType)
                continue;
            for (const type of model?.compositeTypes || []) {
                const typeName = model.getDefinedTypeName(type);
                if (this.models.get(typeName)?.isInlineType) {
                    throw new ModelError(`Inline types cannot be used in unions. The type "${typeName}" is an inline type and is used in a union in "${model.getTypeName()}"`);
                }
            }
        }
    }
    throwOnMixedUnionListFields() {
        // this limitation only applies if the connector supports Netlify Create
        if (!this.supports.create)
            return;
        for (const [, model] of this.models) {
            for (const [, field] of model.fieldsMap) {
                const fieldModel = this.models.get(model.getDefinedTypeName(field.type));
                if (!fieldModel)
                    continue;
                if (fieldModel.isMixedUnion && !field.list) {
                    throw new ModelError(`Mixed unions (documents and objects) are only supported when they're used in list fields. A non-list field with a mixed union type exists as "${model.getTypeName()}.${field.name}"`);
                }
            }
        }
    }
    renamePascaledFieldTypes() {
        if (!this.pascaledNames.size) {
            return;
        }
        for (const model of this.models.values()) {
            // pascal union/interface type references
            if (model.compositeTypes) {
                let index = -1;
                for (const type of model.compositeTypes) {
                    index++;
                    // Definition objects don't need to be renamed here, only rename strings
                    if (typeof type !== `string`)
                        continue;
                    const pascaled = this.pascaledNames.get(type);
                    if (pascaled) {
                        model.compositeTypes[index] = pascaled;
                        model.compositeTypesSet.delete(type);
                        model.compositeTypesSet.add(pascaled);
                    }
                }
            }
            for (const def of Object.values(model.fields)) {
                const pascaled = this.pascaledNames.get(model.getDefinedTypeName(def.type));
                if (pascaled) {
                    def.type = pascaled;
                }
            }
        }
    }
    handleMixedUnionTypes() {
        for (const model of this.models.values()) {
            if (model.isUnionType && model.compositeTypes) {
                const foundTypes = {
                    node: [],
                    object: [],
                    union: [],
                    scalar: [],
                };
                for (const type of model.compositeTypes) {
                    const typename = model.getDefinedTypeName(type);
                    if (builtInTypes.has(typename)) {
                        foundTypes.scalar.push(typename);
                        continue;
                    }
                    const fullType = this.models.get(typename);
                    if (!fullType)
                        continue;
                    if (fullType.isObjectType)
                        foundTypes.object.push(typename);
                    if (fullType.isNodeType)
                        foundTypes.node.push(typename);
                    if (fullType.isUnionType)
                        foundTypes.union.push(typename);
                }
                if (foundTypes.object.length && foundTypes.scalar.length) {
                    throw new ModelError(`Object and scalar types cannot be mixed in a union. Found: ${[
                        ...foundTypes.object,
                        ...foundTypes.scalar,
                    ].join(`, `)} types in ${model.getTypeName()}`);
                }
                if (foundTypes.node.length && foundTypes.scalar.length) {
                    throw new ModelError(`Node and scalar types cannot be mixed in a union. Found: ${[
                        ...foundTypes.node,
                        ...foundTypes.scalar,
                    ].join(`, `)} types in ${model.getTypeName()}`);
                }
                const isMixedUnion = foundTypes.node.length && foundTypes.object.length;
                if (isMixedUnion) {
                    model.setIsMixedUnion();
                }
            }
        }
    }
    panicOnUndefinedModels() {
        const undefinedModelErrors = new Map();
        for (const [seenTypeName, sdlPaths] of this.seenTypePaths.entries()) {
            if (!this.models.has(seenTypeName) &&
                !builtInTypes.has(seenTypeName) &&
                !mappedBuiltinTypes.has(seenTypeName)) {
                if (!undefinedModelErrors.has(seenTypeName)) {
                    undefinedModelErrors.set(seenTypeName, new Set());
                }
                for (const sdlPath of sdlPaths) {
                    undefinedModelErrors.get(seenTypeName).add(sdlPath);
                }
            }
        }
        if (undefinedModelErrors.size > 0) {
            const errorMessages = Array.from(undefinedModelErrors.entries()).map(([typeName, sdlPaths]) => {
                return `Undefined type "${typeName}", referenced on type fields:\n\n${Array.from(sdlPaths.keys())
                    .map((sdlPath) => {
                    return ` - ${sdlPath}`;
                })
                    .join(`\n`)}\n`;
            });
            errorMessages.forEach((message) => {
                console.error(message);
            });
            if (undefinedModelErrors.size > 1) {
                console.error(`There were ${undefinedModelErrors.size} referenced type names which haven't been defined. Either your plugin has a typo or there are types which haven't been defined yet using the connector.model(({ define }) => {}) API.\n`);
            }
            else {
                console.error(`There was 1 referenced type name which hasn't been defined. Either your plugin has a typo or there is a type which hasn't been defined yet using the connector.model(({ define }) => {}) API.\n`);
            }
            setTimeout(() => {
                // leave a little time for large errors to print
                process.exit(1);
            }, 100);
        }
    }
}
