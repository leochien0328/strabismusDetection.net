import { builtInScalars, } from "./definition.js";
import { ModelError } from "./error.js";
export class ModelWalker {
    model;
    getModelByName;
    coersionFields = [];
    mappedCoersionFields = new Map();
    allowedFieldNames = new Set();
    constructor({ model, getModelByName, }) {
        this.model = model;
        this.getModelByName = getModelByName;
    }
    build() {
        if (this.model.isNodeType) {
            this.allowedFieldNames.add(`id`);
            const idField = {
                fieldName: `id`,
                fieldTypeName: `ID`,
                required: true,
                list: false,
            };
            this.mappedCoersionFields.set(`id`, idField);
            this.coersionFields.push(idField);
        }
        if (this.model.isUnionType && this.model.compositeTypes) {
            this.allowedFieldNames.add(`__typename`);
            for (const type of this.model.compositeTypes) {
                const typeName = this.model.getDefinedTypeName(type, this.model.getTypeName());
                const typeModel = this.getModelByName(typeName);
                if (!typeModel && !builtInScalars.has(typeName)) {
                    throw new ModelError(`Could not find model for union type "${typeName}" in model "${this.model.getTypeName()}"`);
                }
                if (typeModel?.isNodeType) {
                    this.allowedFieldNames.add(`id`);
                }
                if (typeModel) {
                    for (const { name } of typeModel.getFields()) {
                        this.allowedFieldNames.add(name);
                    }
                }
            }
        }
        for (const fieldDefinition of this.model.getFields()) {
            const fieldName = fieldDefinition.name;
            const fieldTypeName = this.model.getDefinedTypeName(fieldDefinition.type, fieldName);
            const isBuiltInType = builtInScalars.has(fieldTypeName);
            const fieldModel = this.getModelByName(fieldTypeName);
            if (!fieldModel && !isBuiltInType) {
                throw new ModelError(`Could not find model for field type "${fieldTypeName}" in model "${this.model.getTypeName()}"`);
            }
            const unCameled = this.model.camelToOriginalNames.get(fieldName);
            if (unCameled) {
                this.allowedFieldNames.add(unCameled);
            }
            this.allowedFieldNames.add(fieldName);
            const coersionField = {
                fieldName,
                fieldTypeName,
                model: fieldModel,
                required: !!fieldDefinition.required,
                list: fieldDefinition.list || false,
                visitor: fieldDefinition.visitor,
            };
            this.coersionFields.push(coersionField);
            this.mappedCoersionFields.set(fieldName, coersionField);
        }
    }
    fieldByName(name, visitorState) {
        const field = this.mappedCoersionFields.get(name);
        if (!field) {
            throw new Error(`No coersion field found for ${name}`);
        }
        const model = this.model;
        return {
            name: field.fieldName,
            get originalName() {
                return (model.camelToOriginalNames.get(field.fieldName) || field.fieldName);
            },
            typeName: field.fieldTypeName,
            list: field.list,
            required: field.required,
            is: {
                scalar: builtInScalars.has(field.fieldTypeName) || false,
                node: field?.model?.isNodeType || false,
                union: field?.model?.isUnionType || false,
                object: field?.model?.isObjectType || false,
            },
            get fields() {
                return field.model?.ModelWalker?.fields;
            },
            get visitorContext() {
                return visitorState.context;
            },
            setVisitorContext(newValue) {
                visitorState.context = newValue;
            },
        };
    }
    get fields() {
        const fields = {};
        for (const field of this.coersionFields) {
            fields[field.fieldName] = this.fieldByName(field.fieldName, {
                context: null,
            });
        }
        return fields;
    }
    visitInputValue(
    // input value can be "any" because the connector author can input any data they want and use the visitor to structure it in the shape defined by their models
    inputValue, visitorState) {
        if (typeof this.model.visitor !== `function`) {
            return inputValue;
        }
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const walker = this;
        const visitorInfo = {
            setVisitorContext(newContext) {
                visitorState.context = newContext;
            },
            get fields() {
                return walker.fields;
            },
            get visitorContext() {
                return visitorState?.context;
            },
        };
        return this.model.visitor(inputValue, visitorInfo);
    }
    coerceModelValue(modelValue, path = [], combinedType, visitorState = { context: null }, forPackage = `content-engine`) {
        const isRootNode = !path.length;
        const valueIsArray = process.env.NODE_ENV !== `production` && Array.isArray(modelValue);
        if (valueIsArray) {
            throw new Error(`this should never happen. Received an array when only non-list values should exist.`);
        }
        const valueIsScalar = typeof modelValue !== `object`;
        let coercedValue = valueIsScalar ? modelValue : { ...modelValue };
        if (this.model.isEnumType) {
            this.throwOnInvalidEnumValues(coercedValue, path);
            return modelValue;
        }
        // if the value is a scalar, we don't need to do anything else
        if (valueIsScalar) {
            return coercedValue;
        }
        if (typeof this.model.visitor === `function`) {
            coercedValue = this.visitInputValue(coercedValue, visitorState);
        }
        this.setNodeId(coercedValue, path);
        this.throwOnUndefinedModelFields(coercedValue, combinedType);
        this.throwOnMissingTypename(coercedValue, path);
        this.throwOnIncorrectUnionTypename(coercedValue, path, combinedType);
        const handledUnionValue = this.handleUnionValue(coercedValue, path, visitorState, forPackage);
        if (handledUnionValue)
            return handledUnionValue;
        const handledCrossReferenceValue = this.handleCrossReferenceValue(coercedValue, path, forPackage);
        if (handledCrossReferenceValue)
            return handledCrossReferenceValue;
        if (
        // coercing fields on a null model value will throw errors if one of the fields is required,
        // even if the parent model is not a required field - only check for fields if the modelValue is not null
        modelValue !== null &&
            this.coersionFields.length) {
            this.coerceFields(coercedValue, path, visitorState, forPackage);
        }
        this.setInternalProperty(coercedValue, isRootNode, forPackage);
        return coercedValue;
    }
    setNodeId(coercedValue, path) {
        if (this.model.isNodeType) {
            const rawId = coercedValue.id;
            // If the node is a root node (ie no path yet), we need to add the type name to the path for error messages. ex: "MyModel.foo.bar.id"
            if (!path.length) {
                path.push(this.model.getTypeName());
                path.push(`(rawId='${rawId}')`);
            }
            if (!rawId) {
                throw new ModelError(`The value at input path "${path.join(`.`)}" is missing an "id".\nAll nodes must have an "id" field which identifies the node.`);
            }
            coercedValue._objectId = rawId;
            coercedValue._originalType = this.model.getOriginalName();
            if (!coercedValue._updatedAt && coercedValue._createdAt) {
                coercedValue._updatedAt = coercedValue._createdAt;
            }
            coercedValue.id = coercedValue._connectId =
                this.model.createNodeId(rawId);
        }
    }
    handleCrossReferenceValue(coercedValue, path, forPackage = `content-engine`) {
        if (!this.model.isCrossReferenceType) {
            return;
        }
        const isSingleRefType = this.model.crossReferenceTo.length === 1;
        if (isSingleRefType) {
            coercedValue.instanceID ||= this.model.crossReferenceTo[0].instanceID;
            coercedValue.connectorName ||=
                this.model.crossReferenceTo[0].connectorName;
            coercedValue.modelName ||= this.model.crossReferenceTo[0].modelName;
        }
        else {
            const missingFields = [`instanceID`, `connectorName`, `modelName`].filter((name) => !coercedValue[name]);
            // for cross references to multiple types, these fields are required as we don't know which type of the possible types the input value is
            if (missingFields.length) {
                throw new ModelError(`\nCross reference value at path "${path.join(`.`)}" is missing the following fields: \n\t${missingFields.join(`,\n\t`)}\n\nAll multi-type cross reference values must have these fields so that the cross reference can be resolved.`);
            }
        }
        const { createReferenceId, referenceTypePrefix } = this.model.getGlobalCrossReference(coercedValue.connectorName, coercedValue.instanceID);
        const sharedFields = {
            reference: createReferenceId(coercedValue.reference, coercedValue.modelName),
            modelName: `${referenceTypePrefix}${coercedValue.modelName}`,
        };
        if (forPackage === `stackbit`) {
            return {
                value: sharedFields,
                type: `cross-reference`,
                refType: coercedValue.type === `Asset` ? `asset` : `document`,
                refId: coercedValue.reference,
                refSrcType: coercedValue.connectorName,
                refProjectId: coercedValue.instanceID,
            };
        }
        else if (forPackage === `content-engine`) {
            return {
                ...coercedValue,
                ...sharedFields,
                refId: coercedValue.reference,
            };
        }
    }
    handleUnionValue(coercedValue, path, visitorState, forPackage = `content-engine`) {
        if (this.model.isUnionType) {
            const asType = this.model.ModelBuilder.pascaledNames.get(coercedValue.__typename) ||
                coercedValue.__typename;
            const asModel = this.getModelByName(asType);
            if (!asModel) {
                throw new ModelError(`Could not find model for union type "${asType}" in model "${this.model.getTypeName()}" at node path "${path.join(`.`)}".\n\nAll union model values must have a "__typename" which identifies the correct type of the provided value. You may have a typo in your "__typename" value or you may need to define the ${asType} model.\n\nUnion input: ${JSON.stringify(coercedValue, null, 2)}`);
            }
            if (asModel.isNodeType) {
                const rawId = coercedValue?.id;
                if (!rawId) {
                    throw new ModelError(`The value at input path "${path.join(`.`)}" is missing an "id".\nAll node type union model values must have an "id" which identifies the node connection field. The type of the model in this union is "${asModel.getTypeName()}"`);
                }
                const globalId = asModel.createNodeId(rawId);
                if (forPackage === `content-engine`) {
                    coercedValue.id = globalId;
                    delete coercedValue.__typename;
                    coercedValue.internal ||= {};
                    coercedValue.internal.type = asModel.prefixedTypeName();
                }
                else if (forPackage === `stackbit`) {
                    coercedValue.refId = rawId;
                    coercedValue._connectId = globalId;
                    if (this.model.isMixedUnion) {
                        // we store the global id on "fields" to support mixed unions. This is not a standard Netlify Create (Stackbit) field
                        // graphql proxy directives can only proxy a single field name - so we proxy "fields" and that allows Stackbit objects and references to both proxy correctly in GraphQL
                        // if we were to do it the opposite way (store object fields on _connectId, we would be double storing a lot more data - object fields on fields and on _connectId)
                        coercedValue.fields = globalId;
                    }
                    coercedValue.refType = "document";
                    coercedValue.type = "reference";
                    coercedValue.modelName = asModel.getOriginalName();
                }
                return coercedValue;
            }
            const val = asModel.ModelWalker.coerceModelValue(coercedValue, path, this.model, visitorState, forPackage);
            if (forPackage === `stackbit`) {
                return {
                    type: `model`,
                    modelName: asModel.getOriginalName(),
                    fields: val,
                };
            }
            else if (forPackage === `content-engine`) {
                return val;
            }
        }
    }
    coerceFields(coercedValue, path, visitorState, forPackage = `content-engine`) {
        for (const field of this.coersionFields) {
            const uncameled = this.model.camelToOriginalNames.get(field.fieldName);
            if (uncameled && typeof coercedValue[uncameled] !== `undefined`) {
                coercedValue[field.fieldName] = coercedValue[uncameled];
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete coercedValue[uncameled];
            }
            let modelFieldValue = coercedValue[field.fieldName];
            if (field.visitor) {
                modelFieldValue = coercedValue[field.fieldName] = field.visitor(modelFieldValue, this.fieldByName(field.fieldName, visitorState));
            }
            // since enums are scalars, we need to coerce them here on the field value, instead of above in `coerceModelValue` where object-ish types have their type visitors called
            if (field?.model?.isEnumType &&
                typeof field?.model?.visitor === `function`) {
                modelFieldValue = coercedValue[field.fieldName] =
                    field.model.ModelWalker.visitInputValue(modelFieldValue, visitorState);
            }
            const isList = field.list === true || field.list === `required`;
            const isRequiredList = field.list === `required`;
            const isRelationship = field.model?.isNodeType;
            const fieldMustBeNonNull = field.required || isRequiredList;
            const fieldIsNullOrUndefined = typeof modelFieldValue === `undefined` && modelFieldValue !== null;
            const valueIsArray = Array.isArray(modelFieldValue);
            const shouldThrow = (fieldMustBeNonNull && fieldIsNullOrUndefined) ||
                (isList && !!modelFieldValue && !valueIsArray);
            if (!isList && modelFieldValue && valueIsArray) {
                throw new ModelError(`At input path ${path.join(`.`)} found Array value ${modelFieldValue}, but field definition for ${field.fieldName} is not a list type.`);
            }
            const modelString = `Insertion failed validation\n  -> for model "${this.model.getTypeName()}"\n  -> on`;
            const pathString = shouldThrow
                ? `  -> at input path ${path.join(`.`)}.${field.fieldName} <- this field\n  -> required field type "${field.fieldTypeName}${field.list ? `[]` : ``}"\n  -> provided field value:\n    -> ${field.fieldName} is "${JSON.stringify(modelFieldValue, null, 2)}"`.substring(0, 250) + `\n...`
                : undefined;
            if (shouldThrow && isList && isRelationship) {
                throw new ModelError(`${modelString} required list field "${field.fieldName}".\n    -> This field must be an array of strings that are node IDs ${pathString}`);
            }
            else if (shouldThrow && isList) {
                throw new ModelError(`${modelString} required list field "${field.fieldName}" ${pathString}`);
            }
            else if (shouldThrow && isRelationship) {
                throw new ModelError(`${modelString} required field "${field.fieldName}". This field value must be a node id string ${pathString}`);
            }
            else if (shouldThrow) {
                throw new ModelError(`${modelString} required field "${field.fieldName}" ${pathString}`);
            }
            else if (fieldIsNullOrUndefined) {
                continue;
            }
            if (!field.list && field.model?.isNodeType) {
                const rawId = modelFieldValue?.id || modelFieldValue;
                const id = field.model.createNodeId(rawId);
                if (forPackage === `content-engine`) {
                    coercedValue[field.fieldName] = {
                        id,
                        internal: {
                            type: field.model.prefixedTypeName(),
                        },
                    };
                }
                else if (forPackage === `stackbit`) {
                    coercedValue[field.fieldName] = {
                        type: `reference`,
                        refType: field.model.getTypeName() === `Asset` ? `asset` : `document`,
                        refId: rawId,
                        _connectId: id,
                    };
                }
                continue;
            }
            else if (field.list && field.model?.isNodeType) {
                const fieldModel = field.model;
                if (!fieldModel) {
                    throw new ModelError(`Could not find model for field type: ${JSON.stringify(field, null, 2)})}`);
                }
                const listItemReferences = modelFieldValue?.map?.((modelFieldValueListItem) => {
                    const rawId = modelFieldValueListItem?.id || modelFieldValueListItem;
                    if (typeof rawId !== `string` &&
                        typeof rawId !== `number` &&
                        typeof modelFieldValueListItem !== `undefined`) {
                        throw new ModelError(`Invalid "${this.model.getTypeName()}" input object: ${JSON.stringify(coercedValue, null, 4).replace(`    "${field.fieldName}": `, `--> "${field.fieldName}": `)}\n\nThe value at input path "${path.join(`.`)}.${field.fieldName}${field.list ? `[]` : ``}.id" is not a valid node id string.\nReceived: ${JSON.stringify(rawId, null, 4)}`);
                    }
                    else if (typeof rawId !== `string` && typeof rawId !== `number`) {
                        throw new ModelError(`Invalid "${this.model.getTypeName()}" input object: ${JSON.stringify(coercedValue, null, 4).replace(`    "${field.fieldName}": `, `-->"${field.fieldName}": `)}\n\nThe value at input path "${path.join(`.`)}.${field.fieldName}" is not a valid node id string.\nReceived: ${JSON.stringify(rawId, null, 4)}`);
                    }
                    const id = fieldModel.createNodeId(rawId);
                    if (forPackage === `content-engine`) {
                        return {
                            id,
                            internal: {
                                type: fieldModel.prefixedTypeName(),
                            },
                        };
                    }
                    else if (forPackage === `stackbit`) {
                        return {
                            type: `reference`,
                            refType: fieldModel.getTypeName() === `Asset` ? `asset` : `document`,
                            refId: rawId,
                            _connectId: id,
                        };
                    }
                });
                if (forPackage === `content-engine`) {
                    coercedValue[field.fieldName] = listItemReferences;
                }
                else if (forPackage === `stackbit`) {
                    coercedValue[field.fieldName] = {
                        type: `list`,
                        items: listItemReferences,
                    };
                }
                continue;
            }
            if (field.model && !field.list) {
                if (forPackage === `content-engine`) {
                    coercedValue[field.fieldName] =
                        field.model.ModelWalker.coerceModelValue(modelFieldValue, [...path, field.fieldName], undefined, visitorState, `content-engine`);
                }
                else if (forPackage === `stackbit`) {
                    const modelValue = field.model.ModelWalker.coerceModelValue(modelFieldValue, [...path, field.fieldName], undefined, visitorState, `stackbit`);
                    if (field.model.isUnionType) {
                        coercedValue[field.fieldName] = modelValue;
                    }
                    else if (field.model.isEnumType) {
                        coercedValue[field.fieldName] = {
                            type: `enum`,
                            value: modelValue,
                        };
                    }
                    else if (field.model.isCrossReferenceType) {
                        coercedValue[field.fieldName] = modelValue;
                    }
                    else {
                        coercedValue[field.fieldName] = {
                            type: `model`,
                            modelName: field.model.getOriginalName(),
                            fields: modelValue,
                        };
                    }
                }
                continue;
            }
            else if (field.model && field.list) {
                if (forPackage === `content-engine`) {
                    coercedValue[field.fieldName] = modelFieldValue?.map?.((node, index) => {
                        return field.model.ModelWalker.coerceModelValue(node, [...path, field.fieldName, `[${index}]`], undefined, visitorState, "content-engine");
                    });
                    continue;
                }
                else if (forPackage === `stackbit`) {
                    const listItems = modelFieldValue?.map?.((node, index) => {
                        const fields = field.model.ModelWalker.coerceModelValue(node, [...path, field.fieldName, `[${index}]`], undefined, visitorState, `stackbit`);
                        if (field.model?.isUnionType) {
                            return fields;
                        }
                        if (field.model?.isEnumType) {
                            return {
                                type: `enum`,
                                value: fields,
                            };
                        }
                        if (field.model?.isCrossReferenceType) {
                            return fields;
                        }
                        return {
                            type: `model`,
                            modelName: field.model.getOriginalName(),
                            fields,
                        };
                    });
                    // @todo: once stackbit fully supports mixed unions, we'll probably need something similar to this
                    // if (field.model?.isMixedUnion) {
                    //   coercedValue[field.fieldName] = {
                    //     type: `list`,
                    //     items: listItems.map((li) => {
                    //       const liModel = this.getModelByName(li.__typename);
                    //       if (liModel?.isNodeType) {
                    //         return li;
                    //       } else {
                    //         return {
                    //           type: `model`,
                    //           modelName: li.modelName,
                    //           fields: li.fields,
                    //         };
                    //       }
                    //     }),
                    //   };
                    //
                    //   console.log(JSON.stringify(coercedValue[field.fieldName], null, 2));
                    //   continue;
                    // }
                    if (field.model && field.model.isCrossReferenceType) {
                        coercedValue[field.fieldName] = {
                            type: `list`,
                            items: listItems,
                        };
                    }
                    else {
                        coercedValue[field.fieldName] = {
                            type: `list`,
                            items: listItems,
                        };
                    }
                }
                continue;
            }
            else if (!field.model && field.list && forPackage === `stackbit`) {
                coercedValue[field.fieldName] = {
                    type: `list`,
                    items: modelFieldValue?.map?.((listFieldValue) => {
                        return {
                            type: this.model.getFormattedTypename(field.fieldTypeName),
                            value: listFieldValue,
                        };
                    }),
                };
                continue;
            }
            if (forPackage === `stackbit` && field.fieldTypeName !== `ID`) {
                const stackbitType = field.model?.dataAPI?.originalName ||
                    {
                        String: `string`,
                        Int: `number`,
                    }[field.fieldTypeName] ||
                    this.model.getFormattedTypename(field.fieldTypeName);
                if (stackbitType === `date` &&
                    coercedValue[field.fieldName] instanceof Date) {
                    coercedValue[field.fieldName] =
                        coercedValue[field.fieldName].toISOString();
                }
                coercedValue[field.fieldName] = {
                    type: stackbitType,
                    value: coercedValue[field.fieldName],
                };
                continue;
            }
        }
    }
    setInternalProperty(coercedValue, isRootNode = false, forPackage = `content-engine`) {
        if (isRootNode) {
            const { cacheFieldName } = this.model;
            let cacheFieldValue = ``;
            if (cacheFieldName) {
                cacheFieldValue = coercedValue[cacheFieldName].value
                    ? coercedValue[cacheFieldName].value
                    : coercedValue[cacheFieldName];
            }
            else {
                let fallbackCacheValue = ``;
                if (coercedValue._updatedAt) {
                    if (forPackage === `stackbit`) {
                        // Netlify Create
                        fallbackCacheValue = coercedValue._updatedAt.value;
                    }
                    else if (forPackage === `content-engine`) {
                        // Netlify Connect
                        fallbackCacheValue = coercedValue._updatedAt;
                    }
                }
                else {
                    fallbackCacheValue = Math.random().toString();
                }
                cacheFieldValue = fallbackCacheValue;
            }
            coercedValue.internal ||= {};
            coercedValue.internal.contentDigest = String(cacheFieldValue);
            coercedValue.internal.type = this.model.prefixedTypeName();
        }
        else if (coercedValue.__typename) {
            // connection union fields will have a __typename but no cacheFieldName. internal.type needs to be set for content engine resolvers to work
            coercedValue.__typename = this.model.prefixedTypeName();
            coercedValue.internal ||= {};
            coercedValue.internal.type = this.model.prefixedTypeName();
        }
    }
    throwOnMissingTypename(coercedValue, path) {
        if (this.model.isUnionType && !coercedValue.__typename) {
            throw new ModelError(`Union model "${this.model.getTypeName()}" insertion failed validation for required field "__typename".\nAll union model values must have a "__typename" which identifies the type of the provided value.\nThe value at input path "${path.join(`.`)}" is missing a "__typename".`);
        }
    }
    throwOnIncorrectUnionTypename(coercedValue, path, combinedType) {
        if (process.env.NODE_ENV === `production`)
            return;
        if (this.model.isUnionType || combinedType?.isUnionType) {
            const typeIsInUnion = (combinedType || this.model).compositeTypes?.some((type) => {
                const typeName = this.model.getDefinedTypeName(type, this.model.getTypeName());
                const finalTypeName = this.model.ModelBuilder.pascaledNames.get(typeName) || typeName;
                return (finalTypeName === coercedValue.__typename ||
                    this.model.ModelBuilder.pascaledNames.get(coercedValue.__typename) === finalTypeName);
            });
            if (!typeIsInUnion) {
                throw new ModelError(`Union model "${this.model.getTypeName()}" insertion failed validation for required field "__typename".\nThe value at input path "${path.join(`.`)}" has a "__typename" of "${coercedValue.__typename}" but that type is not in the "${(combinedType || this.model).getTypeName()}" union.\n\nInput value: ${JSON.stringify(coercedValue, null, 2)}\n\nAvailable types: ${(combinedType || this.model).compositeTypes
                    ?.map((type) => {
                    const typeName = this.model.getDefinedTypeName(type, this.model.getTypeName());
                    const finalTypeName = this.model.ModelBuilder.pascaledNames.get(typeName) || typeName;
                    return finalTypeName;
                })
                    .join(`, `)}`);
            }
        }
    }
    throwOnUndefinedModelFields(modelValue, combinedType) {
        if (this.model.isCrossReferenceType)
            return;
        if (process.env.NODE_ENV === `production`)
            return;
        // throw for any properties that are not defined as fields on the model
        Object.keys(modelValue || {}).forEach((key) => {
            if (key === `__typename` && combinedType?.isUnionType) {
                return;
            }
            const fieldName = this.model.getFinalFieldName(key, modelValue?.__typename);
            if (!this.allowedFieldNames.has(fieldName)) {
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete modelValue[key];
            }
        });
    }
    throwOnInvalidEnumValues(modelValue, path) {
        if (process.env.NODE_ENV === `production`)
            return;
        if (!this.model.isEnumType) {
            return;
        }
        if (typeof modelValue !== `string`) {
            throw new ModelError(`Enum value at ${path.join(`.`)} is not a string but is required to be a string value. Found ${JSON.stringify(modelValue)}`);
        }
        if (!this.model.values?.find((storedValue) => storedValue.value === modelValue)) {
            const validValues = this.model.values?.map((v) => v.value).join(`, `);
            throw new ModelError(`Enum value at ${path.join(".")} is "${modelValue}" but must be one of: ${validValues}`);
        }
    }
}
