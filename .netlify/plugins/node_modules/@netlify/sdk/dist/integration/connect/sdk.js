import zodLib from "zod";
import { register } from "zod-metadata";
register(zodLib);
import { ConnectorOptionsSchema, } from "./utils/options.js";
import { ModelError } from "./model/error.js";
import { makeInstanceID } from "./utils/instance-id.js";
import { ConfiguredNetlifyConnector, getGlobalConnectorInstance, setGlobalConnectorInstance, } from "./connector-instance.js";
export class NetlifyConnector {
    config;
    started = false; // true if the first event loop tick has occurred. Plugin APIs cannot be dynamically assigned after this as the "exports" should be static. so this value is checked before assigning plugin APIs. It must be false to assign plugin APIs.
    definedImplementations = new Map();
    isUsingUnifiedAPI = false;
    optionsSchema;
    proxiedSchemas = [];
    supports = {
        create: false,
        deltaSync: true,
    };
    integration;
    constructor(config, integration) {
        this.config = {
            ...config,
            localDevOptions: config.localDevOptions ?? {},
            supports: config.supports ?? {},
        };
        this.supports = {
            ...this.supports,
            ...config.supports,
        };
        this.optionsSchema = new ConnectorOptionsSchema(({ zod }) => zod.object({}));
        this.integration = integration;
        setImmediate(() => {
            // plugins may only add APIs on the first event loop tick.
            // exported APIs are static and cannot be dynamically assigned.
            this.started = true;
            if (!this.definedImplementations.has(`model`)) {
                if (this.proxiedSchemas.length) {
                    return;
                }
                throw new Error(`No connector.model(implementation) was defined. This API is required for all connectors.`);
            }
            if ((this.definedImplementations.has(`event.updateNodes`) ||
                this.definedImplementations.has(`event.createAllNodes`)) &&
                this.definedImplementations.has(`sync`)) {
                if (this.proxiedSchemas.length) {
                    return;
                }
                throw new Error(`connector.event() and connector.documents() cannot both be used. If you're trying the new connector.documents() API, you must remove all calls to connector.event(). connector.sync(implementation) has replaced all connector.event() calls.`);
            }
            if (!this.definedImplementations.has(`sync`) &&
                !this.definedImplementations.has(`event.createAllNodes`)) {
                if (this.proxiedSchemas.length) {
                    return;
                }
                if (this.supports.create) {
                    throw new Error(`No connector.documents({ sync: implementation }) was defined. This API is required for all connectors.`);
                }
                else {
                    throw new Error(`No connector.event('createAllNodes', fn) implementation was defined. This API is required for all connectors.`);
                }
            }
        });
    }
    /**
     * @warning - don't use this unless you know what you're doing :) this is an experimental API
     * @deprecated Prefer specifying this via `NetlifyIntegration#addConnector({ initState, <...> })`
     */
    init = (init) => {
        this.checkCanDefine(`init`);
        this.definedImplementations.set(`init`, init);
    };
    /**
     * `defineOptions` accepts a function that Defines the user configuration options for your `NetlifyConnector`.
     * @deprecated Prefer specifying this via `NetlifyIntegration#addConnector({ defineOptions, <...> })`
     */
    defineOptions = (definer) => {
        this.checkCanDefine(`defineOptions`);
        this.optionsSchema = new ConnectorOptionsSchema(definer);
    };
    getOptionsSchema() {
        return this.optionsSchema.buildSchema();
    }
    /**
     * Defines the content model for your Connector.
     * @link https://sdk.netlify.com/connectors/connector-apis/#model
     */
    model(modeler) {
        this.checkCanDefine(`model`);
        if (this.definedImplementations.has(`model`)) {
            throw new ModelError(`connector.model() may only be called one time, but has been called more than once.`);
        }
        this.definedImplementations.set(`model`, modeler);
    }
    sync(sync) {
        this.checkCanDefine(`sync`);
        if (this.definedImplementations.has(`sync`)) {
            throw new ModelError(`connector.sync() may only be called one time, but has been called more than once.`);
        }
        this.isUsingUnifiedAPI = true;
        this.definedImplementations.set(`sync`, sync);
    }
    hasAccess(userFn) {
        this.checkCanDefine(`hasAccess`);
        this.definedImplementations.set(`hasAccess`, userFn);
    }
    /**
     * @warning - don't use this unless you know what you're doing :) this is an experimental API
     */
    assets(args) {
        this.checkCanDefine(`assets`);
        if (this.definedImplementations.has(`assets.upload`)) {
            throw new ModelError(`connector.assets() may only be called one time, but has been called more than once.`);
        }
        this.isUsingUnifiedAPI = true;
        const { create } = args;
        if (!create) {
            throw new ModelError(`connector.assets({ create }) must be called with a 'create' implementation.`);
        }
        this.definedImplementations.set(`assets.upload`, create);
    }
    /**
     * @warning - don't use this unless you know what you're doing :) this is an experimental API
     */
    documents(args) {
        this.checkCanDefine(`documents`);
        for (const apiName of [
            `documents.update`,
            `documents.create`,
            `documents.delete`,
            `documents.publish`,
        ]) {
            if (this.definedImplementations.has(apiName)) {
                throw new ModelError(`connector.documents() may only be called one time, but it's been called more than once.`);
            }
        }
        this.isUsingUnifiedAPI = true;
        this.definedImplementations.set(`documents.update`, args.update);
        this.definedImplementations.set(`documents.create`, args.create);
        this.definedImplementations.set(`documents.delete`, args.delete);
        this.definedImplementations.set(`documents.publish`, args.publish);
    }
    /**
     * Defines a data event. Supported events are `createAllNodes` and `updateNodes`.
     * @link https://sdk.netlify.com/connectors/connector-apis/#createallnodes
     */
    event(name, implementation) {
        if (this.definedImplementations.has(`event.${name}`)) {
            throw new ModelError(`connector.event('${name}', implementation) was already defined. You may only define each event once.`);
        }
        this.definedImplementations.set(`event.${name}`, implementation);
    }
    checkCanDefine(apiName) {
        if (this.started) {
            throw new Error(`Cannot call ${apiName} after the first event loop tick.\n\nPlease call connector().${apiName}() synchronously in your plugin's main module. Plugin implementations cannot be dynamically assigned.`);
        }
    }
    proxySchema(fn) {
        this.proxiedSchemas.push(fn);
    }
    // Multiple instances of the same connector may need to exist within the same process, so create and store instances by a unique hashed ID
    getConnectorInstance(options, connectorName) {
        const instanceID = options.instanceID ?? makeInstanceID(options);
        const existingConnector = getGlobalConnectorInstance(connectorName, instanceID);
        if (existingConnector) {
            return existingConnector;
        }
        const connectorInstance = new ConfiguredNetlifyConnector({
            slug: connectorName,
            options,
            instanceID,
            NetlifyConnector: this,
            config: this.config,
        });
        setGlobalConnectorInstance(connectorName, instanceID, connectorInstance);
        return connectorInstance;
    }
}
