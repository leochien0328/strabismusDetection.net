import camelcase from "camelcase";
// We need this one as it's the one that is used in the @netlify/content-engine
import _ from "lodash";
import { lmdbStoredAssetToStackbit, lmdbStoredDocumentToStackbit, } from "../utils/data.js";
import { getGlobalConnectorInstance, } from "../connector-instance.js";
import { fastHash } from "../utils/fast-hash.js";
import { omitByUndefined } from "../utils/omit-by-undefined.js";
import { ModelWalker } from "./walker.js";
import { ModelError } from "./error.js";
export const builtInStackbitStringTypes = new Set([
    // todo: make sure the SDK checks that these are strings when validating input data
    "Slug",
    "Url",
    "Text",
    "Markdown",
    "Color",
    "Html",
]);
export const builtInStackbitTypes = new Set([
    ...builtInStackbitStringTypes.keys(),
    // todo: how should cross-reference be handled? we need a custom resolver most likely
    // "cross-reference",
    "richText",
    // these are already handled by @netlify/content-engine types
    // "boolean",
    // "date",
    // "number",
    // "reference",
]);
// todo - this should be imported from @netlify/content-engine
export const builtInTypes = new Set([
    ...builtInStackbitTypes.keys(),
    `ID`,
    `String`,
    `Int`,
    `Float`,
    `Boolean`,
    `JSON`,
    `Date`,
    "DateTime", // Added via graphql-scalars package
]);
export const mappedBuiltinTypes = new Map([
    ...Array.from(builtInTypes).map((type) => {
        return [type.toLowerCase(), type];
    }),
    // additional mappings
    [`integer`, `Int`],
    [`number`, `Float`],
    [`RichText`, `richText`],
]);
export const builtInScalars = new Set([
    ...Array.from(builtInTypes),
    ...mappedBuiltinTypes.keys(),
]);
export class ModelDefinition {
    compositeTypes = [];
    compositeTypesSet = new Set();
    description;
    cacheFieldName;
    ModelWalker;
    ModelBuilder;
    createId;
    visitor;
    camelToOriginalNames = new Map();
    originalToCamelNames = new Map();
    fields = [];
    fieldsMap = new Map();
    fieldGroups;
    // User can pass strings as well as this object type, but we want to store it as an object type
    // to avoid having to check for the type of each value in the rest of the code
    values;
    isMixedUnion = false;
    definedKind;
    typeName;
    originalName;
    nodesApi;
    createApi;
    label;
    shouldAutoRenameFieldsAndModels = true;
    supports;
    isExtendedDefinition;
    _isInternalType;
    isPageType;
    editorDocumentPreview;
    editorObjectPreview;
    crossReferenceTo = [];
    // marks this model as a singleton type in the Netlify Create editor
    isEditorSingleInstance;
    // inlineTypes are types that are defined within another type.
    // They are actually global, but their type name is a hash of the type definition itself.
    // this is for situations where a data source has a non-global type that is used in a field of another type.
    // The connector dev typically wont have a typename available for this type, so we generate one for them.
    _isInlineType;
    constructor(input) {
        this.createId = input.createId;
        this.definedKind = input.kind;
        this.description = input.description;
        this.compositeTypes = input.types;
        this.nodesApi = input.nodesApi;
        this.createApi = input.createApi;
        this.visitor = input.visitor;
        this.supports = input.supports;
        this.shouldAutoRenameFieldsAndModels =
            input.shouldAutoRenameFieldsAndModels;
        this.isExtendedDefinition = !!input.isExtendedDefinition;
        this._isInternalType = !!input.isInternalType;
        this._isInlineType = !!input.isInlineType;
        if (this.isInlineType) {
            const inlinePrefix = camelcase("Inline_" + (input.name || this.definedKind), {
                pascalCase: true,
            });
            // inline type names are a hash of the definition.
            // the type kind or provided name is prefixed for debugging
            this.typeName = inlinePrefix + "_" + fastHash(input);
        }
        else if (!input.name) {
            throw new ModelError(`You must provide a name when defining a type. For example: define.methodName({ name: "MyType", ... }). ${this.isNodeType ? `` : `If you do not have a name for this type, consider using an inline type. Ex: define.inline${this.definedKind}(definition)`}`);
        }
        else {
            this.typeName = input.name;
        }
        const existingDefinition = input.ModelBuilder.models.get(this.typeName);
        if (this._isInlineType && existingDefinition) {
            this.ModelBuilder = existingDefinition.ModelBuilder;
            this.ModelWalker = existingDefinition.ModelWalker;
            // inline types may be redefined as many times as the connector wants, we will only use the first definition
            // this is because the connector doesn't have a name for an inline type, so it doesn't know if it's redefining it
            return existingDefinition;
        }
        this.processInputDefinition(input);
        this.ModelWalker = new ModelWalker({
            model: this,
            getModelByName: this.getModelByName.bind(this),
        });
        if (this.isExtendedDefinition) {
            this.ModelBuilder = input.ModelBuilder.extendModel(this);
        }
        else {
            this.ModelBuilder = input.ModelBuilder.addModel(this);
        }
        return this;
    }
    _mergeExtendedDefinition(extendedDefinition, modelBuilder) {
        if (modelBuilder !== this.ModelBuilder) {
            throw new ModelError(`The extended definition must be created with the same ModelBuilder instance as the original definition. If you're a user of the Netlify SDK, this method is for internal use only.`);
        }
        if (this.definedKind !== extendedDefinition.definedKind) {
            throw new ModelError(`The extended definition for model "${extendedDefinition.typeName}" must be of the same kind as the original definition. The original definition is of kind "${this.definedKind}" and the extended definition is of kind "${extendedDefinition.definedKind}".`);
        }
        for (const extendedField of extendedDefinition.fields) {
            // don't extend builtin fields
            if (extendedField.name.startsWith(`_`)) {
                continue;
            }
            if (this.fieldsMap.has(extendedField.name)) {
                throw new ModelError(`The field "${extendedField.name}" is defined in both the original and extended definitions for model "${extendedDefinition.typeName}". Fields cannot be redefined, only new fields may be added.`);
            }
            this.fields.push(extendedField);
            this.fieldsMap.set(extendedField.name, extendedField);
        }
    }
    getFields() {
        return this.fields;
    }
    getTypeName() {
        return this.typeName;
    }
    getOriginalName() {
        return this.originalName || this.typeName;
    }
    get isInternalType() {
        return this._isInternalType;
    }
    get isInlineType() {
        return this._isInlineType;
    }
    get isNodeType() {
        return this.definedKind === `Node`;
    }
    get isObjectType() {
        return this.definedKind === `Object`;
    }
    get isUnionType() {
        return this.definedKind === `Union`;
    }
    get isEnumType() {
        return this.definedKind === `Enum`;
    }
    get isCrossReferenceType() {
        return this.definedKind === `CrossReference`;
    }
    getDefinedTypeName(type, fieldName) {
        const isDefineInstance = type instanceof ModelDefinition;
        const typeName = isDefineInstance ? type.typeName : type;
        if (typeof typeName === `undefined`) {
            throw new ModelError(`The type of field "${fieldName}" is undefined. Please define the type of this field.`);
        }
        return typeName;
    }
    prefixedTypeName(typeName = this.typeName, field) {
        const builtinExists = mappedBuiltinTypes.has(typeName.toLowerCase());
        const typeDefinition = this.ModelBuilder.models.get(typeName);
        if (builtinExists &&
            // field is optional, so default to builtins if no field is passed
            !field) {
            // return an unprefixed (builtin) typename
            return typeName;
        }
        if (builtinExists &&
            field &&
            // return builtin if it exists and is preferred
            (field.kind === `builtin` ||
                field.kind === `prefer-builtin` ||
                // or if defined types are preferred but one doesn't exist with this name
                (field.kind === `prefer-defined` && !typeDefinition))) {
            // return an unprefixed (builtin) typename
            return typeName;
        }
        if (field &&
            // if the kind doesn't start with prefer-, then we don't fall back. no type of that kind exists, so error
            ((field.kind === `builtin` && !builtinExists) ||
                (field.kind === `defined` && !typeDefinition))) {
            throw new ModelError(`Field "${field.name}" of type "${typeName}" is defined with "kind: '${field.kind}'" but no ${field.kind} type "${typeName}" exists.`);
        }
        // finally return the prefixed typename of the connector-defined type.
        // A field was passed in and either there was no builtin with this typename, or there was but "prefer-defined" was set
        return `${this.ModelBuilder.typePrefix}${typeName}`;
    }
    getFinalFieldName(fieldName, unionModelName) {
        if (!this.shouldAutoRenameFieldsAndModels)
            return fieldName;
        const model = unionModelName ? this.getModelByName(unionModelName) : this;
        if (unionModelName &&
            this.isUnionType &&
            model &&
            !this.compositeTypesSet.has(model.getTypeName())) {
            throw new Error(`${unionModelName} does not exist in union type ${this.getTypeName()}`);
        }
        return model?.originalToCamelNames?.get(fieldName) || fieldName;
    }
    // TODO: sdkFieldToStackbitField should be refactored and combined with this fn
    // this fn creates an inline field definition as if a model/object was created for it - but it does much of the same work that sdkFieldToStackbitField does
    // and this fn may be missing some of the features that sdkFieldToStackbitField has
    toCreateInlineFieldDefinition(sdkField) {
        const fieldDefinition = this.sdkFieldToStackbitField(sdkField, {
            skipInline: true,
        });
        const type = this.isEnumType
            ? `enum`
            : this.isObjectType
                ? `object`
                : `model`;
        const name = sdkField.name || this.typeName;
        const options = this.values?.map((e) => {
            if (e.value === e.label) {
                return e.value;
            }
            return e;
        });
        const fields = this.isEnumType || this.isUnionType
            ? undefined
            : this.sdkFieldsToStackbitFields();
        const controlType = sdkField.editor?.controlType;
        const sharedProps = {
            default: fieldDefinition.default,
            required: fieldDefinition.required,
            preview: fieldDefinition.preview ||
                this.editorObjectPreview ||
                this.editorDocumentPreview,
            controlType,
            label: sdkField.editor?.label,
            group: sdkField.editor?.group,
            name,
        };
        if (sdkField.list) {
            return omitByUndefined({
                ...sharedProps,
                type: `list`,
                items: omitByUndefined({
                    fieldGroups: this.fieldGroups,
                    options,
                    type,
                    fields,
                }),
            });
        }
        else {
            return omitByUndefined({
                ...sharedProps,
                name,
                type,
                fieldGroups: this.fieldGroups,
                options,
                fields,
            });
        }
    }
    toCreateModel() {
        if (
        // asset, thumbnail, and status types are built into Netlify Create already
        this.isInternalType ||
            // don't send inline, union, or enum types to Create - create does not have global type definitions for these
            this.isInlineType ||
            this.isUnionType ||
            this.isEnumType ||
            // cross-reference type already exists in Create
            this.isCrossReferenceType) {
            return false;
        }
        const commonProps = {
            name: this.originalName || this.getTypeName(),
            label: this.label,
            description: this.description,
            fieldGroups: this.fieldGroups,
            singleInstance: this.isEditorSingleInstance,
            fields: this.sdkFieldsToStackbitFields(),
        };
        if (this.isObjectType) {
            return omitByUndefined({
                ...commonProps,
                type: `object`,
                preview: this.editorObjectPreview,
            });
        }
        return omitByUndefined({
            ...commonProps,
            type: this.isPageType ? `page` : `data`,
            preview: this.editorDocumentPreview,
        });
    }
    /**
     *
     * Introduced specifically to keep the casing of the richText simple type.
     * At the time of writing (March 7 2024) this is the only type with any camelcasing, the rest
     * can be safely lowercased.
     */
    getFormattedTypename(typename) {
        if (typename === "richText") {
            return typename;
        }
        return typename.toLowerCase();
    }
    sdkFieldToStackbitField(field, { skipInline } = { skipInline: false }) {
        const definedTypename = this.getDefinedTypeName(field.type);
        let fieldModel = this.ModelBuilder.models.get(definedTypename);
        if (fieldModel?.isInlineType &&
            !fieldModel.isCrossReferenceType &&
            !skipInline) {
            return fieldModel.toCreateInlineFieldDefinition(field);
        }
        // use prefixedTypeName helper to check if we should use the builtin type or not in the case of conflicts
        const useBuiltinType = 
        // ie a connector-defined ModelDefinition exists for this type
        !!fieldModel &&
            // and it's also a builtin type
            mappedBuiltinTypes.has(definedTypename) &&
            // and the prefix helper didn't prefix the type
            mappedBuiltinTypes.has(this.prefixedTypeName(definedTypename, field));
        // ensure we don't use the defined type if the builtin type should be used
        if (useBuiltinType && fieldModel)
            fieldModel = undefined;
        const typename = useBuiltinType
            ? definedTypename
            : fieldModel?.originalName || definedTypename;
        const isObject = fieldModel?.isObjectType;
        const isEnum = fieldModel?.isEnumType;
        const scalarTypename = isObject
            ? `model`
            : {
                // create only has a number field
                float: "number",
                int: "number",
            }[typename.toLowerCase()] ||
                // all other scalar types are supported as lowercase typenames
                this.getFormattedTypename(typename);
        const isAsset = typename === `Asset`;
        const isReference = !isAsset && fieldModel?.isNodeType;
        const isCrossReference = fieldModel?.isCrossReferenceType;
        const isUnion = fieldModel?.isUnionType;
        const isMixedUnion = fieldModel?.isMixedUnion;
        const firstUnionType = isUnion &&
            fieldModel?.compositeTypes &&
            this.ModelBuilder.models.get(this.getDefinedTypeName(fieldModel.compositeTypes[0]));
        const isObjectUnion = firstUnionType && firstUnionType.isObjectType;
        const isReferenceUnion = firstUnionType && firstUnionType.isNodeType;
        const type = (() => {
            if (isMixedUnion)
                return `list`;
            if (isCrossReference)
                return `cross-reference`;
            if (isObjectUnion)
                return `model`;
            if (isReference || isReferenceUnion)
                return `reference`;
            if (isUnion) {
                throw new ModelError(`Unhandled union type for model ${typename}. This is a bug in the Netlify SDK.`);
            }
            const controlType = field.editor?.controlType;
            if (isAsset) {
                return controlType === `image` ? `image` : `file`;
            }
            if (isEnum)
                return `enum`;
            return scalarTypename;
        })();
        const stackbitField = {
            type,
            name: field.name,
        };
        if (typename.toLowerCase() === `int`) {
            stackbitField.subtype = `int`;
        }
        if (typename.toLowerCase() === `float`) {
            stackbitField.subtype = `float`;
        }
        if (fieldModel && isObject) {
            stackbitField.models = [
                fieldModel.getOriginalName(),
            ];
        }
        if (isEnum) {
            if (!fieldModel?.values) {
                throw new ModelError(`Enum type "${typename}" is missing values. This is a bug in the Netlify SDK as at this point in the code, enums should always have values.`);
            }
            const normalizedValues = fieldModel.values.map((e) => {
                if (e.value === e.label) {
                    return e.value;
                }
                return e;
            });
            stackbitField.options =
                normalizedValues;
        }
        if (isCrossReference &&
            fieldModel &&
            fieldModel.crossReferenceTo.length > 0) {
            const crossReferenceField = stackbitField;
            crossReferenceField.models = fieldModel.crossReferenceTo.map((to) => ({
                modelName: to.modelName,
                srcType: to.connectorName,
                srcProjectId: to.instanceID,
            }));
        }
        // any field names starting with _ are internal mandatory fields.
        // they shouldn't be set as required in the Create UI as content admins
        // don't need to set these fields, connector authors do.
        if (!field.name.startsWith(`_`)) {
            stackbitField.required = field.required;
        }
        stackbitField.localized = field.localized;
        stackbitField.label = field.editor?.label;
        stackbitField.hidden = field.editor?.hidden;
        stackbitField.readOnly = field.editor?.readOnly;
        stackbitField.group = field?.editor?.group;
        stackbitField.description = field.description;
        stackbitField.default = field.editor?.initialValue;
        stackbitField.preview =
            field.editor?.preview;
        const controlType = field.editor?.controlType;
        // image and file are not actual Netlify Create control types, but they are used in the SDK to represent kinds of asset fields
        if (controlType && controlType !== `file` && controlType !== `image`) {
            stackbitField.controlType =
                controlType;
        }
        const { editor } = field;
        const numberField = stackbitField;
        if (editor?.numberOptions) {
            const { numberOptions } = editor;
            numberField.min = numberOptions.min;
            numberField.max = numberOptions.max;
            numberField.step = numberOptions.step;
            numberField.unit = numberOptions.unit;
        }
        // Thumbnail is an object type for GraphQL as enums cannot represent additional properties (value, label, thumbnail) like they can in Create. To query a thumbnail you receive an object type ({ label: `Thumbnail title example`, value: "ok.png", thumbnail: `https://example.com/ok.png` }) but in Create you need to be able to select your thumbnail with a Create enum.
        // so Thumbnail is cast as an enum type when sending it to Create - but it's an object type for stored data
        // if the connector specifies "thumbnailOptions" with a label and thumbnail url, the user can select in the UI from those choices, otherwise the user will just see the object type.
        if (typename === `Thumbnail` && editor?.thumbnailOptions) {
            const thumbnailField = stackbitField;
            thumbnailField.type = `enum`;
            thumbnailField.controlType = `thumbnails`;
            thumbnailField.options = editor.thumbnailOptions;
            // models: ["Thumbnail"] isn't allowed in what's now an enum type. If we don't remove this, Stackbit will print warnings and refuse to build the schema
            if (`models` in thumbnailField) {
                delete thumbnailField.models;
            }
        }
        if (isUnion) {
            stackbitField.models = (fieldModel?.compositeTypes || []).map((ct) => {
                const fullType = this.getModelByName(this.getDefinedTypeName(ct));
                return fullType.getOriginalName();
            });
        }
        else if (fieldModel && isReference && !isCrossReference) {
            stackbitField.models = [
                fieldModel.getOriginalName(),
            ];
        }
        if (field.list) {
            const { name, required, hidden, group, default: defaultValue, ...items } = stackbitField;
            const itemsOverride = isMixedUnion
                ? (fieldModel?.compositeTypes || []).map((ct) => {
                    const fullType = this.getModelByName(this.getDefinedTypeName(ct));
                    if (!fullType) {
                        throw new ModelError(
                        // eslint-disable-next-line @typescript-eslint/no-base-to-string -- FIXME
                        `Model ${ct} not found. This is a bug in the Netlify SDK as union types should already be defined at this point in the code.`);
                    }
                    const name = fullType.getOriginalName();
                    return {
                        type: fullType.isNodeType
                            ? // SDK fields that are of a Node (document) type are always reference fields
                                `reference`
                            : // otherwise all Stackbit globally named types are referred to as "models" in Stackbit. In the SDK we have node, object, union, and enum and all are globally named types. The SDK does not have non-global inline types like stackbit does
                                `model`,
                        // models is always an array in stackbit, even if there's only 1 model type for this field
                        models: [name],
                    };
                })
                : false;
            return omitByUndefined({
                name,
                type: `list`,
                items: itemsOverride || omitByUndefined(items),
                group,
                hidden,
                required,
                default: defaultValue,
            });
        }
        else {
            return omitByUndefined(stackbitField);
        }
    }
    sdkFieldsToStackbitFields() {
        return this.fields
            .filter((field) => !field.name.startsWith(`_`))
            .map((field) => this.sdkFieldToStackbitField(field));
    }
    get dataAPI() {
        const walker = this.ModelWalker;
        return {
            name: this.typeName,
            originalName: this.originalName || this.typeName,
            insert: this.insert,
            // needed while unified API is being shipping in small pieces. create is replaced with insert going forward.
            create: this.insert,
            delete: this.delete,
            get fields() {
                return walker.fields;
            },
        };
    }
    buildWalker() {
        // FIXME(ndhoule): Incorrect type (https://github.com/netlify/sdk/pull/1170#discussion_r1556157222)
        // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression
        return this.ModelWalker.build();
    }
    getModelByName(typeName) {
        return this.ModelBuilder.models.get(this.ModelBuilder.pascaledNames.get(typeName) || typeName);
    }
    hasField(fieldName) {
        return this.fieldsMap.has(fieldName);
    }
    get delete() {
        return (nodeIds) => {
            if (!this.isNodeType) {
                throw new ModelError(`You cannot call delete() on a non-node type. You can only delete nodes. This model is a "${this.getTypeName()}" type.`);
            }
            const deleteNode = this.nodesApi?.deleteNode;
            if (!deleteNode) {
                throw new ModelError(`models.${this.typeName}.delete() can only be called inside createAllNodes or updateNodes Connector events.`);
            }
            const removeNode = (rawId) => {
                const id = this.createNodeId(rawId);
                if (this.createApi?.updateContent) {
                    if (this.typeName === `Asset`) {
                        this.createApi.updateContent({
                            deletedAssetIds: [rawId],
                        });
                    }
                    else {
                        this.createApi.updateContent({
                            deletedDocumentIds: [rawId],
                        });
                    }
                }
                if (!this.nodesApi?.getNode?.(id)) {
                    // in Connect if we get a delete request for a node that doesn't exist,
                    // we need to make sure it's removed from the ledger even if it's already not in lmdb
                    // calling deleteNode() on an already deleted node will prevent DELETE_NODE from being emitted
                    // this custom action will ensure that the node is removed from the ledger
                    // DELETE_MISSING_NODE instead of DELETE_NODE to avoid side effects in Gatsby and
                    // @netlify/content-engine as that action expects the node to exist
                    this.nodesApi?.dispatch?.({
                        type: `DELETE_MISSING_NODE`,
                        payload: {
                            id,
                            type: this.prefixedTypeName(),
                        },
                    });
                }
                // FIXME(ndhoule): Incorrect type (https://github.com/netlify/sdk/pull/1170#discussion_r1556157222)
                // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression
                return deleteNode({
                    id,
                    internal: {
                        type: this.prefixedTypeName(),
                        contentDigest: `0`,
                    },
                });
            };
            if (Array.isArray(nodeIds)) {
                return nodeIds.map(removeNode);
            }
            // FIXME(ndhoule): Incorrect type (https://github.com/netlify/sdk/pull/1170#discussion_r1556157222)
            // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression
            return removeNode(nodeIds);
        };
    }
    get insert() {
        return (nodes) => {
            if (!this.isNodeType) {
                throw new ModelError(`You cannot call create() on a non-node type. You can only create nodes. This model is a "${this.getTypeName()}" type.`);
            }
            const createNode = this.nodesApi?.createNode;
            if (!createNode) {
                throw new ModelError(`models.${this.typeName}.insert() can only be called inside documents.sync, createAllNodes, or updateNodes Connector events.`);
            }
            const insertNode = (node) => {
                if (!node)
                    return null;
                // if stackbit is present in this process
                if (this.createApi?.updateContent) {
                    const preparedNode = this.prepareNode(node, `stackbit`);
                    if (this.typeName === `Asset`) {
                        this.createApi.updateContent({
                            assets: [lmdbStoredAssetToStackbit(preparedNode)],
                        });
                    }
                    else {
                        this.createApi.updateContent({
                            documents: [lmdbStoredDocumentToStackbit(preparedNode, this)],
                        });
                    }
                    // if we have stackbit in this process, we store data in stackbit format and use GraphQL aliases to make Connect format resolve properly in GraphQL queries
                    createNode(preparedNode);
                    return preparedNode;
                }
                else {
                    // if there's no stackbit in this process, store data in @netlify/content-engine/Connect format.
                    const preparedNode = this.prepareNode(node, `content-engine`);
                    createNode(preparedNode);
                    return preparedNode;
                }
            };
            if (Array.isArray(nodes)) {
                return nodes.map((node) => insertNode(node));
            }
            return insertNode(nodes);
        };
    }
    createNodeId(rawId) {
        return this.createId(rawId, this.typeName);
    }
    prepareNode(node, forPackage = `content-engine`) {
        return this.ModelWalker.coerceModelValue(node, [], undefined, undefined, forPackage);
    }
    setIsMixedUnion() {
        this.isMixedUnion = true;
    }
    getGlobalCrossReference(connectorName, instanceID) {
        const globalConnector = getGlobalConnectorInstance(connectorName, instanceID);
        if (!globalConnector) {
            // allow unresolved cross references to be created for debugging purposes, and so that a connector with cross references wont break if the cross referenced connector isn't also installed. These wont be usable but they can be queried in GraphQL to see what the cross reference looks like
            return {
                referenceTypePrefix: `Unresolved__`,
                createReferenceId: (id) => id,
            };
        }
        return {
            referenceTypePrefix: globalConnector.typePrefix,
            createReferenceId: globalConnector.createId.bind(globalConnector),
        };
    }
    /**
     * Converts a type into the GraphQL Schema language (SDL). It's called for every Model.
     */
    toSDL() {
        const stackbitIsAvailable = !!this.createApi?.updateContent;
        if (this.isUnionType && this.compositeTypes) {
            return `union ${this.prefixedTypeName()} = ${this.compositeTypes
                .map((type) => this.prefixedTypeName(this.getDefinedTypeName(type, this.getTypeName())))
                .join(` | `)}`;
        }
        else if (this.isUnionType) {
            throw new ModelError(`You've defined a union type ("${this.getTypeName()}") but haven't provided any composite types.`);
        }
        function proxyFromIf(condition, fieldName) {
            return condition ? ` @proxy(from: "${fieldName}")` : ``;
        }
        const sharedCrossReferenceFields = `
  refId: ID!
  modelName: String! ${proxyFromIf(stackbitIsAvailable, `value.modelName`)}
  connectorName: String! ${proxyFromIf(stackbitIsAvailable, `refSrcType`)}
  instanceID: String! ${proxyFromIf(stackbitIsAvailable, `refProjectId`)}`;
        // for cross references to more than one type, we need to create a union type
        if (this.isCrossReferenceType && this.crossReferenceTo.length > 1) {
            const crossRefType = `type ${this.prefixedTypeName()} @dontInfer {${sharedCrossReferenceFields}
  reference: ${this.prefixedTypeName()}Union ${proxyFromIf(stackbitIsAvailable, "value.reference")} @link
}
`;
            const crossRefUnionType = `union ${this.prefixedTypeName()}Union = ${this.crossReferenceTo
                .map((to) => {
                const { referenceTypePrefix } = this.getGlobalCrossReference(to.connectorName, to.instanceID);
                return referenceTypePrefix + to.modelName;
            })
                .join(` | `)}`;
            return crossRefType + `\n` + crossRefUnionType;
        }
        else if (this.isCrossReferenceType &&
            this.crossReferenceTo.length === 1) {
            const { referenceTypePrefix } = this.getGlobalCrossReference(this.crossReferenceTo[0].connectorName, this.crossReferenceTo[0].instanceID);
            return `type ${this.prefixedTypeName()} @dontInfer {${sharedCrossReferenceFields}
  reference: ${referenceTypePrefix + this.crossReferenceTo[0].modelName} ${proxyFromIf(stackbitIsAvailable, `value.reference`)} @link
}`;
        }
        // building up SDL strings instead of using type builders in case we want to remove graphql-compose later. definitions are intentionally simple, so model shouldn't be an issue.
        let sdl = ``;
        if (this.description) {
            sdl += `"""${this.description}"""\n`;
        }
        if (this.isEnumType) {
            const enumValues = this.values?.map((value) => {
                return `"""${value.label}"""\n  ${value.value}`;
            });
            sdl += `enum ${this.prefixedTypeName()} {
  ${enumValues?.join(`\n  `)}
}`;
            return sdl;
        }
        sdl += `type ${this.prefixedTypeName()} `;
        if (this.isNodeType) {
            sdl += `implements Node `;
        }
        sdl += `@dontInfer {\n`;
        this.fields.forEach((fieldType) => {
            const fieldName = fieldType.name;
            const { type, required, list } = fieldType;
            // all internal fields are prefixed with _ the only one needed to be queried is _objectId
            // so that frontend html annotations to support Netlify Create can be added using this field.
            if (fieldName !== `_objectId` && fieldName.startsWith(`_`)) {
                return null;
            }
            const fieldTypeName = this.getDefinedTypeName(type, fieldName);
            const fieldModel = this.ModelBuilder.models.get(fieldTypeName);
            if (fieldType?.description) {
                sdl += `  """${fieldType.description}"""\n`;
            }
            sdl += `  ${fieldName}: `;
            let fieldSdl = ``;
            if (list) {
                fieldSdl += `[`;
            }
            const prefixedFieldType = this.prefixedTypeName(fieldTypeName, fieldType);
            if (prefixedFieldType === `richText`) {
                // currently we don't have a RichText scalar, so cast to JSON
                fieldSdl += `JSON`;
            }
            else {
                fieldSdl += prefixedFieldType;
            }
            if (required) {
                fieldSdl += `!`;
            }
            if (list) {
                fieldSdl += `]`;
            }
            if (list === `required`) {
                fieldSdl += `!`;
            }
            let isNodeType = fieldModel?.isNodeType;
            if (fieldModel?.isUnionType) {
                isNodeType = fieldModel.compositeTypes?.some((type) => {
                    const typeName = this.getDefinedTypeName(type, this.getTypeName());
                    return this.getModelByName(typeName)?.isNodeType;
                });
            }
            // when Stackbit is running in the current process, lmdb nodes are stored in Stackbit format
            // so proxy for that format. In production, nodes are stored in Connect format
            if (stackbitIsAvailable) {
                let proxyField = ``;
                if (fieldModel?.isCrossReferenceType) {
                    proxyField = list ? `items` : null;
                }
                else if (isNodeType &&
                    fieldModel?.isMixedUnion &&
                    fieldModel?.isUnionType) {
                    proxyField = list ? `items.fields` : `fields`;
                }
                else if (isNodeType && fieldModel?.isUnionType) {
                    proxyField = list ? `items._connectId` : `_connectId`;
                }
                else if (isNodeType) {
                    proxyField = list ? `items._connectId` : `_connectId`;
                }
                else if (fieldModel?.isObjectType || fieldModel?.isUnionType) {
                    proxyField = list ? `items.fields` : `fields`;
                }
                else {
                    proxyField = list ? `items.value` : `value`;
                }
                if (proxyField) {
                    fieldSdl += ` @proxy(from: "${fieldName}.${proxyField}")`;
                }
            }
            if (isNodeType) {
                fieldSdl += ` @link(from: "${fieldName}.id"${fieldModel?.isMixedUnion ? ` keepObjects: true` : ``})`;
            }
            sdl += `${fieldSdl}\n`;
        });
        sdl += `}`;
        return sdl;
    }
    containsIllegalChars(str) {
        return /[^a-zA-Z0-9_]/.test(str);
    }
    processInputDefinitionFields(definition) {
        if (!this.isObjectType && !this.isNodeType) {
            // only object/node types have fields currently
            return;
        }
        if ((!Array.isArray(definition.fields) &&
            typeof definition.fields !== `object`) ||
            !definition.fields) {
            throw new ModelError(`Field definitions must be an array or object, found ${typeof definition.fields} fields in "${definition.name}" definition.`);
        }
        // convert object field definitions to array
        if (!Array.isArray(definition.fields)) {
            this.fields = Object.entries(definition.fields).map(([fieldName, field]) => {
                return {
                    name: fieldName,
                    ...field,
                };
            });
        }
        else {
            // otherwise use provided array, do a light clone to avoid modifying the original
            this.fields = definition.fields.map((field) => ({ ...field }));
        }
        const stackbitIsRunningInThisProcess = !!this.createApi?.updateContent;
        const supportsCreate = this.supports.create;
        const builtInFields = [
            // connect fields
            {
                // this is set internally by the SDK. connector devs will not set this. it needs to be here to be stored in Create
                name: `_objectId`,
                type: `String`,
                required: true,
                description: `The original non-global ID from this data source`,
                editor: {
                    hidden: true,
                    readOnly: true,
                },
            },
            {
                // this is set internally by the SDK. connector devs will not set this. it needs to be here to be stored in Create
                name: `_originalType`,
                type: `String`,
                required: true,
                description: `The original non-global type name from this data source`,
                editor: {
                    readOnly: true,
                    hidden: true,
                },
            },
            {
                // this is set internally by the SDK. connector devs will not set this. it needs to be here to be stored in Create
                name: `_connectId`,
                type: `String`,
                required: stackbitIsRunningInThisProcess,
                editor: {
                    hidden: true,
                },
            },
            // create fields
            {
                name: `_updatedAt`,
                type: `Date`,
                required: stackbitIsRunningInThisProcess,
                editor: {
                    hidden: true,
                },
            },
            {
                name: `_createdAt`,
                type: `Date`,
                required: stackbitIsRunningInThisProcess,
                editor: {
                    hidden: true,
                },
            },
            {
                name: `_status`,
                type: supportsCreate ? `StatusEnum` : `String`,
                required: stackbitIsRunningInThisProcess,
                editor: {
                    hidden: true,
                },
            },
            {
                name: `_manageUrl`,
                type: supportsCreate ? `Url` : `String`,
                editor: {
                    hidden: true,
                },
            },
            {
                name: `_createdBy`,
                type: `String`,
                editor: {
                    hidden: true,
                },
            },
            {
                name: `_updatedBy`,
                type: `String`,
                list: true,
                editor: {
                    hidden: true,
                },
            },
            {
                name: `_locale`,
                type: `String`,
                editor: {
                    hidden: true,
                },
            },
        ];
        if (this.isNodeType) {
            this.fields.push(...builtInFields);
        }
        this.fields.forEach((field) => {
            // don't camelcase or validate builtin fields
            if (!this.isNodeType || !builtInFields.includes(field)) {
                if (this.shouldAutoRenameFieldsAndModels) {
                    const fieldName = field.name;
                    const camelFieldName = _.camelCase(fieldName);
                    if (fieldName !== camelFieldName) {
                        this.camelToOriginalNames.set(camelFieldName, fieldName);
                        this.originalToCamelNames.set(fieldName, camelFieldName);
                        field.name = camelFieldName;
                    }
                }
                this.validateFieldDefinition(field);
            }
            if (this.fieldsMap.has(field.name)) {
                throw new ModelError(`Model field definition with name ${this.getTypeName()}.${field.name} has been defined more than once. Each field name must be unique.`);
            }
            if (field.kind &&
                ![`prefer-builtin`, `prefer-defined`, `builtin`, `defined`].includes(field.kind)) {
                throw new ModelError(`Field kind must be "prefer-builtin", "prefer-defined", "builtin", or "defined" but ${this.getTypeName()}.${field.name}.kind is set to "${field.kind}"`);
            }
            if (!field.kind)
                field.kind = `prefer-builtin`;
            this.fieldsMap.set(field.name, field);
        });
    }
    processInputDefinition(definition) {
        if (this.definedKind !== `Node` && definition.cacheFieldName) {
            throw new ModelError(`You cannot provide a "cacheFieldName" for a non-Node type. "cacheFieldName" is only valid when using define.nodeModel({ ... }). This setting specifies which property on nodes should be used to invalidate each cached node.`);
        }
        if (typeof this.typeName !== `string`) {
            throw new ModelError(`The name of a model must be a string. For example: define.nodeModel({ name: "MyType", ... })`);
        }
        if (this.definedKind !== `Enum` && definition.values) {
            throw new ModelError(`You cannot provide "values" for a non-Enum type. "values" is only valid when using define.enum({ ... }).`);
        }
        if (this.definedKind === `Enum`) {
            const invalidEnumValue = definition.values?.find((value) => {
                if (typeof value !== `string` && typeof value !== `object`) {
                    return true;
                }
                if (typeof value === `object` && !value?.label && !value?.value) {
                    return true;
                }
            });
            if (invalidEnumValue) {
                throw new ModelError(`Enum values can only be strings. "${typeof invalidEnumValue === "object"
                    ? JSON.stringify(invalidEnumValue)
                    : invalidEnumValue}" is not valid.`);
            }
            // Transform all strings into objects to avoid having to check for the type of each value in the rest of the code
            this.values = (definition.values || []).map((value) => {
                if (typeof value === `string`) {
                    return { label: value, value };
                }
                return {
                    label: value.label,
                    value: value.value,
                };
            });
        }
        // For Netlify Create don't camel case model names. In a future release this will become the default, but this is a breaking change for now so do it conditionally.
        if (this.shouldAutoRenameFieldsAndModels) {
            const pascaled = camelcase(this.typeName, {
                pascalCase: true,
            });
            if (pascaled !== definition.name) {
                definition.ModelBuilder.pascaledNames.set(this.typeName, pascaled);
                this.originalName = definition.name;
                this.typeName = definition.name = pascaled;
            }
        }
        if (this.containsIllegalChars(this.typeName)) {
            throw new ModelError(`Names can only contain english language letters and numbers. "${definition.name}" is not valid.`);
        }
        if (definition.editor) {
            const { label, isPage, singleInstance, preview, fieldGroups } = definition.editor;
            if (label) {
                this.label = label;
            }
            if (isPage) {
                this.isPageType = true;
            }
            if (singleInstance) {
                this.isEditorSingleInstance = true;
            }
            if (preview) {
                if (definition.kind === `Object`) {
                    this.editorObjectPreview = preview;
                }
                if (definition.kind === `Node`) {
                    this.editorDocumentPreview = preview;
                }
            }
            if (fieldGroups) {
                this.fieldGroups = fieldGroups;
            }
        }
        if (definition.kind === `CrossReference`) {
            if (!definition.to)
                throw new ModelError(`CrossReference must have a "to" field`);
            this.crossReferenceTo = Array.isArray(definition.to)
                ? definition.to
                : [definition.to];
        }
        this.processInputDefinitionFields(definition);
        this.compositeTypes?.forEach((type) => {
            this.compositeTypesSet.add(this.getDefinedTypeName(type));
        });
        this.cacheFieldName = definition.cacheFieldName;
        if (this.cacheFieldName) {
            const cacheFieldDef = this.fieldsMap.get(this.cacheFieldName);
            if (!cacheFieldDef) {
                throw new ModelError(`You've defined a cacheFieldName ("${this.cacheFieldName}") but haven't defined a field with that name.`);
            }
            if (!cacheFieldDef.required) {
                throw new ModelError(`You've defined a cacheFieldName ("${this.cacheFieldName}") but that field is not defined as required. For proper cache invalidation this field must always exist.`);
            }
            if (cacheFieldDef.list) {
                throw new ModelError(`You've defined a cacheFieldName ("${this.cacheFieldName}") but that field type is a list. For proper cache invalidation the cacheFieldName can only be set to a non-list field type.`);
            }
            const cacheFieldTypeName = this.getDefinedTypeName(cacheFieldDef.type);
            if (cacheFieldDef.type !== `String` &&
                mappedBuiltinTypes.get(cacheFieldTypeName) !== `String`) {
                throw new ModelError(`You've defined a cacheFieldName ("${this.cacheFieldName}") For proper cache invalidation the cacheFieldName can only be set to a "String" field type. The "${this.cacheFieldName}" field is of type "${cacheFieldTypeName}".`);
            }
        }
    }
    validateFieldDefinition(fieldDef) {
        const fieldName = fieldDef.name;
        if (typeof fieldName !== `string`) {
            throw new ModelError(`Field names must be strings. "${JSON.stringify(fieldName, null, 2)}" is not a string`);
        }
        if (this.containsIllegalChars(fieldName)) {
            throw new ModelError(`Names can only contain english language letters and numbers. "${fieldName}" is not valid.`);
        }
        if (fieldName.match(/^\d/)) {
            throw new ModelError(`Names cannot start with a number. "${fieldName}" is not valid.`);
        }
        if (typeof fieldDef !== `object` || Array.isArray(fieldDef)) {
            throw new ModelError(`Field type definitions must be objects. "${JSON.stringify(fieldDef, null, 2)}" is not an object.`);
        }
        if (typeof fieldDef.type === `string`) {
            const lowercasedBuiltIn = mappedBuiltinTypes.get(fieldDef.type);
            if (lowercasedBuiltIn) {
                fieldDef.type = lowercasedBuiltIn;
            }
        }
        const fieldTypeName = this.getDefinedTypeName(fieldDef.type, fieldName);
        if (typeof fieldTypeName !== `string`) {
            throw new ModelError(`Field definition "${fieldName}.type" must be defined as a string. For ex -> ${fieldName}: { type: "Boolean" }
Instead you have defined it as "${JSON.stringify(fieldTypeName, null, 2)}"`);
        }
        if ([`[`, `]`, `!`].some((char) => fieldTypeName.includes(char))) {
            throw new ModelError(`The type of field "${fieldName}" must not be an SDL string.
For example this is not allowed
  ${fieldName}: { type: "${fieldTypeName}" }
use something like the following instead
  ${fieldName}: { type: "${fieldTypeName
                .replaceAll(`[`, ``)
                .replaceAll(`]`, ``)
                .replaceAll(`!`, ``)}", required: ${fieldTypeName.includes(`!`)}${fieldTypeName.includes(`[`)
                ? `, list: ${fieldTypeName.includes(`]!`) ? `"required"` : `true`}`
                : ``} }`);
        }
        if ([`id`, `internal`, `fields`, `__typename`, `versionId`].includes(fieldName.toLowerCase())) {
            throw new ModelError(`"${fieldName}" is a built-in reserved field name and cannot be redefined, a different field name must be used.`);
        }
        if (this.isUnionType && !this.compositeTypes?.length) {
            throw new ModelError(`You must provide at least one type when defining a union. For example: define.union({ name: "MyUnion", types: ["MyType"] })`);
        }
        if (fieldDef.visitor && typeof fieldDef.visitor !== `function`) {
            throw new ModelError(`Field visitors must be defined as a function. Found ${typeof fieldDef.visitor}`);
        }
        if (`required` in fieldDef &&
            typeof fieldDef.required !== `undefined` &&
            typeof fieldDef.required !== `boolean`) {
            throw new ModelError(`The "required" property in field definitions must either be undefined or a boolean value. Found ${typeof fieldDef.required} for field ${fieldDef.name}`);
        }
    }
}
