import * as CSITypes from "@stackbit/types";
import type { FieldInitialValueFunction, DocumentFieldPreview } from "@stackbit/types";
import { ConnectorSupports } from "../sdk.js";
import { ConfiguredNetlifyConnector, NodesApi } from "../connector-instance.js";
import { ModelWalker } from "./walker.js";
import { ModelBuilder } from "./builder.js";
type DefineArgs = {
    name: string;
    description?: string;
    visitor?: Visitor;
};
type NetlifyCreateSharedEditorModelSettings = {
    fieldGroups?: FieldGroupItem[];
    label?: string;
};
export type NetlifyCreateEditorObjectSettings = NetlifyCreateSharedEditorModelSettings & {
    preview?: DocumentFieldPreview;
};
export type NetlifyCreateEditorDocumentSettings = NetlifyCreateSharedEditorModelSettings & {
    preview?: CSITypes.DocumentPreview;
    /** @description flags a document model as a page type in Netlify Create **/
    isPage?: boolean;
    /** @description marks this document model as being a singleton type in the Netlify Create editor. This is useful for global, singleton models, which are typically used to affect globally-shared content on the site, such as settings, styles, and default SEO values. **/
    singleInstance?: boolean;
};
export type DefineObjectArgs = DefineArgs & {
    fields: ModelFields;
    editor?: NetlifyCreateEditorObjectSettings;
};
export type DefineEnumArgs = DefineArgs & {
    values: string[] | {
        label: string;
        value: string;
    }[];
};
export type DefineNodeArgs = DefineArgs & {
    cacheFieldName?: string;
    fields: ModelFields;
};
/**
 * Defines a document type.
 */
export type DefineDocumentArgs = Omit<DefineObjectArgs, "editor"> & {
    cacheFieldName?: string;
    editor?: NetlifyCreateEditorDocumentSettings;
};
export type DefineUnionArgs = DefineArgs & {
    types: (string | ModelDefinition)[];
};
type CrossReferenceTo = {
    /** @description the name of the model that this cross-reference is for **/
    modelName: string;
    /** @description the name of the connector that this cross-reference is for **/
    connectorName: string;
    /** @description the instance ID of the connector that this cross-reference is for **/
    instanceID: string;
};
export type DefineCrossReferenceArgs = DefineInlineArgs<DefineArgs> & {
    /** @description the model this cross-reference can point to **/
    to: CrossReferenceTo[] | CrossReferenceTo;
};
type DefineInlineArgs<T> = Omit<T, "name"> & {
    /** @description If provided, the name will be used as the prefix in the generated type name for the inline type **/
    name?: string;
};
export type DefineInlineUnionArgs = DefineInlineArgs<DefineUnionArgs>;
export type DefineInlineEnumArgs = DefineInlineArgs<DefineEnumArgs>;
export type DefineInlineObjectArgs = DefineInlineArgs<DefineObjectArgs>;
type DefineKind = `Object` | `Union` | `Node` | `Enum` | `CrossReference`;
export type ModelField = {
    name: string;
    type: string | ModelDefinition;
    required?: boolean;
    list?: boolean | `required`;
    description?: string;
    visitor?: FieldVisitor;
    /**
     * @description Used to resolve conflicts between internal and defined types. ex: Text/String/Boolean/etc.
     * @default "prefer-builtin"
     */
    kind?: `prefer-builtin` | `prefer-defined` | `defined` | `builtin`;
    localized?: boolean;
    editor?: NetlifyCreateEditorFieldSettings;
};
export type NetlifyCreateEditorFieldSettings = {
    hidden?: boolean;
    label?: string;
    readOnly?: boolean;
    /** @description sets the field group this field will show up in in the Netlify Create Editor **/
    group?: string;
    /** @description sets the initial value for this field in the Netlify Create editor **/
    initialValue?: FieldInitialValueFunction | unknown;
    /** @description configures the UI preview data for this field in the Netlify Create editor **/
    preview?: DocumentFieldPreview;
    controlType?: `slider` | `dropdown` | `thumbnail` | `button-group` | `checkbox` | `image` | `file`;
    numberOptions?: {
        min?: number;
        max?: number;
        step?: number;
        unit?: string;
    };
    thumbnailOptions?: {
        label: string;
        thumbnail: string;
        value: string;
    }[];
};
export interface FieldGroupItem {
    name: string;
    label: string;
    icon?: string;
}
export type ModelFieldsObject = {
    [name: string]: Omit<ModelField, `name`>;
};
export type ModelFieldsArray = ModelField[];
export type ModelFields = ModelFieldsArray | ModelFieldsObject;
export type RawNodeObject = {
    id?: string;
    [key: string]: any;
};
type VisitorValue = any;
export type Visitor = (value: VisitorValue, info: {
    visitorContext: any;
    setVisitorContext: (newContext: any) => any;
    fields: ModelWalker["fields"];
}) => VisitorValue;
export type FieldVisitor = (value: VisitorValue, info: ReturnType<ModelWalker["fieldByName"]>) => VisitorValue;
export declare const builtInStackbitStringTypes: Set<string>;
export declare const builtInStackbitTypes: Set<string>;
export declare const builtInTypes: Set<string>;
export declare const mappedBuiltinTypes: Map<string, string>;
export declare const builtInScalars: Set<string>;
type ModelDefinitionInput = {
    kind: DefineKind;
    ModelBuilder: ModelBuilder;
    nodesApi: NodesApi;
    createId: ConfiguredNetlifyConnector["createId"];
    createApi?: CSITypes.Cache;
    shouldAutoRenameFieldsAndModels: boolean;
    supports: ConnectorSupports;
    isInternalType: boolean;
    isInlineType?: boolean;
    isExtendedDefinition?: boolean;
} & Omit<DefineArgs, "name"> & {
    name?: string;
} & Partial<DefineNodeArgs & DefineObjectArgs & DefineUnionArgs & DefineDocumentArgs & DefineCrossReferenceArgs & DefineEnumArgs>;
export declare class ModelDefinition {
    compositeTypes?: (string | ModelDefinition)[];
    compositeTypesSet: Set<string>;
    description?: string;
    cacheFieldName?: string;
    ModelWalker: ModelWalker;
    ModelBuilder: ModelBuilder;
    private createId;
    visitor?: Visitor;
    camelToOriginalNames: Map<string, string>;
    originalToCamelNames: Map<string, string>;
    fields: ModelField[];
    fieldsMap: Map<string, ModelField>;
    fieldGroups?: NetlifyCreateSharedEditorModelSettings["fieldGroups"];
    values?: {
        label: string;
        value: string;
    }[];
    isMixedUnion: boolean;
    private definedKind;
    private typeName;
    private originalName?;
    private nodesApi;
    private createApi?;
    private label?;
    private shouldAutoRenameFieldsAndModels;
    private supports;
    private isExtendedDefinition;
    private _isInternalType;
    private isPageType?;
    private editorDocumentPreview?;
    private editorObjectPreview?;
    crossReferenceTo: CrossReferenceTo[];
    private isEditorSingleInstance?;
    private _isInlineType;
    constructor(input: ModelDefinitionInput);
    _mergeExtendedDefinition(extendedDefinition: ModelDefinition, modelBuilder: ModelBuilder): void;
    getFields(): ModelField[];
    getTypeName(): string;
    getOriginalName(): string;
    get isInternalType(): boolean;
    get isInlineType(): boolean;
    get isNodeType(): boolean;
    get isObjectType(): boolean;
    get isUnionType(): boolean;
    get isEnumType(): boolean;
    get isCrossReferenceType(): boolean;
    getDefinedTypeName(type: string | ModelDefinition, fieldName?: string): string;
    prefixedTypeName(typeName?: string, field?: ModelField): string;
    getFinalFieldName(fieldName: string, unionModelName?: string): string;
    private toCreateInlineFieldDefinition;
    toCreateModel(): CSITypes.ObjectModel | CSITypes.PageModel | CSITypes.DataModel | false;
    /**
     *
     * Introduced specifically to keep the casing of the richText simple type.
     * At the time of writing (March 7 2024) this is the only type with any camelcasing, the rest
     * can be safely lowercased.
     */
    getFormattedTypename(typename: string): CSITypes.Field["type"];
    private sdkFieldToStackbitField;
    private sdkFieldsToStackbitFields;
    get dataAPI(): {
        name: string;
        originalName: string;
        insert: (nodes?: RawNodeObject | RawNodeObject[] | undefined) => any;
        create: (nodes?: RawNodeObject | RawNodeObject[] | undefined) => any;
        delete: (nodeIds: string | string[]) => void | void[];
        readonly fields: import("./walker.js").Fields;
    };
    buildWalker(): void;
    private getModelByName;
    hasField(fieldName: string): boolean;
    private get delete();
    private get insert();
    createNodeId(rawId: string): string;
    private prepareNode;
    setIsMixedUnion(): void;
    getGlobalCrossReference(connectorName: string, instanceID: string): {
        referenceTypePrefix: string;
        createReferenceId: (rawId: string, modelName: string) => string;
    };
    /**
     * Converts a type into the GraphQL Schema language (SDL). It's called for every Model.
     */
    toSDL(): string;
    private containsIllegalChars;
    private processInputDefinitionFields;
    private processInputDefinition;
    private validateFieldDefinition;
}
export {};
