import { type SourceNodesArgs } from "@netlify/content-engine";
import * as CSITypes from "@stackbit/types";
import { type ConnectorSupports, type PlatformType } from "../sdk.js";
import { type ConfiguredNetlifyConnector, type NodesApi } from "../connector-instance.js";
import { type Locale } from "../types/csi.js";
import { DefineCrossReferenceArgs, DefineDocumentArgs, DefineEnumArgs, DefineInlineEnumArgs, DefineInlineObjectArgs, DefineInlineUnionArgs, DefineNodeArgs, DefineObjectArgs, DefineUnionArgs, ModelDefinition, ModelFields } from "./definition.js";
export type Define = ModelBuilder["pluginAPI"]["define"];
export type Extend = ModelBuilder["pluginAPI"]["extend"];
export type ModelerArgs<State> = {
    define: Define;
    extend: Extend;
    cache: SourceNodesArgs["cache"];
    state: State;
    platform: PlatformType;
};
export type Modeler<State, ConfigurationOptions extends Record<string, any>> = (args: ModelerArgs<State>, configurationOptions: ConfigurationOptions) => Promise<void>;
export type Models = {
    [modelName: string]: ModelDefinition["dataAPI"];
    [Symbol.iterator](): IterableIterator<ModelDefinition["dataAPI"]>;
} & Record<string, ModelDefinition["dataAPI"]> & {
    concurrent(count: number, callback: (model: ModelDefinition["dataAPI"]) => Promise<void> | void): Promise<void> | void;
};
export type ModelsIteratorObject = Models;
export declare class ModelBuilder {
    models: Map<string, ModelDefinition>;
    private extendedModels;
    modelDataAPIs: Models;
    complete: boolean;
    sdl: string;
    locales: Locale[];
    typePrefix: string;
    nodesApi: NodesApi;
    createApi?: CSITypes.Cache;
    createId: ConfiguredNetlifyConnector["createId"];
    slug: string;
    private supports;
    pascaledNames: Map<string, string>;
    private seenTypePaths;
    private shouldAutoRenameFieldsAndModels;
    constructor({ nodesApi, createApi, supports, slug, createId, }: {
        nodesApi: NodesApi;
        createApi?: CSITypes.Cache;
        supports: ConnectorSupports;
        slug: string;
        createId: ConfiguredNetlifyConnector["createId"];
    });
    private defineAPI;
    get pluginAPI(): {
        define: {
            /**
             *
             */
            crossReference: (args: DefineCrossReferenceArgs) => ModelDefinition;
            /**
             * Defines an enum scalar type. Enum types are used to define fields on node models where the field may only contain one of the values specified as
             * part of the type definition.
             */
            enum: (args: DefineEnumArgs) => ModelDefinition;
            /**
             * Defines an enum scalar type. Enum types are used to define fields on node models where the field may only contain one of the values specified as
             * part of the type definition.
             * Inline enum types are identical to object types, but do not require a name. The name will be generated by hashing the definition.
             */
            inlineEnum: (args: DefineInlineEnumArgs) => ModelDefinition;
            /**
             * @warning - this is an experimental API. Only use if you know what you're doing
             */
            document: (args: DefineDocumentArgs) => ModelDefinition;
            /**
             * Defines a node model. Nodes are database records that can be queried by their ID. Defining a type allows you to create and update nodes of that type during the createAllNodes and updateNodes data events.
             */
            nodeModel: (args: DefineNodeArgs) => ModelDefinition;
            /**
             * Defines an object type. Object types are used to define fields on node models.
             */
            object: (args: DefineObjectArgs) => ModelDefinition;
            /**
             * Defines an inline object type. Object types are used to define fields on node models.
             * Inline object types are identical to object types, but do not require a name. The name will be generated by hashing the definition.
             */
            inlineObject: (args: DefineInlineObjectArgs) => ModelDefinition;
            /**
             * Defines a union type. Union types are used to define fields on node models where the field may be of multiple different types.
             */
            union: (args: DefineUnionArgs) => ModelDefinition;
            /**
             * Defines a union type. Union types are used to define fields on node models where the field may be of multiple different types.
             * Inline union types are identical to object types, but do not require a name. The name will be generated by hashing the definition.
             */
            inlineUnion: (args: DefineInlineUnionArgs) => ModelDefinition;
            /**
             * @warning this is an experimental API. Only use if you know what you're doing :)
             */
            locales: (locales: Locale[]) => void;
        };
        extend: {
            Asset: (definition: {
                fields: ModelFields;
            }) => void | undefined;
        };
    };
    private get defineInternal();
    private defineInternalCreateModels;
    build({ modeler, typePrefix, cache, configurationOptions, state, shouldAutoRenameFieldsAndModels, platform, }: {
        modeler: Modeler<any, any>;
        typePrefix: string;
        cache: SourceNodesArgs["cache"];
        configurationOptions: Record<string, any>;
        state: Record<string, any>;
        shouldAutoRenameFieldsAndModels?: boolean;
        platform: PlatformType;
    }): Promise<{
        sdl: string;
    }>;
    toCreateModels(): (CSITypes.ObjectModel<unknown> | CSITypes.PageModel<unknown> | CSITypes.DataModel<unknown>)[];
    extendModel(model: ModelDefinition): this;
    addModel(model: ModelDefinition): this;
    private reset;
    private finalizeModels;
    private setSeenTypePaths;
    private validateModelHarmony;
    private throwOnInlineUnionMemberTypes;
    private throwOnMixedUnionListFields;
    private renamePascaledFieldTypes;
    private handleMixedUnionTypes;
    private panicOnUndefinedModels;
}
