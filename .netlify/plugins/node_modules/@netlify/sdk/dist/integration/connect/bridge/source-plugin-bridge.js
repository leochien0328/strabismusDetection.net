import path from "path";
import { writeFile } from "fs/promises";
import { DateTimeTypeDefinition } from "graphql-scalars";
import chalk from "chalk";
import { builtInStackbitStringTypes } from "../model/definition.js";
import { ModelError } from "../model/error.js";
import { delayedExit } from "../utils/delayed-exit.js";
import { getRemoteGraphQLSchemaFn } from "../utils/get-remote-graphql-schema.js";
import { BridgePluginAPI } from "./bridge.js";
// the internal source plugin calls APIs on this class to interact with the connector
// the methods on this class are content-engine/Gatsby APIs
export class SourcePluginBridgeAPI extends BridgePluginAPI {
    contentEngineCache;
    async onPluginInit(helpers, pluginOptions) {
        const startTime = Date.now();
        const connector = this.runningConnector;
        const { cache } = helpers;
        this.contentEngineCache = {
            get: cache.get.bind(cache),
            set: cache.set.bind(cache),
            delete: cache.del.bind(cache),
        };
        await connector.setOptionsValues(pluginOptions);
        await connector._initialize();
        this.log(`initialized ${chalk.blue(`${(Date.now() - startTime).toString()}ms`)}`);
    }
    /**
     * content-engine / Gatsby API - will be called by internal source plugin
     */
    async createSchemaCustomization(schemaCustomizationApi) {
        const connector = this.runningConnector;
        if (connector.proxiedSchemas.length) {
            await Promise.all(connector.proxiedSchemas?.map(async (fn) => {
                const schema = (await fn({
                    options: connector.optionsValues,
                    typePrefix: connector.config.typePrefix,
                    state: connector.initState,
                    getRemoteGraphQLSchema: getRemoteGraphQLSchemaFn(connector.config.typePrefix),
                }));
                schemaCustomizationApi.actions.addThirdPartySchema({
                    schema,
                });
            }));
        }
        if (connector.supports.create) {
            // add builtin Create string-like types when Create support is enabled.
            // This is a workaround for content-engine (models are defining SDL and GraphQL needs this buildScalarType result),
            // we don't want to duplicate this pattern if possible.
            schemaCustomizationApi.actions.createTypes(Array.from(builtInStackbitStringTypes.keys()).map((name) => schemaCustomizationApi.schema.buildScalarType({
                name,
                description: `Netlify Create ${name} String type`,
            })));
        }
        schemaCustomizationApi.actions.createTypes(DateTimeTypeDefinition);
        const { connect } = connector.getAPIPromises("model");
        const startTime = Date.now();
        const { sdl } = await connector._buildDefinedModels(schemaCustomizationApi.cache);
        if (sdl)
            schemaCustomizationApi.actions.createTypes(sdl);
        if (process.env.NODE_ENV === `development` ||
            process.env.NODE_ENV === `test`) {
            const moreThanOneDevConnector = Array.isArray(connector.config.localDevOptions) &&
                connector.config.localDevOptions.length > 1;
            await writeFile(path.join(process.cwd(), `dev-model${moreThanOneDevConnector ? "-" + connector.ModelBuilder.typePrefix : ``}.gql`), `# this file is automatically generated. Its only purpose is for debugging and understanding how your model definitions translate to GraphQL\n\n${sdl}`);
        }
        this.log(`defined ${connector.ModelBuilder.models.size} models ${chalk.blue(`${(Date.now() - startTime).toString()}ms`)}`);
        connect.resolve(connector.ModelBuilder);
    }
    async sourceNodes(args, options) {
        const connector = this.runningConnector;
        connector.syncCount = 0;
        connector.nodesApi.createNode = (input) => {
            connector.syncCount++;
            return args.actions.createNode(input);
        };
        connector.nodesApi.deleteNode = (input) => {
            connector.syncCount++;
            // FIXME(ndhoule): Incorrect type (https://github.com/netlify/sdk/pull/1170#discussion_r1556157222)
            // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression
            return args.actions.deleteNode(input);
        };
        connector.nodesApi.dispatch = args.store.dispatch;
        connector.nodesApi.getNode = args.getNode;
        connector.nodesApi.cache = args.cache;
        connector.nodesApi.pluginOptions = options;
        connector.nodesApi.webhookBody = args.webhookBody || {};
        const syncingLog = setTimeout(() => {
            this.log(`syncing`, {
                symbol: `â§—`,
                symbolColor: `yellow`,
            });
        }, 3000);
        const startTime = Date.now();
        try {
            await connector.sync(args);
        }
        catch (e) {
            if (e instanceof ModelError) {
                console.error(e.message);
            }
            else if (e instanceof Error) {
                console.error(e.stack);
            }
            else {
                console.error(e);
            }
            return delayedExit();
        }
        finally {
            connector.nodesApi.deleteNode = undefined;
            connector.nodesApi.cache = undefined;
            connector.nodesApi.pluginOptions = undefined;
        }
        clearTimeout(syncingLog);
        this.log(`synced ${connector.syncCount} records ${chalk.blue(`${(Date.now() - startTime).toString()}ms`)}\n`);
    }
}
