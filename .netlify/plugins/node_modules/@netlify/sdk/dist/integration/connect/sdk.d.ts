import { GraphQLSchema } from "graphql";
import zodLib from "zod";
import { type SourceNodesArgs, type PluginOptions } from "@netlify/content-engine";
import * as CSITypes from "@stackbit/types";
import { type NetlifyIntegration } from "../index.js";
import { type MaybePromise } from "../../lib/types.js";
import { type User } from "./types/csi.js";
import { type ModelBuilder, type Modeler, type ModelsIteratorObject } from "./model/builder.js";
import { ConnectorOptionsSchema, type BaseOptionsSchema, type DefineOptionsSchema, type DefineOptionsSchemaOptions, type DefineOptionsSchemaOutput } from "./utils/options.js";
import { ConfiguredNetlifyConnector } from "./connector-instance.js";
import { ModelDefinition } from "./model/definition.js";
import { RawAsset } from "./utils/data.js";
type GetDocument = (id: string) => CSITypes.Document<unknown> | undefined;
export declare class NetlifyConnector<State extends ConnectorContextState, OptionsSchema extends BaseOptionsSchema, LocalDevOptions extends BaseConnectorLocalDevOptions | BaseConnectorLocalDevOptions[] = BaseConnectorLocalDevOptions> {
    config: ConnectorConfig<LocalDevOptions>;
    private started;
    definedImplementations: Map<APIName, DefinedImplementation<any>>;
    isUsingUnifiedAPI: boolean;
    optionsSchema: ConnectorOptionsSchema<OptionsSchema>;
    proxiedSchemas: ProxiedSchemaFn<State, OptionsSchema>[];
    supports: ConnectorSupports;
    private integration;
    constructor(config: ConnectorConfigInput<LocalDevOptions>, integration: NetlifyIntegration<any, any, any, any>);
    /**
     * @warning - don't use this unless you know what you're doing :) this is an experimental API
     * @deprecated Prefer specifying this via `NetlifyIntegration#addConnector({ initState, <...> })`
     */
    init: (init: ConnectorInitState<DefineOptionsSchemaOutput<OptionsSchema>, State>) => void;
    /**
     * `defineOptions` accepts a function that Defines the user configuration options for your `NetlifyConnector`.
     * @deprecated Prefer specifying this via `NetlifyIntegration#addConnector({ defineOptions, <...> })`
     */
    defineOptions: (definer: DefineOptionsSchema<OptionsSchema>) => void;
    getOptionsSchema(): OptionsSchema;
    /**
     * Defines the content model for your Connector.
     * @link https://sdk.netlify.com/connectors/connector-apis/#model
     */
    model(modeler: Modeler<State, ConnectorConfig<LocalDevOptions>>): void;
    sync(sync: (args: {
        models: ModelsIteratorObject;
        webhookBody: Record<string, any>;
        isInitialSync: boolean | null;
        state: State;
        cache: Cache;
        options: DefineOptionsSchemaOutput<OptionsSchema>;
        platform: PlatformType;
    }) => Promise<void> | void): void;
    hasAccess(userFn: (options: {
        userContext?: {
            name: string;
            email: string;
            sso?: {
                idpId: string;
                firstName?: string;
                lastName?: string;
                emails?: {
                    value: string;
                    type?: string;
                    primary?: boolean;
                }[];
                attributes?: Record<string, any>;
            } | undefined;
        } | undefined;
    }) => Promise<{
        hasConnection: boolean;
        hasPermissions: boolean;
    }>): void;
    /**
     * @warning - don't use this unless you know what you're doing :) this is an experimental API
     */
    assets<AssetsType extends {
        userContext: unknown;
    }>(args: {
        create: (args: {
            state: State;
            fileName: string;
            mimeType: string;
            locale?: string;
            userContext?: User<AssetsType["userContext"]>;
            url?: string;
            base64?: string;
        }) => Promise<RawAsset> | RawAsset;
    }): void;
    /**
     * @warning - don't use this unless you know what you're doing :) this is an experimental API
     */
    documents<DocumentsType extends {
        userContext: unknown;
    }>(args: ConnectorDocuments<DocumentsType, OptionsSchema, State>): void;
    /**
     * Defines a data event. Supported events are `createAllNodes` and `updateNodes`.
     * @link https://sdk.netlify.com/connectors/connector-apis/#createallnodes
     */
    event(name: "createAllNodes" | "updateNodes", implementation: CreateNodesPluginApi | false): void;
    private checkCanDefine;
    proxySchema(fn: ProxiedSchemaFn<State, OptionsSchema>): void;
    getConnectorInstance(options: Record<string, any>, connectorName: string): ConfiguredNetlifyConnector;
}
declare module "zod" {
    interface ZodMeta {
        [k: string | number | symbol]: unknown;
    }
    interface ZodTypeDef {
        meta?: ZodMeta;
    }
    interface ZodType<Output = any, Def extends zodLib.ZodTypeDef = zodLib.ZodTypeDef, Input = Output> {
        getMeta(): this["_def"] extends {
            meta: infer M;
        } ? M : ZodMeta | undefined;
        meta<T extends ZodMeta = ZodMeta>(meta: T): ZodType<Output, Def extends {
            meta: infer M;
        } ? Def & {
            meta: M & T;
        } : Def & {
            meta: T;
        }, Input>;
    }
}
export type ConnectorDocuments<DocumentsType extends {
    userContext: unknown;
}, OptionsSchema extends BaseOptionsSchema, State extends ConnectorContextState> = {
    update: ConnectorDocumentsUpdate<DocumentsType, OptionsSchema, State>;
    create: ConnectorDocumentsCreate<DocumentsType, OptionsSchema, State>;
    delete: ConnectorDocumentsDelete<DocumentsType, OptionsSchema, State>;
    publish: ConnectorDocumentsPublish<DocumentsType, OptionsSchema, State>;
};
export type ConnectorDocumentsUpdate<DocumentsType extends {
    userContext: unknown;
}, OptionsSchema extends BaseOptionsSchema, State extends ConnectorContextState> = (args: {
    cache: Cache;
    document: any;
    getDocument: GetDocument;
    model: ModelDefinition["dataAPI"];
    models: ModelBuilder["modelDataAPIs"];
    operations: CSITypes.UpdateOperation[];
    options: DefineOptionsSchemaOutput<OptionsSchema>;
    platform: PlatformType;
    state: State;
    userContext: (User & DocumentsType["userContext"]) | undefined;
}) => MaybePromise<void>;
export type ConnectorDocumentsCreate<DocumentsType extends {
    userContext: unknown;
}, OptionsSchema extends BaseOptionsSchema, State extends ConnectorContextState> = (args: {
    cache: Cache;
    getDocument: GetDocument;
    model: ModelDefinition["dataAPI"];
    models: ModelBuilder["modelDataAPIs"];
    options: DefineOptionsSchemaOutput<OptionsSchema>;
    platform: PlatformType;
    state: State;
    updateOperationFields: Record<string, CSITypes.UpdateOperationField>;
    userContext: (User & DocumentsType["userContext"]) | undefined;
}) => MaybePromise<{
    documentId: string;
}>;
export type ConnectorDocumentsDelete<DocumentsType extends {
    userContext: unknown;
}, OptionsSchema extends BaseOptionsSchema, State extends ConnectorContextState> = (args: {
    cache: Cache;
    document: any;
    getDocument: GetDocument;
    model: ModelDefinition["dataAPI"];
    models: ModelBuilder["modelDataAPIs"];
    options: DefineOptionsSchemaOutput<OptionsSchema>;
    platform: PlatformType;
    state: State;
    userContext: (User & DocumentsType["userContext"]) | undefined;
}) => MaybePromise<void>;
export type ConnectorDocumentsPublish<DocumentsType extends {
    userContext: unknown;
}, OptionsSchema extends BaseOptionsSchema, State extends ConnectorContextState> = (args: {
    state: State;
    cache: Cache;
    options: DefineOptionsSchemaOutput<OptionsSchema>;
    documents: any[];
    userContext: (User & DocumentsType["userContext"]) | undefined;
    platform: PlatformType;
}) => MaybePromise<void>;
export type ConnectorSupports = {
    create: boolean;
    deltaSync: boolean;
};
export type ConnectorConfigInputSupports = Partial<ConnectorSupports>;
export type ConnectorConfigInput<LocalDevOptions extends BaseConnectorLocalDevOptions | BaseConnectorLocalDevOptions[] = BaseConnectorLocalDevOptions> = {
    localDevOptions?: LocalDevOptions | undefined;
    supports?: ConnectorConfigInputSupports | undefined;
    typePrefix: string;
};
export type getRemoteGraphQLSchema = {
    uri: string;
    headers?: Record<string, string>;
};
export type BaseConnectorLocalDevOptions = {
    [key: string]: string | boolean | number;
};
export type ConnectorConfig<LocalDevOptions extends BaseConnectorLocalDevOptions | BaseConnectorLocalDevOptions[] = BaseConnectorLocalDevOptions> = {
    localDevOptions: LocalDevOptions;
    supports: Partial<ConnectorSupports>;
    typePrefix: string;
};
export type ProxiedSchemaFn<State extends ConnectorContextState, OptionsSchema extends BaseOptionsSchema> = (options: {
    options: DefineOptionsSchemaOutput<OptionsSchema>;
    state: State;
    typePrefix: string;
    getRemoteGraphQLSchema(args: getRemoteGraphQLSchema): Promise<GraphQLSchema>;
}) => Promise<GraphQLSchema>;
export interface Cache {
    get<T = unknown>(key: string): Promise<T>;
    set<T = unknown>(key: string, value: T): Promise<void>;
    delete(key: string): Promise<void>;
}
export interface ConnectorAPIUtils<State, OptionsType> {
    /**
     * The data source options passed to the connector (creds etc.)
     */
    options: OptionsType;
    /**
     * Mutable state. Can be used for e.g. API clients. Do not use to store document data.
     */
    state: State;
    /**
     * Cache to store data between builds, e.g. sync tokens. Do not use to store document data.
     */
    cache: Cache;
    /**
     * Platform that the connector is running on.
     */
    platform: PlatformType;
}
export type CreateNodesPluginApi = (createAllNodesApi: {
    models: ModelsIteratorObject;
    cache: SourceNodesArgs["cache"];
    webhookBody: Record<string, any>;
}, pluginOptions: PluginOptions) => Promise<void> | void;
type DefinedImplementation<T = any> = false | ((args?: any, options?: any) => Promise<T> | T);
export type APIName = "sync" | "documents.update" | "documents.create" | "documents.delete" | "documents.publish" | "init" | "model" | "event.createAllNodes" | "event.updateNodes" | "hasAccess" | "assets.upload";
export type APIPromiseName = APIName | "runtime";
export type ConnectorContext<State extends ConnectorContextState> = {
    state: State;
};
export type ConnectorContextState = {
    [key: string]: unknown;
};
export type PlatformType = "netlify-connect" | "netlify-create" | "local" | "unknown";
export type ValidationError = {
    message: string;
    objectType: "document" | "asset";
    objectId: string;
    fieldPath: (string | number)[];
    isUniqueValidation?: boolean;
};
export type Asset<AssetContext = unknown> = {
    type: "asset";
    id: string;
    manageUrl: string;
    status: "added" | "modified" | "published" | "deleted";
    createdAt: string;
    createdBy?: string;
    updatedAt: string;
    updatedBy?: string[];
    locale?: string;
    fields: CSITypes.AssetFields;
    context: AssetContext;
    hidden?: boolean;
};
export { type BaseOptionsSchema as ConnectorBaseOptionsSchema, type DefineOptionsSchemaOutput as ConnectorDefineOptionsSchemaOutput, } from "./utils/options.js";
export type ConnectorDefineOptionsOptions = DefineOptionsSchemaOptions;
export type ConnectorDefineOptions<OptionsSchema extends BaseOptionsSchema> = DefineOptionsSchema<OptionsSchema>;
export type ConnectorInitStateOptions<Options> = Omit<ConnectorAPIUtils<never, Options>, "state">;
export type ConnectorInitState<State, Options> = (options: ConnectorInitStateOptions<Options>) => MaybePromise<State & {
    projectManageUrl?: string;
}>;
