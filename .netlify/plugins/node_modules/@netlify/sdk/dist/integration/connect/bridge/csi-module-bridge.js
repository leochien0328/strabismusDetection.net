import { lmdbStoredAssetToStackbit } from "../utils/data.js";
import { ModelError } from "../model/error.js";
import { BridgePluginAPI } from "./bridge.js";
export class CSIBridgeAPI extends BridgePluginAPI {
    cache;
    get stackbitCache() {
        if (!this.cache) {
            throw new ModelError(`Netlify Create cache is not available but it should be. This is a bug in the Netlify SDK.`);
        }
        return this.cache;
    }
    async init({ cache }) {
        // wait for Connects init to finish
        const { connect, create } = this.runningConnector.getAPIPromises("init");
        await connect.promise;
        // send back the Create cache so the SDK can use it to insert & delete
        // documents/assets/etc
        create.resolve(cache);
        this.cache = cache;
    }
    async hasAccess(args) {
        const connector = this.runningConnector;
        const access = connector.definedImplementations.get("hasAccess");
        if (access) {
            return access(args);
        }
        return Promise.resolve({
            hasPermissions: true,
            hasConnection: true,
        });
    }
    async uploadAsset(args) {
        const connector = this.runningConnector;
        const upload = connector.definedImplementations.get("assets.upload");
        if (upload) {
            const returnVal = await upload({
                fileName: args.fileName,
                mimeType: args.mimeType,
                base64: args.base64,
                url: args.url,
                locale: args.locale,
                userContext: args.userContext,
                state: connector.initState,
            });
            return lmdbStoredAssetToStackbit(connector.ModelBuilder.modelDataAPIs.Asset.insert(returnVal));
        }
        throw new Error("connector.assets({ upload: fn }) is not implemented");
    }
    async updateDocument(args) {
        const connector = this.runningConnector;
        const update = connector.definedImplementations.get("documents.update");
        const modelName = args.document.modelName;
        if (update) {
            const model = connector.ModelBuilder.modelDataAPIs[modelName];
            if (!model) {
                throw new ModelError(`No model found with name ${modelName}`);
            }
            const getDocument = this.stackbitCache.getDocumentById;
            return update({
                model,
                models: connector.ModelBuilder.modelDataAPIs,
                document: args.document,
                state: connector.initState,
                cache: connector.sourcePluginAPI.contentEngineCache,
                options: connector.optionsValues,
                operations: args.operations,
                userContext: args.userContext,
                platform: connector.platform,
                getDocument,
            });
        }
        throw new Error("connector.documents({ update: fn }) is not implemented");
    }
    async createDocument(args) {
        const connector = this.runningConnector;
        const create = connector.definedImplementations.get("documents.create");
        if (!create) {
            throw new Error("connector.documents({ create: fn }) is not implemented");
        }
        const modelName = args.model.name;
        const model = connector.ModelBuilder.modelDataAPIs[modelName];
        if (!model) {
            throw new ModelError(`No model found with name ${modelName}`);
        }
        const getDocument = this.stackbitCache.getDocumentById;
        const connectorReturnedVal = await create({
            model,
            models: connector.ModelBuilder.modelDataAPIs,
            state: connector.initState,
            options: connector.optionsValues,
            cache: connector.sourcePluginAPI.contentEngineCache,
            updateOperationFields: args.updateOperationFields,
            userContext: args.userContext,
            platform: connector.platform,
            getDocument,
        });
        return connectorReturnedVal;
    }
    async deleteDocument(args) {
        const connector = this.runningConnector;
        const del = connector.definedImplementations.get("documents.delete");
        if (!del) {
            throw new Error("connector.documents({ delete: fn }) is not implemented");
        }
        const modelName = args.document?.modelName;
        const model = connector.ModelBuilder.modelDataAPIs[modelName];
        if (!model) {
            throw new ModelError(`No model found with name ${modelName}`);
        }
        const getDocument = this.stackbitCache.getDocumentById;
        return del({
            model,
            models: connector.ModelBuilder.modelDataAPIs,
            cache: connector.sourcePluginAPI.contentEngineCache,
            options: connector.optionsValues,
            document: args.document,
            state: connector.initState,
            userContext: args.userContext,
            platform: connector.platform,
            getDocument,
        });
    }
    async publishDocuments(args) {
        const connector = this.runningConnector;
        const publish = connector.definedImplementations.get("documents.publish");
        if (!publish) {
            throw new Error("connector.documents({ publish: fn }) is not implemented");
        }
        return publish({
            documents: args.documents,
            options: connector.optionsValues,
            cache: connector.sourcePluginAPI.contentEngineCache,
            state: connector.initState,
            userContext: args.userContext,
            platform: connector.platform,
        });
    }
    async getModels() {
        const { connect, create } = this.runningConnector.getAPIPromises("model");
        const modelBuilder = await connect.promise;
        if (!modelBuilder) {
            return;
        }
        try {
            return modelBuilder.toCreateModels();
        }
        catch (e) {
            create.reject(e);
        }
        finally {
            create.resolve();
        }
    }
    getLocales() {
        return this.runningConnector.ModelBuilder.locales;
    }
    getProjectManageUrl() {
        return this.runningConnector.initState?.projectManageUrl || ``;
    }
    async connectSyncFinished() {
        const { connect } = this.runningConnector.getAPIPromises(`sync`);
        await connect.promise;
        return this.runningConnector;
    }
    async getDocuments() {
        const { connect } = this.runningConnector.getAPIPromises(`sync`);
        await connect.promise;
        return (await this.connectSyncFinished()).restoreAllDocuments();
    }
    async getAssets() {
        const { connect } = this.runningConnector.getAPIPromises(`sync`);
        await connect.promise;
        return (await this.connectSyncFinished()).restoreAllAssets();
    }
}
