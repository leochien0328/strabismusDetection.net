{"version":3,"file":"derived-types.js","names":["_graphqlCompose","require","getDerivedTypes","typeComposer","derivedTypes","getExtension","Set","deleteFieldsOfDerivedTypes","getFieldNames","forEach","fieldName","fieldType","getField","type","has","getTypeName","removeField","exports","removeTypeFromSchemaComposer","schemaComposer","delete","_gqType","clearDerivedTypes","typeName","values","derivedTypeComposer","getAnyTC","ObjectTypeComposer","InterfaceTypeComposer","inputTypeComposer","getInputTypeComposer","removeInputTypeComposer","setExtension","addDerivedType","derivedTypeName","add"],"sources":["../../../src/schema/types/derived-types.ts"],"sourcesContent":["/**\n * Derived types are types that make sense only when their base type exists\n *\n * Take this node for example:\n * {\n *   internal: { type: 'Foo' },\n *   fields: {\n *     bar: \"string\",\n *   }\n * }\n *\n * It will produce following types:\n * Foo\n * FooFields\n *\n * FooInputFilter\n * FooSortInput\n *\n * FooFieldsInputFilter\n * FooFieldsSortFilter\n * etc\n *\n * Derived types:\n *   Foo: FooFields, FooInputFilter, FooSortInput\n *   FooFields: FooFieldsInputFilter, FooFieldsSortFilter\n *\n * Caveats:\n *   Only types created via inference are marked as derived. So if in the example above\n *   user explicitly defines `FooFields` type (via `createTypes` call) it won't be considered\n *   a derived type\n */\nimport {\n  ObjectTypeComposer,\n  InterfaceTypeComposer,\n  ScalarTypeComposer,\n  SchemaComposer,\n  InputTypeComposer,\n  EnumTypeComposer,\n  UnionTypeComposer,\n} from \"graphql-compose\";\n\ntype AllTypeComposer =\n  | ObjectTypeComposer\n  | InputTypeComposer\n  | EnumTypeComposer\n  | InterfaceTypeComposer\n  | UnionTypeComposer\n  | ScalarTypeComposer;\n\nconst getDerivedTypes = ({\n  typeComposer,\n}: {\n  typeComposer: AllTypeComposer;\n}): Set<string> => {\n  const derivedTypes = typeComposer.getExtension(`derivedTypes`);\n  if (derivedTypes) {\n    return derivedTypes as Set<string>;\n  }\n\n  return new Set();\n};\n\nexport const deleteFieldsOfDerivedTypes = ({ typeComposer }): void => {\n  const derivedTypes = getDerivedTypes({ typeComposer });\n\n  typeComposer.getFieldNames().forEach((fieldName) => {\n    const fieldType = typeComposer.getField(fieldName).type;\n\n    if (derivedTypes.has(fieldType.getTypeName())) {\n      typeComposer.removeField(fieldName);\n    }\n  });\n};\n\nconst removeTypeFromSchemaComposer = ({\n  schemaComposer,\n  typeComposer,\n}): void => {\n  schemaComposer.delete(typeComposer.getTypeName());\n  schemaComposer.delete((typeComposer as any)._gqType);\n  schemaComposer.delete(typeComposer);\n};\n\nexport const clearDerivedTypes = ({\n  schemaComposer,\n  typeComposer,\n}: {\n  schemaComposer: SchemaComposer<any>;\n  typeComposer: AllTypeComposer;\n}): void => {\n  const derivedTypes = getDerivedTypes({ typeComposer });\n\n  for (const typeName of derivedTypes.values()) {\n    const derivedTypeComposer = schemaComposer.getAnyTC(typeName);\n    clearDerivedTypes({ schemaComposer, typeComposer: derivedTypeComposer });\n    removeTypeFromSchemaComposer({\n      schemaComposer,\n      typeComposer: derivedTypeComposer,\n    });\n  }\n\n  if (\n    typeComposer instanceof ObjectTypeComposer ||\n    typeComposer instanceof InterfaceTypeComposer\n  ) {\n    const inputTypeComposer = typeComposer.getInputTypeComposer();\n    removeTypeFromSchemaComposer({\n      schemaComposer,\n      typeComposer: inputTypeComposer,\n    });\n    typeComposer.removeInputTypeComposer();\n  }\n\n  typeComposer.setExtension(`derivedTypes`, new Set());\n};\n\nexport const addDerivedType = ({\n  typeComposer,\n  derivedTypeName,\n}: {\n  typeComposer: AllTypeComposer;\n  derivedTypeName: string;\n}): void => {\n  const derivedTypes = getDerivedTypes({ typeComposer });\n  typeComposer.setExtension(`derivedTypes`, derivedTypes.add(derivedTypeName));\n};\n"],"mappings":";;;;AA+BA,IAAAA,eAAA,GAAAC,OAAA;AA/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAmBA,MAAMC,eAAe,GAAGA,CAAC;EACvBC;AAGF,CAAC,KAAkB;EACjB,MAAMC,YAAY,GAAGD,YAAY,CAACE,YAAY,CAAE,cAAa,CAAC;EAC9D,IAAID,YAAY,EAAE;IAChB,OAAOA,YAAY;EACrB;EAEA,OAAO,IAAIE,GAAG,CAAC,CAAC;AAClB,CAAC;AAEM,MAAMC,0BAA0B,GAAGA,CAAC;EAAEJ;AAAa,CAAC,KAAW;EACpE,MAAMC,YAAY,GAAGF,eAAe,CAAC;IAAEC;EAAa,CAAC,CAAC;EAEtDA,YAAY,CAACK,aAAa,CAAC,CAAC,CAACC,OAAO,CAAEC,SAAS,IAAK;IAClD,MAAMC,SAAS,GAAGR,YAAY,CAACS,QAAQ,CAACF,SAAS,CAAC,CAACG,IAAI;IAEvD,IAAIT,YAAY,CAACU,GAAG,CAACH,SAAS,CAACI,WAAW,CAAC,CAAC,CAAC,EAAE;MAC7CZ,YAAY,CAACa,WAAW,CAACN,SAAS,CAAC;IACrC;EACF,CAAC,CAAC;AACJ,CAAC;AAACO,OAAA,CAAAV,0BAAA,GAAAA,0BAAA;AAEF,MAAMW,4BAA4B,GAAGA,CAAC;EACpCC,cAAc;EACdhB;AACF,CAAC,KAAW;EACVgB,cAAc,CAACC,MAAM,CAACjB,YAAY,CAACY,WAAW,CAAC,CAAC,CAAC;EACjDI,cAAc,CAACC,MAAM,CAAEjB,YAAY,CAASkB,OAAO,CAAC;EACpDF,cAAc,CAACC,MAAM,CAACjB,YAAY,CAAC;AACrC,CAAC;AAEM,MAAMmB,iBAAiB,GAAGA,CAAC;EAChCH,cAAc;EACdhB;AAIF,CAAC,KAAW;EACV,MAAMC,YAAY,GAAGF,eAAe,CAAC;IAAEC;EAAa,CAAC,CAAC;EAEtD,KAAK,MAAMoB,QAAQ,IAAInB,YAAY,CAACoB,MAAM,CAAC,CAAC,EAAE;IAC5C,MAAMC,mBAAmB,GAAGN,cAAc,CAACO,QAAQ,CAACH,QAAQ,CAAC;IAC7DD,iBAAiB,CAAC;MAAEH,cAAc;MAAEhB,YAAY,EAAEsB;IAAoB,CAAC,CAAC;IACxEP,4BAA4B,CAAC;MAC3BC,cAAc;MACdhB,YAAY,EAAEsB;IAChB,CAAC,CAAC;EACJ;EAEA,IACEtB,YAAY,YAAYwB,kCAAkB,IAC1CxB,YAAY,YAAYyB,qCAAqB,EAC7C;IACA,MAAMC,iBAAiB,GAAG1B,YAAY,CAAC2B,oBAAoB,CAAC,CAAC;IAC7DZ,4BAA4B,CAAC;MAC3BC,cAAc;MACdhB,YAAY,EAAE0B;IAChB,CAAC,CAAC;IACF1B,YAAY,CAAC4B,uBAAuB,CAAC,CAAC;EACxC;EAEA5B,YAAY,CAAC6B,YAAY,CAAE,cAAa,EAAE,IAAI1B,GAAG,CAAC,CAAC,CAAC;AACtD,CAAC;AAACW,OAAA,CAAAK,iBAAA,GAAAA,iBAAA;AAEK,MAAMW,cAAc,GAAGA,CAAC;EAC7B9B,YAAY;EACZ+B;AAIF,CAAC,KAAW;EACV,MAAM9B,YAAY,GAAGF,eAAe,CAAC;IAAEC;EAAa,CAAC,CAAC;EACtDA,YAAY,CAAC6B,YAAY,CAAE,cAAa,EAAE5B,YAAY,CAAC+B,GAAG,CAACD,eAAe,CAAC,CAAC;AAC9E,CAAC;AAACjB,OAAA,CAAAgB,cAAA,GAAAA,cAAA"}