{"version":3,"file":"inference-metadata.js","names":["_is32BitInteger","require","_date","getType","value","key","is32BitInteger","includes","looksLikeADate","Date","String","Array","isArray","length","Object","keys","updateValueDescriptorObject","typeInfo","nodeId","operation","metadata","path","push","dprops","forEach","v","descriptor","undefined","updateValueDescriptor","pop","updateValueDescriptorArray","item","updateValueDescriptorRelNodes","listOfNodeIds","delta","nodes","dirty","updateValueDescriptorString","empty","example","typeName","total","first","mergeObjectKeys","dpropsKeysA","dpropsKeysB","otherProps","Set","concat","descriptorsAreEqual","otherDescriptor","types","possibleTypes","otherTypes","childDescriptorsAreEqual","type","_descriptor$array","_otherDescriptor$arra","array","_descriptor$object","_otherDescriptor$obje","dpropsKeys","object","every","prop","_descriptor$object2","_otherDescriptor$obje2","_descriptor$relatedNo","_otherDescriptor$rela","nodeIds","relatedNode","id","_descriptor$relatedNo2","_otherDescriptor$rela2","Boolean","_descriptor$relatedNo3","_otherDescriptor$rela3","relatedNodeList","_descriptor$relatedNo4","_otherDescriptor$rela4","_isEqual2","default","nodeFields","node","ignoredFields","filter","has","updateTypeMetadata","initialMetadata","disabled","ignored","fieldMap","field","ignore","set","exports","disable","addNode","deleteNode","addNodes","state","isEmpty","hasNodes","typeMetadata","_typeMetadata$total","haveEqualFields","otherFieldMap","fields"],"sources":["../../../src/schema/infer/inference-metadata.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-use-before-define */\n/*\n## Incrementally track the structure of nodes with metadata\n\nThis metadata can be later utilized for schema inference\n(via building `exampleValue` or directly)\n\n### Usage example:\n\n```javascript\n  const node1 = { id: '1', foo: 25, bar: 'str' }\n  const node2 = { id: '1', foo: 'conflict' }\n\n  let meta = { ignoredFields: new Set(['id']) }\n  meta = addNode(meta, node1)\n  meta = addNode(meta, node2)\n  console.log(meta.fieldMap)\n  // outputs: {\n  //   foo: {\n  //     int: { total: 1, example: 25 },\n  //     string: { total: 1, example: 'conflict' },\n  //   },\n  //   bar: {\n  //     string: { total: 1, example: 'str' },\n  //   },\n  // }\n\n  const example1 = getExampleObject({ meta, typeName, typeConflictReporter })\n  console.log(example1)\n  // outputs { bar: 'str' }\n  // and reports conflicts discovered\n\n  meta = deleteNode(meta, node2)\n  console.log(meta.fieldMap)\n  // outputs: {\n  //   foo: {\n  //     int: { total: 1, example: 25 },\n  //     string: { total: 0, example: 'conflict' },\n  //   },\n  //   bar: { string: { total: 1, example: 'str' } },\n  // }\n\n  const example2 = getExampleObject({ meta, typeName, typeConflictReporter })\n  // outputs: { foo: 25, bar: 'str' }\n```\n\n`addNode`, `deleteNode`, `getExampleObject` are O(N) where N is the number\nof fields in the node object (including nested fields)\n\n### Caveats\n\n* Conflict tracking for arrays is tricky, i.e.: { a: [5, \"foo\"] } and { a: [5] }, { a: [\"foo\"] }\n  are represented identically in metadata. To workaround it we additionally track first NodeId:\n  { a: { array: { item: { int: { total: 1, first: `1` }, string: { total: 1, first: `1` } }}\n  { a: { array: { item: { int: { total: 1, first: `1` }, string: { total: 1, first: `2` } }}\n  This way we can produce more useful conflict reports\n  (still rare edge cases possible when reporting may be confusing, i.e. when node is deleted)\n*/\n\nimport { isEqual } from \"lodash\";\nimport { is32BitInteger } from \"../../utils/is-32-bit-integer\";\nimport { looksLikeADate } from \"../types/date\";\nimport { Node } from \"../../types\";\nimport { TypeConflictReporter } from \"./type-conflict-reporter\";\n\nexport interface ITypeInfo {\n  first?: string;\n  total: number;\n  example?: unknown;\n}\n\nexport interface ITypeInfoString extends ITypeInfo {\n  empty: number;\n  example: string;\n}\n\nexport interface ITypeInfoDate extends ITypeInfo {\n  example: string | Date;\n}\n\nexport interface ITypeInfoNumber extends ITypeInfo {\n  example: number;\n}\n\nexport interface ITypeInfoBoolean extends ITypeInfo {\n  example: boolean;\n}\n\nexport interface ITypeInfoArray extends ITypeInfo {\n  item: IValueDescriptor;\n}\n\nexport interface ITypeInfoRelatedNodes extends ITypeInfo {\n  nodes: { [key: string]: number };\n}\n\nexport interface ITypeInfoObject extends ITypeInfo {\n  dprops: {\n    [name: string]: IValueDescriptor;\n  };\n}\n\nexport interface IValueDescriptor {\n  int?: ITypeInfoNumber;\n  float?: ITypeInfoNumber;\n  date?: ITypeInfoDate;\n  string?: ITypeInfoString;\n  boolean?: ITypeInfoBoolean;\n  array?: ITypeInfoArray;\n  relatedNode?: ITypeInfoRelatedNodes;\n  relatedNodeList?: ITypeInfoRelatedNodes;\n  object?: ITypeInfoObject;\n}\n\nexport type ValueType = keyof IValueDescriptor;\n\nexport interface ITypeMetadata {\n  typeName?: string;\n  disabled?: boolean;\n  ignored?: boolean;\n  dirty?: boolean;\n  total?: number;\n  ignoredFields?: Set<string>;\n  fieldMap?: Record<string, IValueDescriptor>;\n  typeConflictReporter?: TypeConflictReporter;\n  [key: string]: unknown;\n}\n\ntype Operation = \"add\" | \"del\";\n\nconst getType = (value: unknown, key: string): ValueType | \"null\" => {\n  // Staying as close as possible to GraphQL types\n  switch (typeof value) {\n    case `number`:\n      return is32BitInteger(value) ? `int` : `float`;\n    case `string`:\n      if (key.includes(`___NODE`)) {\n        return `relatedNode`;\n      }\n      return looksLikeADate(value) ? `date` : `string`;\n    case `boolean`:\n      return `boolean`;\n    case `object`:\n      if (value === null) return `null`;\n      if (value instanceof Date) return `date`;\n      if (value instanceof String) return `string`;\n      if (Array.isArray(value)) {\n        if (value.length === 0) {\n          return `null`;\n        }\n        return key.includes(`___NODE`) ? `relatedNodeList` : `array`;\n      }\n      if (!Object.keys(value).length) return `null`;\n      return `object`;\n    default:\n      // bigint, symbol, function, unknown (host objects in IE were typeof \"unknown\", for example)\n      return `null`;\n  }\n};\n\nconst updateValueDescriptorObject = (\n  value: Record<string, unknown>,\n  typeInfo: ITypeInfoObject,\n  nodeId: string,\n  operation: Operation,\n  metadata: ITypeMetadata,\n  path: Array<Record<string, unknown>>,\n): void => {\n  path.push(value);\n\n  const { dprops = {} } = typeInfo;\n  typeInfo.dprops = dprops;\n\n  Object.keys(value).forEach((key) => {\n    const v = value[key];\n\n    let descriptor = dprops[key];\n    if (descriptor === undefined) {\n      descriptor = {};\n      dprops[key] = descriptor;\n    }\n\n    updateValueDescriptor(\n      nodeId,\n      key,\n      v,\n      operation,\n      descriptor,\n      metadata,\n      path,\n    );\n  });\n\n  path.pop();\n};\n\nconst updateValueDescriptorArray = (\n  value: Array<unknown>,\n  key: string,\n  typeInfo: ITypeInfoArray,\n  nodeId: string,\n  operation: Operation,\n  metadata: ITypeMetadata,\n  path: Array<Record<string, unknown>>,\n): void => {\n  value.forEach((item) => {\n    let descriptor = typeInfo.item;\n    if (descriptor === undefined) {\n      descriptor = {};\n      typeInfo.item = descriptor;\n    }\n\n    updateValueDescriptor(\n      nodeId,\n      key,\n      item,\n      operation,\n      descriptor,\n      metadata,\n      path,\n    );\n  });\n};\n\nconst updateValueDescriptorRelNodes = (\n  listOfNodeIds: Array<string>,\n  delta: number,\n  operation: Operation,\n  typeInfo: ITypeInfoRelatedNodes,\n  metadata: ITypeMetadata,\n): void => {\n  const { nodes = {} } = typeInfo;\n  typeInfo.nodes = nodes;\n\n  listOfNodeIds.forEach((nodeId) => {\n    nodes[nodeId] = (nodes[nodeId] || 0) + delta;\n\n    // Treat any new related node addition or removal as a structural change\n    // FIXME: this will produce false positives as this node can be\n    //  of the same type as another node already in the map (but we don't know it here)\n    if (nodes[nodeId] === 0 || (operation === `add` && nodes[nodeId] === 1)) {\n      metadata.dirty = true;\n    }\n  });\n};\n\nconst updateValueDescriptorString = (\n  value: string,\n  delta: number,\n  typeInfo: ITypeInfoString,\n): void => {\n  if (value === ``) {\n    const { empty = 0 } = typeInfo;\n    typeInfo.empty = empty + delta;\n  }\n  typeInfo.example =\n    typeof typeInfo.example !== `undefined` ? typeInfo.example : value;\n};\n\nconst updateValueDescriptor = (\n  nodeId: string,\n  key: string,\n  value: unknown,\n  operation: Operation = `add`,\n  descriptor: IValueDescriptor,\n  metadata: ITypeMetadata,\n  path: Array<Record<string, unknown>>,\n): void => {\n  // The object may be traversed multiple times from root.\n  // Each time it does it should not revisit the same node twice\n  if (path.includes(value as Record<string, unknown>)) {\n    return;\n  }\n\n  const typeName = getType(value, key);\n\n  if (typeName === `null`) {\n    return;\n  }\n\n  const delta = operation === `del` ? -1 : 1;\n\n  let typeInfo: ITypeInfo | undefined = descriptor[typeName];\n  if (typeInfo === undefined) {\n    // eslint-disable-next-line no-undef\n    typeInfo = (descriptor[typeName] as ITypeInfo) = { total: 0 };\n  }\n  typeInfo.total += delta;\n\n  // Keeping track of structural changes\n  // (when value of a new type is added or an existing type has no more values assigned)\n  if (typeInfo.total === 0 || (operation === `add` && typeInfo.total === 1)) {\n    metadata.dirty = true;\n  }\n\n  // Keeping track of the first node for this type. Only used for better conflict reporting.\n  // (see Caveats section in the header comments)\n  if (operation === `add`) {\n    if (!typeInfo.first) {\n      typeInfo.first = nodeId;\n    }\n  } else if (operation === `del`) {\n    if (typeInfo.first === nodeId || typeInfo.total === 0) {\n      typeInfo.first = undefined;\n    }\n  }\n\n  switch (typeName) {\n    case `object`:\n      updateValueDescriptorObject(\n        value as Record<string, unknown>,\n        typeInfo as ITypeInfoObject,\n        nodeId,\n        operation,\n        metadata,\n        path,\n      );\n      return;\n    case `array`:\n      updateValueDescriptorArray(\n        value as Array<unknown>,\n        key,\n        typeInfo as ITypeInfoArray,\n        nodeId,\n        operation,\n        metadata,\n        path,\n      );\n      return;\n    case `relatedNode`:\n      updateValueDescriptorRelNodes(\n        [value as string],\n        delta,\n        operation,\n        typeInfo as ITypeInfoRelatedNodes,\n        metadata,\n      );\n      return;\n    case `relatedNodeList`:\n      updateValueDescriptorRelNodes(\n        value as Array<string>,\n        delta,\n        operation,\n        typeInfo as ITypeInfoRelatedNodes,\n        metadata,\n      );\n      return;\n    case `string`:\n      updateValueDescriptorString(\n        value as string,\n        delta,\n        typeInfo as ITypeInfoString,\n      );\n      return;\n  }\n\n  // int, float, boolean, null\n\n  typeInfo.example =\n    typeof typeInfo.example !== `undefined` ? typeInfo.example : value;\n};\n\nconst mergeObjectKeys = (\n  dpropsKeysA: Record<string, unknown> = {},\n  dpropsKeysB: Record<string, unknown> = {},\n): Array<string> => {\n  const dprops = Object.keys(dpropsKeysA);\n  const otherProps = Object.keys(dpropsKeysB);\n  return [...new Set(dprops.concat(otherProps))];\n};\n\nconst descriptorsAreEqual = (\n  descriptor?: IValueDescriptor,\n  otherDescriptor?: IValueDescriptor,\n): boolean => {\n  const types = possibleTypes(descriptor);\n  const otherTypes = possibleTypes(otherDescriptor);\n\n  const childDescriptorsAreEqual = (type: string): boolean => {\n    switch (type) {\n      case `array`:\n        return descriptorsAreEqual(\n          descriptor?.array?.item,\n          otherDescriptor?.array?.item,\n        );\n      case `object`: {\n        const dpropsKeys = mergeObjectKeys(\n          descriptor?.object?.dprops,\n          otherDescriptor?.object?.dprops,\n        );\n        return dpropsKeys.every((prop) =>\n          descriptorsAreEqual(\n            descriptor?.object?.dprops[prop],\n            otherDescriptor?.object?.dprops[prop],\n          ),\n        );\n      }\n      case `relatedNode`: {\n        const nodeIds = mergeObjectKeys(\n          descriptor?.relatedNode?.nodes,\n          otherDescriptor?.relatedNode?.nodes,\n        );\n        // Must be present in both descriptors or absent in both\n        // in order to be considered equal\n        return nodeIds.every(\n          (id) =>\n            Boolean(descriptor?.relatedNode?.nodes[id]) ===\n            Boolean(otherDescriptor?.relatedNode?.nodes[id]),\n        );\n      }\n      case `relatedNodeList`: {\n        const nodeIds = mergeObjectKeys(\n          descriptor?.relatedNodeList?.nodes,\n          otherDescriptor?.relatedNodeList?.nodes,\n        );\n        return nodeIds.every(\n          (id) =>\n            Boolean(descriptor?.relatedNodeList?.nodes[id]) ===\n            Boolean(otherDescriptor?.relatedNodeList?.nodes[id]),\n        );\n      }\n      default:\n        return true;\n    }\n  };\n\n  // Equal when all possible types are equal (including conflicts)\n  return isEqual(types, otherTypes) && types.every(childDescriptorsAreEqual);\n};\n\nconst nodeFields = (node: Node, ignoredFields = new Set()): Array<string> =>\n  Object.keys(node).filter((key) => !ignoredFields.has(key));\n\nconst updateTypeMetadata = (\n  metadata = initialMetadata(),\n  operation: Operation,\n  node: Node,\n): ITypeMetadata => {\n  if (metadata.disabled) {\n    return metadata;\n  }\n  metadata.total = (metadata.total || 0) + (operation === `add` ? 1 : -1);\n  if (metadata.ignored) {\n    return metadata;\n  }\n  const { ignoredFields, fieldMap = {} } = metadata;\n\n  nodeFields(node, ignoredFields).forEach((field) => {\n    let descriptor = fieldMap[field];\n    if (descriptor === undefined) {\n      descriptor = {};\n      fieldMap[field] = descriptor;\n    }\n\n    updateValueDescriptor(\n      node.id,\n      field,\n      node[field],\n      operation,\n      descriptor,\n      metadata,\n      [],\n    );\n  });\n  metadata.fieldMap = fieldMap;\n  return metadata;\n};\n\nconst ignore = (metadata = initialMetadata(), set = true): ITypeMetadata => {\n  metadata.ignored = set;\n  metadata.fieldMap = {};\n  return metadata;\n};\n\nconst disable = (metadata = initialMetadata(), set = true): ITypeMetadata => {\n  metadata.disabled = set;\n  return metadata;\n};\n\nconst addNode = (metadata: ITypeMetadata, node: Node): ITypeMetadata =>\n  updateTypeMetadata(metadata, `add`, node);\n\nconst deleteNode = (metadata: ITypeMetadata, node: Node): ITypeMetadata =>\n  updateTypeMetadata(metadata, `del`, node);\n\nconst addNodes = (\n  metadata = initialMetadata(),\n  nodes: Iterable<Node>,\n): ITypeMetadata => {\n  let state = metadata;\n  for (const node of nodes) {\n    state = addNode(state, node);\n  }\n  return state;\n};\n\nconst possibleTypes = (descriptor: IValueDescriptor = {}): Array<ValueType> =>\n  Object.keys(descriptor).filter(\n    (type) => descriptor[type].total > 0,\n  ) as Array<ValueType>;\n\nconst isEmpty = ({ fieldMap }): boolean =>\n  Object.keys(fieldMap).every(\n    (field) => possibleTypes(fieldMap[field]).length === 0,\n  );\n\n// Even empty type may still have nodes\nconst hasNodes = (typeMetadata: ITypeMetadata): boolean =>\n  (typeMetadata.total ?? 0) > 0;\n\nconst haveEqualFields = (\n  { fieldMap = {} } = {},\n  { fieldMap: otherFieldMap = {} } = {},\n): boolean => {\n  const fields = mergeObjectKeys(fieldMap, otherFieldMap);\n  return fields.every((field) =>\n    descriptorsAreEqual(fieldMap[field], otherFieldMap[field]),\n  );\n};\n\nconst initialMetadata = (state?: Record<string, unknown>): ITypeMetadata => {\n  return {\n    typeName: undefined,\n    disabled: false,\n    ignored: false,\n    dirty: false,\n    total: 0,\n    ignoredFields: undefined,\n    fieldMap: {},\n    ...state,\n  };\n};\n\nexport {\n  addNode,\n  addNodes,\n  deleteNode,\n  ignore,\n  disable,\n  isEmpty,\n  hasNodes,\n  haveEqualFields,\n  initialMetadata,\n};\n"],"mappings":"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"}