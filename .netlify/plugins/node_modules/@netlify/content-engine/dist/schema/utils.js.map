{"version":3,"file":"utils.js","names":["_graphql","require","_graphqlCompose","_isPlainObject","_interopRequireDefault","_redux","toTypeNames","schema","gqlTypeName","gqlType","getType","isObjectType","isAbstractType","possibleTypes","getPossibleTypes","map","type","name","exports","toNodeTypeNames","filter","getInterfaces","some","iface","isObjectOrInterfaceTypeComposer","ObjectTypeComposer","InterfaceTypeComposer","fieldNeedToResolve","typeComposer","schemaComposer","fieldName","nodeTypeNames","possibleTCs","getAnyTC","tc","getFieldExtension","fieldPathNeedToResolve","selector","schemaCustomization","composer","store","getState","Error","selectors","split","isInterfaceType","i","length","nextType","getNamedType","getFields","getResolvedFields","node","typeName","internal","resolvedNodes","resolvedNodesCache","get","id","pathObjectToPathString","input","path","currentValue","leaf","undefined","isPlainObject","entries","Object","key","value","push","join","maybeConvertSortInputObjectToSortPath","args","_args$sort","_args$sort2","sort","Array","isArray","fields","order","every","item","toLowerCase","sorts","modifiedSort"],"sources":["../../src/schema/utils.ts"],"sourcesContent":["import {\n  isAbstractType,\n  getNamedType,\n  GraphQLSchema,\n  isObjectType,\n  isInterfaceType,\n  GraphQLObjectType,\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n} from \"graphql\";\nimport {\n  InterfaceTypeComposer,\n  NamedTypeComposer,\n  ObjectTypeComposer,\n  SchemaComposer,\n} from \"graphql-compose\";\nimport isPlainObject from \"lodash/isPlainObject\";\n\nimport type { IGatsbyNodePartial } from \"../datastore/in-memory/indexing\";\nimport { IGatsbyNode } from \"../internal\";\nimport { store } from \"../redux\";\n\nexport const toTypeNames = (\n  schema: GraphQLSchema,\n  gqlTypeName:\n    | string\n    | GraphQLObjectType\n    | GraphQLInterfaceType\n    | GraphQLUnionType,\n): Array<string> => {\n  const gqlType =\n    typeof gqlTypeName === `string` ? schema.getType(gqlTypeName) : gqlTypeName;\n\n  if (!gqlType || !(isObjectType(gqlType) || isAbstractType(gqlType))) {\n    return [];\n  }\n\n  const possibleTypes = isAbstractType(gqlType)\n    ? schema.getPossibleTypes(gqlType)\n    : [gqlType];\n\n  return possibleTypes.map((type) => type.name);\n};\n\nexport const toNodeTypeNames = (\n  schema: GraphQLSchema,\n  gqlTypeName:\n    | string\n    | GraphQLObjectType\n    | GraphQLInterfaceType\n    | GraphQLUnionType,\n): Array<string> => {\n  const gqlType =\n    typeof gqlTypeName === `string` ? schema.getType(gqlTypeName) : gqlTypeName;\n\n  if (!gqlType || !(isObjectType(gqlType) || isAbstractType(gqlType))) {\n    return [];\n  }\n\n  const possibleTypes = isAbstractType(gqlType)\n    ? schema.getPossibleTypes(gqlType)\n    : [gqlType];\n\n  return possibleTypes\n    .filter((type) =>\n      type.getInterfaces().some((iface) => iface.name === `Node`),\n    )\n    .map((type) => type.name);\n};\n\nexport function isObjectOrInterfaceTypeComposer(\n  type: NamedTypeComposer<any>,\n): type is ObjectTypeComposer | InterfaceTypeComposer {\n  return (\n    type instanceof ObjectTypeComposer || type instanceof InterfaceTypeComposer\n  );\n}\n\nexport const fieldNeedToResolve = ({\n  schema,\n  gqlType,\n  typeComposer,\n  schemaComposer,\n  fieldName,\n}: {\n  schema: GraphQLSchema;\n  gqlType: GraphQLObjectType | GraphQLInterfaceType;\n  typeComposer: ObjectTypeComposer<any> | InterfaceTypeComposer<any>;\n  schemaComposer: SchemaComposer<any>;\n  fieldName: string;\n}): boolean => {\n  const nodeTypeNames = toNodeTypeNames(schema, gqlType);\n\n  const possibleTCs: Array<ObjectTypeComposer | InterfaceTypeComposer> = [\n    typeComposer,\n    ...nodeTypeNames\n      .map((name) => schemaComposer.getAnyTC(name))\n      .filter(isObjectOrInterfaceTypeComposer),\n  ];\n\n  for (const tc of possibleTCs) {\n    if (tc.getFieldExtension(fieldName, `needsResolve`) || false) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nexport const fieldPathNeedToResolve = ({\n  selector,\n  type,\n}: {\n  selector: string;\n  type: string | GraphQLObjectType | GraphQLInterfaceType;\n}): boolean => {\n  const {\n    schema,\n    schemaCustomization: { composer: schemaComposer },\n  } = store.getState();\n\n  if (!schemaComposer) {\n    throw new Error(`Schema composer isn't set yet`);\n  }\n\n  const selectors =\n    typeof selector === `string` ? selector.split(`.`) : selector;\n\n  let gqlType = typeof type === `string` ? schema.getType(type) : type;\n\n  if (!gqlType || !(isObjectType(gqlType) || isInterfaceType(gqlType))) {\n    return false;\n  }\n\n  for (let i = 0; i < selectors.length; i++) {\n    const fieldName = selectors[i];\n    const typeComposer = schemaComposer.getAnyTC(gqlType.name);\n\n    if (!isObjectOrInterfaceTypeComposer(typeComposer)) {\n      return false;\n    }\n\n    if (\n      fieldNeedToResolve({\n        schema,\n        gqlType,\n        typeComposer,\n        schemaComposer,\n        fieldName,\n      })\n    ) {\n      return true;\n    }\n\n    const nextType = getNamedType(gqlType.getFields()[fieldName].type);\n    if (!nextType || !(isObjectType(nextType) || isInterfaceType(nextType))) {\n      return false;\n    } else {\n      gqlType = nextType;\n    }\n  }\n\n  return false;\n};\n\nexport function getResolvedFields(\n  node: IGatsbyNode | IGatsbyNodePartial,\n): undefined | Record<string, any> {\n  const typeName = node.internal.type;\n  const resolvedNodes = store.getState().resolvedNodesCache.get(typeName);\n  return resolvedNodes?.get(node.id);\n}\n\ntype NestedPathStructure = INestedPathStructureNode | true | \"ASC\" | \"DESC\";\n\nexport interface INestedPathStructureNode {\n  [key: string]: NestedPathStructure;\n}\n\nexport function pathObjectToPathString(input: INestedPathStructureNode): {\n  path: string;\n  leaf: any;\n} {\n  const path: Array<string> = [];\n  let currentValue: NestedPathStructure | undefined = input;\n  let leaf: any = undefined;\n  while (currentValue) {\n    if (isPlainObject(currentValue)) {\n      const entries = Object.entries(currentValue);\n      if (entries.length !== 1) {\n        throw new Error(`Invalid field arg`);\n      }\n      for (const [key, value] of entries) {\n        path.push(key);\n        currentValue = value;\n      }\n    } else {\n      leaf = currentValue;\n      currentValue = undefined;\n    }\n  }\n\n  return {\n    path: path.join(`.`),\n    leaf,\n  };\n}\n\nexport function maybeConvertSortInputObjectToSortPath(args: any): any {\n  if (!args.sort) {\n    return args;\n  }\n\n  // check if it's already in expected format\n  if (\n    Array.isArray(args.sort?.fields) &&\n    Array.isArray(args.sort?.order) &&\n    args.sort.order.every(\n      (item) =>\n        typeof item === `string` &&\n        (item.toLowerCase() === `asc` || item.toLowerCase() === `desc`),\n    )\n  ) {\n    return args;\n  }\n\n  let sorts = args.sort;\n\n  if (!Array.isArray(sorts)) {\n    sorts = [sorts];\n  }\n\n  const modifiedSort: any = {\n    fields: [],\n    order: [],\n  };\n\n  for (const sort of sorts) {\n    const { path, leaf } = pathObjectToPathString(sort);\n    modifiedSort.fields.push(path);\n    modifiedSort.order.push(leaf);\n  }\n\n  return {\n    ...args,\n    sort: modifiedSort,\n  };\n\n  return args;\n}\n"],"mappings":"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"}