{"version":3,"file":"create-index.js","names":["_util","require","_redux","_common","undefinedSymbol","exports","Symbol","for","createIndex","context","typeName","indexFields","indexName","buildIndexName","meta","getIndexMetadata","state","indexReady","lockIndex","err","doCreateIndex","assertReady","databases","metadata","get","toMetadataKey","_meta$state","Error","datastore","indexes","label","console","time","resolvedNodes","store","getState","resolvedNodesCache","stats","maxKeysPerItem","keyCount","itemCount","indexMetadata","keyFields","multiKeyFields","keyPrefix","i","node","iterateNodesByType","resolvedFields","id","keys","prepareIndexKeys","length","Math","max","push","indexKey","put","Promise","resolve","setTimeout","Set","timeEnd","e","error","String","indexKeyElements","dottedField","fieldValue","resolveFieldValue","indexFieldValue","jsValueToLmdbKey","path","internal","type","inspect","Array","isArray","flat","counter","cartesianProduct","justLocked","ifNoExists","reject","retries","timeout","poll","min","fields","tokens","field","sortDirection","join","value","result","item","lmdbKey","undefined","JSON","stringify"],"sources":["../../../../src/datastore/lmdb/query/create-index.ts"],"sourcesContent":["import { inspect } from \"util\";\nimport { store } from \"../../../redux\";\nimport { IGatsbyNode } from \"../../../redux/types\";\nimport { IDataStore, ILmdbDatabases } from \"../../types\";\nimport { cartesianProduct, resolveFieldValue } from \"./common\";\n\ninterface IIndexingContext {\n  databases: ILmdbDatabases;\n  datastore: IDataStore;\n}\n\nexport type IndexFields = Map<string, number>; // name, direction\n\nexport interface IIndexMetadata {\n  state: \"ready\" | \"building\" | \"stale\" | \"error\" | \"initial\";\n  error?: string;\n  typeName: string;\n  keyPrefix: number | string;\n  keyFields: Array<[fieldName: string, orderDirection: number]>;\n  multiKeyFields: Array<string>;\n\n  // Stats for multi-key indexes\n  // (e.g. when node is { id: `id`, foo: [1,2] } it translates into two index keys: [1,`id`], [2,`id`])\n  stats: {\n    keyCount: number;\n    itemCount: number;\n    maxKeysPerItem: number;\n  };\n}\n\nexport const undefinedSymbol = Symbol.for(`undef`);\n\nexport type IndexFieldValue =\n  | number\n  | string\n  | boolean\n  | null\n  | typeof undefinedSymbol\n  | Array<IndexFieldValue>;\n\nexport type IndexKey = Array<IndexFieldValue>;\n\nexport async function createIndex(\n  context: IIndexingContext,\n  typeName: string,\n  indexFields: IndexFields,\n): Promise<IIndexMetadata> {\n  const indexName = buildIndexName(typeName, indexFields);\n  const meta = getIndexMetadata(context, typeName, indexFields, false);\n\n  switch (meta?.state) {\n    case `ready`:\n      return meta;\n    case `building`: {\n      return indexReady(context, indexName);\n    }\n    case `initial`:\n    default: {\n      try {\n        await lockIndex(context, indexName);\n      } catch (err) {\n        // Index is being updated in some other process.\n        // Wait and assume it's in a good state when done\n        return indexReady(context, indexName);\n      }\n      return doCreateIndex(context, typeName, indexFields);\n    }\n  }\n}\n\nexport function getIndexMetadata(\n  context: IIndexingContext,\n  typeName: string,\n  indexFields: IndexFields,\n  assertReady = true,\n): IIndexMetadata {\n  const { databases } = context;\n  const indexName = buildIndexName(typeName, indexFields);\n  const meta: IIndexMetadata = databases.metadata.get(toMetadataKey(indexName));\n\n  if (assertReady && meta?.state !== `ready`) {\n    throw new Error(\n      `Index ${indexName} is not ready yet. State: ${meta?.state ?? `unknown`}`,\n    );\n  }\n  return meta;\n}\n\nasync function doCreateIndex(\n  context: IIndexingContext,\n  typeName: string,\n  indexFields: IndexFields,\n): Promise<IIndexMetadata> {\n  const { datastore, databases } = context;\n  const { indexes, metadata } = databases;\n  const indexName = buildIndexName(typeName, indexFields);\n\n  const label = `Indexing ${indexName}`;\n  console.time(label);\n\n  // Assuming materialization was run before creating index\n  const resolvedNodes = store.getState().resolvedNodesCache.get(typeName);\n\n  // TODO: iterate only over dirty nodes\n  // TODO: wrap in async transaction?\n  const stats: IIndexMetadata[\"stats\"] = {\n    maxKeysPerItem: 0,\n    keyCount: 0,\n    itemCount: 0,\n  };\n  const indexMetadata: IIndexMetadata = {\n    state: `building`,\n    typeName,\n    keyFields: [...indexFields],\n    multiKeyFields: [],\n    keyPrefix: indexName, // FIXME\n    stats,\n  };\n\n  try {\n    let i = 0;\n    for (const node of datastore.iterateNodesByType(typeName)) {\n      // Assuming materialization was run (executing custom resolvers for fields in `filter` and `sort` clauses)\n      //  And materialized values of those fields are stored in resolvedNodes\n      const resolvedFields = resolvedNodes?.get(node.id);\n      const { keys, multiKeyFields } = prepareIndexKeys(\n        node,\n        resolvedFields,\n        indexName,\n        indexFields,\n      );\n      stats.keyCount += keys.length;\n      stats.itemCount++;\n      stats.maxKeysPerItem = Math.max(stats.maxKeysPerItem, keys.length);\n      indexMetadata.multiKeyFields.push(...multiKeyFields);\n\n      for (const indexKey of keys) {\n        // Note: this may throw if indexKey exceeds 1978 chars (lmdb limit) or contain objects/buffers/etc\n        indexes.put(indexKey, node.id);\n      }\n      if (++i % 5000 === 0) {\n        // Do not block event loop too much\n        await new Promise((resolve) => setTimeout(resolve, 3));\n      }\n    }\n    indexMetadata.state = `ready`;\n    indexMetadata.multiKeyFields = [...new Set(indexMetadata.multiKeyFields)];\n\n    await metadata.put(toMetadataKey(indexName), indexMetadata);\n    console.timeEnd(label);\n\n    return indexMetadata;\n  } catch (e) {\n    indexMetadata.state = `error`;\n    indexMetadata.error = String(e);\n    await metadata.put(toMetadataKey(indexName), indexMetadata);\n    throw e;\n  }\n}\n\n/**\n * Returns a list of index keys for a given node.\n * One node may produce multiple index entries when indexing over array values.\n *\n * For example:\n *  Node: { foo: [{ bar: `bar1`}, { bar: `bar2` }] }\n *  Index fields: [`foo.bar`] will produce the following elements: [`bar1`, `bar2`]\n *\n * Keys are prefixed with index name and suffixed with node counter for stable sort.\n *\n * If materialization result (resolvedFields) exists for a given index field\n *  it is used as a key element, otherwise the a raw node value is used.\n */\nfunction prepareIndexKeys(\n  node: IGatsbyNode,\n  resolvedFields: { [field: string]: unknown } | undefined,\n  indexName: string,\n  indexFields: IndexFields,\n): { keys: Array<IndexKey>; multiKeyFields: Array<string> } {\n  // TODO: use index id vs index name (shorter)\n  const indexKeyElements: Array<Array<IndexFieldValue>> = [];\n  const multiKeyFields: Array<string> = [];\n\n  indexKeyElements.push([indexName]);\n  for (const dottedField of indexFields.keys()) {\n    const fieldValue = resolveFieldValue(dottedField, node, resolvedFields);\n    let indexFieldValue = jsValueToLmdbKey(fieldValue);\n\n    // Got value that can't be stored in lmdb key\n    if (typeof indexFieldValue === `undefined`) {\n      const path = `${node.internal.type}.${dottedField} (id: ${node.id})`;\n      throw new Error(`Bad value at ${path}: ${inspect(fieldValue)}`);\n    }\n    indexFieldValue = Array.isArray(indexFieldValue)\n      ? indexFieldValue.flat() // FIXME\n      : [indexFieldValue];\n\n    indexKeyElements.push(indexFieldValue);\n\n    if (indexFieldValue.length > 1) {\n      multiKeyFields.push(dottedField);\n    }\n  }\n  indexKeyElements.push([node.internal.counter]);\n\n  return { keys: cartesianProduct(...indexKeyElements), multiKeyFields };\n}\n\nasync function lockIndex(\n  context: IIndexingContext,\n  indexName: string,\n): Promise<void> {\n  const { metadata } = context.databases;\n  const indexKey = toMetadataKey(indexName);\n\n  const justLocked = await metadata.ifNoExists(indexKey, () => {\n    metadata.put(indexKey, null);\n  });\n  if (!justLocked) {\n    throw new Error(`Index is already locked`);\n  }\n}\n\nasync function indexReady(\n  context: IIndexingContext,\n  indexName: string,\n): Promise<IIndexMetadata> {\n  return new Promise((resolve, reject) => {\n    const { metadata } = context.databases;\n\n    let retries = 0;\n    let timeout = 16;\n    function poll(): void {\n      const indexMetadata = metadata.get(toMetadataKey(indexName));\n      if (indexMetadata?.state === `ready`) {\n        resolve(indexMetadata);\n        return;\n      }\n      if (retries++ > 1000) {\n        reject(new Error(`Index ${indexName} is locked for too long`));\n        return;\n      }\n      setTimeout(poll, timeout);\n      timeout = Math.min(200, timeout * 1.5);\n    }\n    poll();\n  });\n}\n\n/**\n * Autogenerate index name based on parameters.\n *\n * Example:\n *\n * buildIndexName(`Foo`, { foo: 1, bar: -1 }) -> `Foo/foo:1/bar:-1\n */\nfunction buildIndexName(typeName: string, fields: IndexFields): string {\n  const tokens: Array<string> = [typeName];\n\n  for (const [field, sortDirection] of fields) {\n    tokens.push(`${field}:${sortDirection}`);\n  }\n\n  return tokens.join(`/`);\n}\n\nfunction toMetadataKey(indexName: string): string {\n  return `index:${indexName}`;\n}\n\nfunction jsValueToLmdbKey(value: unknown): IndexFieldValue | undefined {\n  if (\n    typeof value === `number` ||\n    typeof value === `string` ||\n    typeof value === `boolean` ||\n    value === null\n  ) {\n    return value;\n  }\n  if (typeof value === `undefined`) {\n    // Array keys containing `undefined` are not supported by lmdb-store\n    //  But we can't exclude those nodes from an index because\n    //  filters { eq: null, gte: null, lte: null } are expected to return such nodes\n    // Furthermore, lmdb-store puts those keys before others and we want them to be below\n    //  so need to add additional padding\n    return undefinedSymbol;\n  }\n  if (Array.isArray(value)) {\n    const result: Array<IndexFieldValue> = [];\n    for (const item of value) {\n      const lmdbKey = jsValueToLmdbKey(item);\n      if (typeof lmdbKey === `undefined`) {\n        return undefined; // bad value\n      }\n      result.push(lmdbKey);\n    }\n    return result;\n  }\n  // FIXME: not sure if we want this but there are tests for this :/\n  if (typeof value === `object`) {\n    return JSON.stringify(value);\n  }\n  return undefined;\n}\n"],"mappings":"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"}