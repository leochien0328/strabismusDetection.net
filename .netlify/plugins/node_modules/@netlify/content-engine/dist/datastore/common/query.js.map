{"version":3,"file":"query.js","names":["_prepareRegex","require","_micromatch","DbComparator","exports","DB_COMPARATOR_VALUES","Set","Object","values","isDbComparator","value","has","createDbQueriesFromObject","filter","createDbQueriesFromObjectNested","path","keys","getOwnPropertyNames","_flatMap2","default","key","queries","map","query","type","nestedQuery","comparator","concat","dbQueryToDottedField","currentQuery","push","join","getFilterStatement","dbQuery","prefixResolvedFields","resolvedFields","dottedFields","objectToDottedField","dottedFieldKeys","forEach","prefixPath","some","dottedKey","startsWith","unshift","prepareQueryArgs","filterFields","filters","_isPlainObject2","Error","prepareRegex","makeRe","obj","result","pathResult","comparatorSpecificity","EQ","IN","GTE","LTE","GT","LT","NIN","NE","sortBySpecificity","all","sort","compareBySpecificityDesc","a","b","aComparator","bComparator","aSpecificity","bSpecificity"],"sources":["../../../src/datastore/common/query.ts"],"sourcesContent":["import * as _ from \"lodash\";\nimport { prepareRegex } from \"../../utils/prepare-regex\";\nimport { makeRe } from \"micromatch\";\n\nexport interface IDbQueryQuery {\n  type: \"query\";\n  path: Array<string>;\n  query: IDbFilterStatement;\n}\n\nexport interface IDbQueryElemMatch {\n  type: \"elemMatch\";\n  path: Array<string>;\n  nestedQuery: DbQuery;\n}\n\nexport type DbQuery = IDbQueryQuery | IDbQueryElemMatch;\n\nexport enum DbComparator {\n  EQ = `$eq`,\n  NE = `$ne`,\n  GT = `$gt`,\n  GTE = `$gte`,\n  LT = `$lt`,\n  LTE = `$lte`,\n  IN = `$in`,\n  NIN = `$nin`,\n  REGEX = `$regex`,\n  GLOB = `$glob`,\n}\n\n// TODO: merge with DbComparatorValue\nexport type FilterValueNullable =\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n  | RegExp // Only valid for $regex\n  | Array<string | number | boolean | null | undefined>;\n\n// This is filter value in most cases\nexport type FilterValue =\n  | string\n  | number\n  | boolean\n  | RegExp // Only valid for $regex\n  | Array<string | number | boolean>;\n\n// The value is an object with arbitrary keys that are either filter values or,\n// recursively, an object with the same struct. Ie. `{a: {a: {a: 2}}}`\nexport interface IInputQuery {\n  [key: string]: FilterValueNullable | IInputQuery;\n}\n// Similar to IInputQuery except the comparator leaf nodes will have their\n// key prefixed with `$` and their value, in some cases, normalized.\nexport interface IPreparedQueryArg {\n  [key: string]: FilterValueNullable | IPreparedQueryArg;\n}\n\nconst DB_COMPARATOR_VALUES: Set<string> = new Set(Object.values(DbComparator));\n\nfunction isDbComparator(value: string): value is DbComparator {\n  return DB_COMPARATOR_VALUES.has(value);\n}\n\nexport type DbComparatorValue = string | number | boolean | RegExp | null;\n\nexport interface IDbFilterStatement {\n  comparator: DbComparator;\n  value: DbComparatorValue | Array<DbComparatorValue>;\n}\n\n/**\n * Converts a nested mongo args object into array of DbQuery objects,\n * structured representation of each distinct path of the query. We convert\n * nested objects with multiple keys to separate instances.\n */\nexport function createDbQueriesFromObject(\n  filter: Record<string, any>,\n): Array<DbQuery> {\n  return createDbQueriesFromObjectNested(filter);\n}\n\nfunction createDbQueriesFromObjectNested(\n  filter: Record<string, any>,\n  path: Array<string> = [],\n): Array<DbQuery> {\n  const keys = Object.getOwnPropertyNames(filter);\n  return _.flatMap(keys, (key: string): Array<DbQuery> => {\n    if (key === `$elemMatch`) {\n      const queries = createDbQueriesFromObjectNested(filter[key]);\n      return queries.map((query) => {\n        return {\n          type: `elemMatch`,\n          path: path,\n          nestedQuery: query,\n        };\n      });\n    } else if (isDbComparator(key)) {\n      return [\n        {\n          type: `query`,\n          path,\n          query: {\n            comparator: key,\n            value: filter[key],\n          },\n        },\n      ];\n    } else {\n      return createDbQueriesFromObjectNested(filter[key], path.concat([key]));\n    }\n  });\n}\n\n/**\n * Takes a DbQuery structure and returns a dotted representation of a field referenced in this query.\n *\n * Example:\n * ```js\n *   const query = createDbQueriesFromObject({\n *     foo: { $elemMatch: { id: { $eq: 5 }, test: { $gt: 42 } } },\n *     bar: { $in: [`bar`] }\n *   })\n *   const result = query.map(dbQueryToDottedField)\n * ```\n * Returns:\n *   [`foo.id`, `foo.test`, `bar`]\n */\nexport function dbQueryToDottedField(query: DbQuery): string {\n  const path: Array<string> = [...query.path];\n  let currentQuery = query;\n  while (currentQuery.type === `elemMatch`) {\n    currentQuery = currentQuery.nestedQuery;\n    path.push(...currentQuery.path);\n  }\n  return path.join(`.`);\n}\n\nexport function getFilterStatement(dbQuery: DbQuery): IDbFilterStatement {\n  let currentQuery = dbQuery;\n  while (currentQuery.type !== `query`) {\n    currentQuery = currentQuery.nestedQuery;\n  }\n  return currentQuery.query;\n}\n\nexport function prefixResolvedFields(\n  queries: Array<DbQuery>,\n  resolvedFields: Record<string, unknown>,\n): Array<DbQuery> {\n  const dottedFields = objectToDottedField(resolvedFields);\n  const dottedFieldKeys = Object.getOwnPropertyNames(dottedFields);\n  queries.forEach((query) => {\n    const prefixPath = query.path.join(`.`);\n    if (\n      dottedFields[prefixPath] ||\n      (dottedFieldKeys.some((dottedKey) => dottedKey.startsWith(prefixPath)) &&\n        query.type === `elemMatch`) ||\n      dottedFieldKeys.some((dottedKey) => prefixPath.startsWith(dottedKey))\n    ) {\n      query.path.unshift(`__gatsby_resolved`);\n    }\n  });\n  return queries;\n}\n\n/**\n * Transforms filters coming from input GraphQL query to mongodb-compatible format\n * (by prefixing comparators with \"$\").\n *\n * Example:\n *   { foo: { eq: 5 } } -> { foo: { $eq: 5 }}\n */\nexport function prepareQueryArgs(\n  filterFields: Array<IInputQuery> | IInputQuery = {},\n): IPreparedQueryArg {\n  const filters = {};\n  Object.keys(filterFields).forEach((key) => {\n    const value = filterFields[key];\n    if (_.isPlainObject(value)) {\n      filters[key === `elemMatch` ? `$elemMatch` : key] = prepareQueryArgs(\n        value as IInputQuery,\n      );\n    } else {\n      switch (key) {\n        case `regex`:\n          if (typeof value !== `string`) {\n            throw new Error(\n              `The $regex comparator is expecting the regex as a string, not an actual regex or anything else`,\n            );\n          }\n          filters[`$regex`] = prepareRegex(value);\n          break;\n        case `glob`:\n          filters[`$regex`] = makeRe(value);\n          break;\n        default:\n          filters[`$${key}`] = value;\n      }\n    }\n  });\n  return filters;\n}\n\n// Converts a nested mongo args object into a dotted notation. acc\n// (accumulator) must be a reference to an empty object. The converted\n// fields will be added to it. E.g\n//\n// {\n//   internal: {\n//     type: {\n//       $eq: \"TestNode\"\n//     },\n//     content: {\n//       $regex: new MiniMatch(v)\n//     }\n//   },\n//   id: {\n//     $regex: newMiniMatch(v)\n//   }\n// }\n//\n// After execution, acc would be:\n//\n// {\n//   \"internal.type\": {\n//     $eq: \"TestNode\"\n//   },\n//   \"internal.content\": {\n//     $regex: new MiniMatch(v)\n//   },\n//   \"id\": {\n//     $regex: // as above\n//   }\n// }\n\n// Like above, but doesn't handle $elemMatch\nexport function objectToDottedField(\n  obj: Record<string, unknown>,\n  path: Array<string> = [],\n): Record<string, unknown> {\n  let result = {};\n  Object.keys(obj).forEach((key) => {\n    const value = obj[key];\n    if (_.isPlainObject(value)) {\n      const pathResult = objectToDottedField(\n        value as Record<string, unknown>,\n        path.concat(key),\n      );\n      result = {\n        ...result,\n        ...pathResult,\n      };\n    } else {\n      result[path.concat(key).join(`.`)] = value;\n    }\n  });\n  return result;\n}\n\nconst comparatorSpecificity = {\n  [DbComparator.EQ]: 80,\n  [DbComparator.IN]: 70,\n  [DbComparator.GTE]: 60,\n  [DbComparator.LTE]: 50,\n  [DbComparator.GT]: 40,\n  [DbComparator.LT]: 30,\n  [DbComparator.NIN]: 20,\n  [DbComparator.NE]: 10,\n};\n\nexport function sortBySpecificity(all: Array<DbQuery>): Array<DbQuery> {\n  return [...all].sort(compareBySpecificityDesc);\n}\n\nfunction compareBySpecificityDesc(a: DbQuery, b: DbQuery): number {\n  const aComparator = getFilterStatement(a).comparator;\n  const bComparator = getFilterStatement(b).comparator;\n  if (aComparator === bComparator) {\n    return 0;\n  }\n  const aSpecificity = comparatorSpecificity[aComparator];\n  const bSpecificity = comparatorSpecificity[bComparator];\n  if (!aSpecificity || !bSpecificity) {\n    throw new Error(\n      `Unexpected comparator pair: ${aComparator}, ${bComparator}`,\n    );\n  }\n  return aSpecificity > bSpecificity ? -1 : 1;\n}\n"],"mappings":"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"}