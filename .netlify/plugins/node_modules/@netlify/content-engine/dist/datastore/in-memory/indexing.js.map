{"version":3,"file":"indexing.js","names":["_query","require","_2","_getValueAt","_utils","nodeIdToIdentifierMap","Map","getGatsbyNodePartial","node","indexFields","resolvedFields","cacheKey","id","internal","counter","derefPartial","undefined","has","_nodeIdToIdentifierMa","get","deref","_every2","default","map","field","gatsbyNodePartialInternalData","dottedFields","fieldsToStore","Set","sortFieldIds","getSortFieldIdentifierKeys","fullNodeObject","resolvedNodeFields","dottedField","startsWith","getResolvedFields","getValueAt","slice","length","getNode","partial","Object","assign","type","set","WeakRef","exports","sortByIds","a","b","postIndexingMetaSetup","filterCache","op","bucket","byValue","sort","postIndexingMetaSetupNeNin","includes","postIndexingMetaSetupLtLteGtGte","arr","meta","nodesUnordered","forEach","v","nodeId","push","entriesNullable","entries","filter","orderedNodes","orderedValues","offsets","valuesAsc","nodesByValueAsc","valueRangesAsc","valuesDesc","nodesByValueDesc","valueRangesDesc","ensureIndexByQuery","filterCacheKey","filterPath","nodeTypeNames","filtersCache","getDataStore","iterateNodesByType","addNodeToFilterCache","chain","iterateNodes","ensureEmptyFilterCache","orderedByCounter","valueOffset","i","nextProp","Array","isArray","markNodeForValue","value","ensureIndexByElemMatch","addNodeToBucketWithElemMatch","valueAtCurrentStep","path","nestedQuery","elem","binarySearchAsc","values","needle","min","max","pivot","Math","floor","binarySearchDesc","getNodesFromCacheByValue","filterValue","wasElemMatch","_filterCache$byValue$","_filterCache$byValue$2","arrNull","arrUndef","unionNodesByCounter","Error","filterValueArr","_filterCache$byValue$3","add","nodes","expensiveDedupeInline","removeBucketFromSet","RegExp","regex","test","String","ranges","range","point","pivotMin","pivotMax","pivotValue","exclPivot","inclPivot","until","reverse","cache","delete","intersectNodesByCounter","pointerA","pointerB","result","maxA","maxB","lastAdded","counterA","counterB","prev","j","objectToDottedField","dottedFieldKeys","keys","fieldKeys","some","key"],"sources":["../../../src/datastore/in-memory/indexing.ts"],"sourcesContent":["import { IGatsbyNode } from \"../../redux/types\";\nimport {\n  IDbQueryElemMatch,\n  FilterValue,\n  FilterValueNullable,\n  objectToDottedField,\n} from \"../common/query\";\nimport { getDataStore, getNode } from \"..\";\nimport _ from \"lodash\";\nimport { getValueAt } from \"../../utils/get-value-at\";\nimport { getResolvedFields } from \"../../schema/utils\";\n\n// Only list supported ops here. \"CacheableFilterOp\"\n// TODO: merge with DbComparator ?\nexport type FilterOp =\n  | \"$eq\"\n  | \"$ne\"\n  | \"$lt\"\n  | \"$lte\"\n  | \"$gt\"\n  | \"$gte\"\n  | \"$in\"\n  | \"$nin\"\n  | \"$regex\"; // Note: this includes $glob\n\nexport type FilterCacheKey = string;\ntype GatsbyNodeID = string;\n\nexport interface IGatsbyNodePartial {\n  id: GatsbyNodeID;\n  internal: {\n    type: string;\n    counter: number;\n  };\n  gatsbyNodePartialInternalData: {\n    indexFields: Set<string>;\n  };\n  [k: string]: any;\n}\n\nconst nodeIdToIdentifierMap = new Map<\n  GatsbyNodeID,\n  WeakRef<IGatsbyNodePartial>\n>();\n\n/**\n * Grabs an instance of IGatsbyNodePartial for the given node.\n * This accepts an IGatsbyNode or IGatsbyNodePartial as input, which allows\n * us to conditionally store index fields on the partial if we encounter\n * one that hasn't been stored on the partial yet.\n */\nexport const getGatsbyNodePartial = (\n  node: IGatsbyNode | IGatsbyNodePartial,\n  indexFields: Array<string>,\n  resolvedFields: Record<string, any>,\n): IGatsbyNodePartial => {\n  // first, check if we have the partial in the cache\n  const cacheKey = `${node.id}_____${node.internal.counter}`;\n  let derefPartial: IGatsbyNodePartial | undefined = undefined;\n  if (nodeIdToIdentifierMap.has(cacheKey)) {\n    derefPartial = nodeIdToIdentifierMap.get(cacheKey)?.deref();\n\n    // now check if we have it in memory and it has all the fields we need\n    if (\n      derefPartial &&\n      _.every(\n        indexFields.map((field) =>\n          derefPartial!.gatsbyNodePartialInternalData.indexFields.has(field),\n        ),\n      )\n    ) {\n      return derefPartial;\n    }\n  }\n\n  // find all the keys of fields and store them and their values on the partial\n  // if we've already passed this partial, merge both sets of index fields\n  const dottedFields = {};\n  const fieldsToStore = derefPartial\n    ? new Set([\n        ...derefPartial.gatsbyNodePartialInternalData.indexFields,\n        ...indexFields,\n      ])\n    : new Set(indexFields);\n\n  const sortFieldIds = getSortFieldIdentifierKeys(\n    [...fieldsToStore],\n    resolvedFields,\n  );\n  let fullNodeObject: IGatsbyNode | undefined =\n    node.gatsbyNodePartialInternalData ? undefined : (node as IGatsbyNode);\n  let resolvedNodeFields;\n\n  for (const dottedField of sortFieldIds) {\n    if (dottedField in node) {\n      dottedFields[dottedField] = node[dottedField];\n    } else {\n      if (dottedField.startsWith(`__gatsby_resolved.`)) {\n        if (!resolvedNodeFields) {\n          resolvedNodeFields = getResolvedFields(node);\n        }\n\n        dottedFields[dottedField] = getValueAt(\n          resolvedNodeFields,\n          dottedField.slice(`__gatsby_resolved.`.length),\n        );\n      } else {\n        // if we haven't gotten the full node object, fetch it once\n        // use the full node object to fetch the value\n        if (!fullNodeObject) {\n          fullNodeObject = getNode(node.id)!;\n        }\n        dottedFields[dottedField] = getValueAt(fullNodeObject, dottedField);\n      }\n    }\n  }\n\n  // create the partial object\n  const partial = Object.assign(dottedFields, {\n    id: node.id,\n    internal: {\n      counter: node.internal.counter,\n      type: node.internal.type,\n    },\n    gatsbyNodePartialInternalData: {\n      indexFields: fieldsToStore,\n    },\n  });\n\n  // set the object in the cache for later fetching\n  nodeIdToIdentifierMap.set(cacheKey, new WeakRef<IGatsbyNodePartial>(partial));\n\n  return partial;\n};\n\nconst sortByIds = (a: IGatsbyNodePartial, b: IGatsbyNodePartial): number =>\n  a.internal.counter - b.internal.counter;\n\nexport interface IFilterCache {\n  op: FilterOp;\n  // In this map `undefined` values represent nodes that did not have the path\n  // The individual arrays are ordered asc by internal.counter which will\n  // preserve insertion order and guarantee uniqueness and it's a number so our\n  // .sort() calls can subtract one from the other which is nice :)\n  // This arrays may contain duplicates (!) because those only get filtered in the\n  // last step.\n  // TODO: We might decide to make sure these buckets _are_ deduped for eq perf\n  byValue: Map<FilterValueNullable, Array<IGatsbyNodePartial>>;\n  meta: {\n    // Used by ne/nin, which will create a Set from this array and then remove another set(s) and sort\n    nodesUnordered?: Array<IGatsbyNodePartial>;\n    // Flat list of all nodes by requested types, ordered by counter (cached for empty filters)\n    orderedByCounter?: Array<IGatsbyNodePartial>;\n    // Ordered list of all values (by `<`) found by this filter. No null / undefs\n    valuesAsc?: Array<FilterValue>;\n    // Flat list of nodes, ordered by valueAsc\n    nodesByValueAsc?: Array<IGatsbyNodePartial>;\n    // Ranges of nodes per value, maps to the nodesByValueAsc array\n    valueRangesAsc?: Map<FilterValue, [number, number]>;\n    // Ordered list of all values (by `>`) found by this filter. No null / undefs\n    valuesDesc?: Array<FilterValue>;\n    // Flat list of nodes, ordered by valueDesc\n    nodesByValueDesc?: Array<IGatsbyNodePartial>;\n    // Ranges of nodes per value, maps to the nodesByValueDesc array\n    valueRangesDesc?: Map<FilterValue, [number, number]>;\n  };\n}\nexport type FiltersCache = Map<FilterCacheKey, IFilterCache>;\n\nexport function postIndexingMetaSetup(\n  filterCache: IFilterCache,\n  op: FilterOp,\n): void {\n  // Loop through byValue and make sure the buckets are sorted by counter\n  // Since we don't do insertion sort, we have to do it afterwards\n  for (const bucket of filterCache.byValue) {\n    bucket[1].sort(sortByIds);\n  }\n\n  if (op === `$ne` || op === `$nin`) {\n    postIndexingMetaSetupNeNin(filterCache);\n  } else if ([`$lt`, `$lte`, `$gt`, `$gte`].includes(op)) {\n    postIndexingMetaSetupLtLteGtGte(filterCache, op);\n  }\n}\n\nfunction postIndexingMetaSetupNeNin(filterCache: IFilterCache): void {\n  // Note: edge cases regarding `null` and `undefined`. Here `undefined` signals\n  // that the property did not exist as the filters do not support actual\n  // `undefined` values.\n  // For $ne, `null` only returns nodes that actually have the property\n  // and in that case the property cannot be `null` either. For any other value,\n  // $ne will return all nodes where the value is not actually the needle,\n  // including nodes where the value is null.\n  // A $nin does the same as an $ne except it filters multiple values instead\n  // of just one.\n  // For `$ne` we will take the list of all targeted nodes and eliminate the\n  // bucket of nodes with a particular value, if it exists at all..\n\n  const arr: Array<IGatsbyNodePartial> = [];\n  filterCache.meta.nodesUnordered = arr;\n  filterCache.byValue.forEach((v) => {\n    v.forEach((nodeId) => {\n      arr.push(nodeId);\n    });\n  });\n}\n\nfunction postIndexingMetaSetupLtLteGtGte(\n  filterCache: IFilterCache,\n  op: FilterOp,\n): void {\n  // Create an ordered array of individual nodes, ordered (grouped) by the\n  // value to which the filter resolves. Nodes per value are ordered by\n  // internal.counter, asc.\n  // This way non-eq ops can simply slice the array to get a range.\n\n  const entriesNullable: Array<\n    [FilterValueNullable, Array<IGatsbyNodePartial>]\n  > = [...filterCache.byValue.entries()];\n\n  // These range checks never return `null` or `undefined` so filter those out\n  // By filtering them out early, the sort should be faster. Could be ...\n  const entries: Array<[FilterValue, Array<IGatsbyNodePartial>]> =\n    entriesNullable.filter(([v]) => v != null) as Array<\n      [FilterValue, Array<IGatsbyNodePartial>]\n    >;\n\n  // Sort all arrays by its value, asc. Ignore/allow potential type casting.\n  // Note: while `<` is the inverse of `>=`, the ordering might coerce values.\n  // This coercion makes the op no longer idempotent (normally the result of\n  // `a < b` is the opposite of `b >= a` for any a or b of the same type). The\n  // exception is a number that is `NaN`, which we're ignoring here as it's most\n  // likely a bug in the user code. However, when coercing the ops may end up\n  // comparing against `NaN`, too. For example: `(\"abc\" <= 12) !== (12 > \"abc\")`\n  // which ends up doing `NaN <= 12` and `NaN > \"abc\"`, which will both yield\n  // false.\n  // So instead we potentially track two ordered lists; ascending and descending\n  // and the only difference when comparing the inverse of one to the other\n  // should be how these `NaN` cases end up getting ordered.\n  // It's fine for `lt` and `lte` to use the same ordered list. Same for gt/gte.\n  if (op === `$lt` || op === `$lte`) {\n    // Order ascending; first value is lowest\n    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));\n  } else if (op === `$gt` || op === `$gte`) {\n    // Order descending; first value is highest\n    entries.sort(([a], [b]) => (a > b ? -1 : a < b ? 1 : 0));\n  }\n\n  const orderedNodes: Array<IGatsbyNodePartial> = [];\n  const orderedValues: Array<FilterValue> = [];\n  const offsets: Map<FilterValue, [number, number]> = new Map();\n  entries.forEach(([v, bucket]: [FilterValue, Array<IGatsbyNodePartial>]) => {\n    // Record the range containing all nodes with as filter value v\n    // The last value of the range should be the offset of the next value\n    // (So you should be able to do `nodes.slice(start, stop)` to get them)\n    offsets.set(v, [orderedNodes.length, orderedNodes.length + bucket.length]);\n    // We could do `arr.push(...bucket)` here but that's not safe with very\n    // large sets, so we use a regular loop\n    bucket.forEach((node) => orderedNodes.push(node));\n    orderedValues.push(v);\n  });\n\n  if (op === `$lt` || op === `$lte`) {\n    filterCache.meta.valuesAsc = orderedValues;\n    filterCache.meta.nodesByValueAsc = orderedNodes;\n    // The nodesByValueAsc is ordered by value, but multiple nodes per value are\n    // not ordered. To make lt as fast as lte, we must know the start and stop\n    // index for each value. Similarly useful for for `ne`.\n    filterCache.meta.valueRangesAsc = offsets;\n  } else if (op === `$gt` || op === `$gte`) {\n    filterCache.meta.valuesDesc = orderedValues;\n    filterCache.meta.nodesByValueDesc = orderedNodes;\n    // The nodesByValueDesc is ordered by value, but multiple nodes per value are\n    // not ordered. To make gt as fast as gte, we must know the start and stop\n    // index for each value. Similarly useful for for `ne`.\n    filterCache.meta.valueRangesDesc = offsets;\n  }\n}\n\n/**\n * Given a single non-elemMatch filter path, a list of node types, and a\n * cache, create a cache that for each resulting value of the filter contains\n * all the Nodes in a list.\n * This cache is used for applying the filter and is a massive improvement over\n * looping over all the nodes, when the number of pages (/nodes) scales up.\n */\nexport const ensureIndexByQuery = (\n  op: FilterOp,\n  filterCacheKey: FilterCacheKey,\n  filterPath: Array<string>,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache,\n  indexFields: Array<string>,\n  resolvedFields: Record<string, any>,\n): void => {\n  const filterCache: IFilterCache = {\n    op,\n    byValue: new Map<FilterValueNullable, Array<IGatsbyNodePartial>>(),\n    meta: {},\n  } as IFilterCache;\n  filtersCache.set(filterCacheKey, filterCache);\n\n  // We cache the subsets of nodes by type, but only one type. So if searching\n  // through one node type we can prevent a search through all nodes, otherwise\n  // it's probably faster to loop through all nodes. Perhaps. Maybe.\n\n  if (nodeTypeNames.length === 1) {\n    getDataStore()\n      .iterateNodesByType(nodeTypeNames[0])\n      .forEach((node) => {\n        addNodeToFilterCache({\n          node,\n          chain: filterPath,\n          filterCache,\n          indexFields,\n          resolvedFields,\n        });\n      });\n  } else {\n    // Here we must first filter for the node type\n    // This loop is expensive at scale (!)\n    getDataStore()\n      .iterateNodes()\n      .forEach((node) => {\n        if (!nodeTypeNames.includes(node.internal.type)) {\n          return;\n        }\n\n        addNodeToFilterCache({\n          node,\n          chain: filterPath,\n          filterCache,\n          indexFields,\n          resolvedFields,\n        });\n      });\n  }\n\n  postIndexingMetaSetup(filterCache, op);\n};\n\nexport function ensureEmptyFilterCache(\n  filterCacheKey,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache,\n  indexFields: Array<string>,\n  resolvedFields: Record<string, any>,\n): void {\n  // This is called for queries without any filters\n  // We want to cache the result since it's basically a list of nodes by type(s)\n  // There are sites that have multiple queries which are empty\n\n  const orderedByCounter: Array<IGatsbyNodePartial> = [];\n\n  filtersCache.set(filterCacheKey, {\n    op: `$eq`, // Ignore.\n    byValue: new Map<FilterValueNullable, Array<IGatsbyNodePartial>>(),\n    meta: {\n      orderedByCounter, // This is what we want\n    },\n  });\n\n  if (nodeTypeNames.length === 1) {\n    getDataStore()\n      .iterateNodesByType(nodeTypeNames[0])\n      .forEach((node) => {\n        orderedByCounter.push(\n          getGatsbyNodePartial(node, indexFields, resolvedFields),\n        );\n      });\n  } else {\n    // Here we must first filter for the node type\n    // This loop is expensive at scale (!)\n    getDataStore()\n      .iterateNodes()\n      .forEach((node) => {\n        if (nodeTypeNames.includes(node.internal.type)) {\n          orderedByCounter.push(\n            getGatsbyNodePartial(node, indexFields, resolvedFields),\n          );\n        }\n      });\n  }\n\n  // Since each node can only have one type, we shouldn't have to be concerned\n  // about duplicates in this array. Just make sure they're sorted.\n  orderedByCounter.sort(sortByIds);\n}\n\nfunction addNodeToFilterCache({\n  node,\n  chain,\n  filterCache,\n  indexFields,\n  resolvedFields,\n  valueOffset = node,\n}: {\n  node: IGatsbyNode;\n  chain: Array<string>;\n  filterCache: IFilterCache;\n  indexFields: Array<string>;\n  resolvedFields: Record<string, any>;\n  valueOffset?: any;\n}): void {\n  // - for plain query, valueOffset === node\n  // - for elemMatch, valueOffset is sub-tree of the node to continue matching\n  let v = valueOffset as any;\n  let i = 0;\n  while (i < chain.length && v) {\n    const nextProp = chain[i++];\n    if (i === 1 && nextProp === `__gatsby_resolved`) {\n      v = getResolvedFields(v);\n    } else {\n      v = v[nextProp];\n    }\n  }\n\n  if (\n    (typeof v !== `string` &&\n      typeof v !== `number` &&\n      typeof v !== `boolean` &&\n      v !== null) ||\n    i !== chain.length\n  ) {\n    if (i === chain.length && Array.isArray(v)) {\n      // The op resolved to an array\n      // Add an entry for each element of the array. This would work for ops\n      // like eq and ne, but not sure about range ops like lt,lte,gt,gte.\n\n      v.forEach((v) =>\n        markNodeForValue(filterCache, node, v, indexFields, resolvedFields),\n      );\n\n      return;\n    }\n\n    // This means that either\n    // - The filter resolved to `undefined`, or\n    // - The filter resolved to something other than a primitive\n    // Set the value to `undefined` to mark \"path does not (fully) exist\"\n    v = undefined;\n  }\n\n  markNodeForValue(filterCache, node, v, indexFields, resolvedFields);\n}\n\nfunction markNodeForValue(\n  filterCache: IFilterCache,\n  node: IGatsbyNode,\n  value: FilterValueNullable,\n  indexFields: Array<string>,\n  resolvedFields: Record<string, any>,\n): void {\n  let arr = filterCache.byValue.get(value);\n  if (!arr) {\n    arr = [];\n    filterCache.byValue.set(value, arr);\n  }\n\n  const partial = getGatsbyNodePartial(node, indexFields, resolvedFields);\n  if (!arr.includes(partial)) {\n    arr.push(partial);\n  }\n}\n\nexport const ensureIndexByElemMatch = (\n  op: FilterOp,\n  filterCacheKey: FilterCacheKey,\n  filter: IDbQueryElemMatch,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache,\n  indexFields: Array<string>,\n  resolvedFields: Record<string, any>,\n): void => {\n  // Given an elemMatch filter, generate the cache that contains all nodes that\n  // matches a given value for that sub-query\n\n  const filterCache: IFilterCache = {\n    op,\n    byValue: new Map<FilterValueNullable, Array<IGatsbyNodePartial>>(),\n    meta: {},\n  } as IFilterCache;\n  filtersCache.set(filterCacheKey, filterCache);\n\n  if (nodeTypeNames.length === 1) {\n    getDataStore()\n      .iterateNodesByType(nodeTypeNames[0])\n      .forEach((node) => {\n        addNodeToBucketWithElemMatch({\n          node,\n          valueAtCurrentStep: node,\n          filter,\n          filterCache,\n          indexFields,\n          resolvedFields,\n        });\n      });\n  } else {\n    // Expensive at scale\n    getDataStore()\n      .iterateNodes()\n      .forEach((node) => {\n        if (!nodeTypeNames.includes(node.internal.type)) {\n          return;\n        }\n\n        addNodeToBucketWithElemMatch({\n          node,\n          valueAtCurrentStep: node,\n          filter,\n          filterCache,\n          indexFields,\n          resolvedFields,\n        });\n      });\n  }\n\n  postIndexingMetaSetup(filterCache, op);\n};\n\nfunction addNodeToBucketWithElemMatch({\n  node,\n  valueAtCurrentStep, // Arbitrary step on the path inside the node\n  filter,\n  filterCache,\n  indexFields,\n  resolvedFields,\n}: {\n  node: IGatsbyNode;\n  valueAtCurrentStep: any; // Arbitrary step on the path inside the node\n  filter: IDbQueryElemMatch;\n  filterCache: IFilterCache;\n  indexFields: Array<string>;\n  resolvedFields: Record<string, any>;\n}): void {\n  const { path, nestedQuery } = filter;\n\n  // Find the value to apply elemMatch to\n  let i = 0;\n  while (i < path.length && valueAtCurrentStep) {\n    const nextProp = path[i++];\n    if (i === 1 && nextProp === `__gatsby_resolved`) {\n      valueAtCurrentStep = getResolvedFields(valueAtCurrentStep);\n    } else {\n      valueAtCurrentStep = valueAtCurrentStep[nextProp];\n    }\n  }\n\n  if (path.length !== i) {\n    // Found undefined before the end of the path\n    return;\n  }\n\n  // `v` should now be an elemMatch target, probably an array (but maybe not)\n  if (!Array.isArray(valueAtCurrentStep)) {\n    // It's possible to `elemMatch` on a non-array so let's support that too\n    valueAtCurrentStep = [valueAtCurrentStep];\n  }\n\n  // Note: We need to check all elements because the node may need to be added\n  // to multiple buckets (`{a:[{b:3},{b:4}]}`, for `a.elemMatch.b/eq` that\n  // node ends up in buckets for value 3 and 4. This may lead to duplicate\n  // work when elements resolve to the same value, but that can't be helped.\n  valueAtCurrentStep.forEach((elem) => {\n    if (nestedQuery.type === `elemMatch`) {\n      addNodeToBucketWithElemMatch({\n        node,\n        valueAtCurrentStep: elem,\n        filter: nestedQuery,\n        filterCache,\n        indexFields,\n        resolvedFields,\n      });\n    } else {\n      // Now take same route as non-elemMatch filters would take\n      addNodeToFilterCache({\n        node,\n        chain: nestedQuery.path,\n        filterCache,\n        indexFields,\n        resolvedFields,\n        valueOffset: elem,\n      });\n    }\n  });\n}\n\nconst binarySearchAsc = (\n  values: Array<FilterValue>, // Assume ordered asc\n  needle: FilterValue,\n): [number, number] | undefined => {\n  let min = 0;\n  let max = values.length - 1;\n  let pivot = Math.floor(values.length / 2);\n  while (min <= max) {\n    const value = values[pivot];\n    if (needle < value) {\n      // Move pivot to middle of nodes left of current pivot\n      // assert pivot < max\n      max = pivot;\n    } else if (needle > value) {\n      // Move pivot to middle of nodes right of current pivot\n      // assert pivot > min\n      min = pivot;\n    } else {\n      // This means needle === value\n      // TODO: except for NaN ... and potentially certain type casting cases\n      return [pivot, pivot];\n    }\n\n    if (max - min <= 1) {\n      // End of search. Needle not found (as expected). Use pivot as index.\n      // If the needle was not found, max-min==1 and max is returned.\n      return [min, max];\n    }\n\n    pivot = min + Math.floor((max - min) / 2);\n  }\n\n  // Shouldn't be reachable\n  return undefined;\n};\nconst binarySearchDesc = (\n  values: Array<FilterValue>, // Assume ordered desc\n  needle: FilterValue,\n): [number, number] | undefined => {\n  let min = 0;\n  let max = values.length - 1;\n  let pivot = Math.floor(values.length / 2);\n  while (min <= max) {\n    const value = values[pivot];\n    if (needle < value) {\n      // Move pivot to middle of nodes right of current pivot\n      // assert pivot < min\n      min = pivot;\n    } else if (needle > value) {\n      // Move pivot to middle of nodes left of current pivot\n      // assert pivot > max\n      max = pivot;\n    } else {\n      // This means needle === value\n      // TODO: except for NaN ... and potentially certain type casting cases\n      return [pivot, pivot];\n    }\n\n    if (max - min <= 1) {\n      // End of search. Needle not found (as expected). Use pivot as index.\n      // If the needle was not found, max-min==1 and max is returned.\n      return [min, max];\n    }\n\n    pivot = min + Math.floor((max - min) / 2);\n  }\n\n  // Shouldn't be reachable\n  return undefined;\n};\n\n/**\n * Given the cache key for a filter and a target value return the list of nodes\n * that resolve to this value. The returned array should be ordered by id.\n * This returns `undefined` if there is no such node\n *\n * Basically if the filter was {a: {b: {slug: {eq: \"foo/bar\"}}}} then it will\n * return all the nodes that have `node.slug === \"foo/bar\"`. That usually (but\n * not always) at most one node for slug, but this filter can apply to anything.\n *\n * Arrays returned by this function must be ordered by internal.counter and\n * not contain duplicate nodes (!)\n */\nexport const getNodesFromCacheByValue = (\n  filterCacheKey: FilterCacheKey,\n  filterValue: FilterValueNullable,\n  filtersCache: FiltersCache,\n  wasElemMatch,\n): Array<IGatsbyNodePartial> | undefined => {\n  const filterCache = filtersCache.get(filterCacheKey);\n  if (!filterCache) {\n    return undefined;\n  }\n\n  const op = filterCache.op;\n\n  if (op === `$eq`) {\n    // Arrays in byValue are assumed to be ordered by counter\n\n    if (filterValue == null) {\n      // Edge case for null; fetch all nodes for `null` and `undefined` because\n      // `$eq` also returns nodes without the path when searching for `null`.\n      // Not all ops do so, so we map non-existing paths to `undefined`.\n\n      const arrNull = filterCache.byValue.get(null) ?? [];\n      const arrUndef = filterCache.byValue.get(undefined) ?? [];\n\n      // Merge the two (ordered) arrays and return an ordered deduped array\n      // TODO: is there a reason left why we cant just cache this merged list?\n      return unionNodesByCounter(arrNull, arrUndef);\n    }\n\n    return filterCache.byValue.get(filterValue);\n  }\n\n  if (op === `$in`) {\n    if (!Array.isArray(filterValue)) {\n      throw new Error(\"The argument to the `in` comparator should be an array\");\n    }\n    const filterValueArr: Array<FilterValueNullable> = filterValue;\n\n    const set: Set<IGatsbyNodePartial> = new Set();\n\n    // TODO: we can also mergeSort for every step. this may perform worse because of how memory in js works.\n    // For every value in the needle array, find the bucket of nodes for\n    // that value, add this bucket of nodes to one list, return the list.\n    filterValueArr.forEach((v: FilterValueNullable) =>\n      filterCache.byValue.get(v)?.forEach((v) => set.add(v)),\n    );\n\n    const arr = [...set]; // this is bad for perf but will guarantee us a unique set :(\n    arr.sort(sortByIds);\n\n    // Note: it's very unlikely that the list of filter values is big so .includes should be fine here\n    if (filterValueArr.includes(null)) {\n      // Like all other ops, `in: [null]` behaves weirdly, allowing all nodes\n      // that do not actually have a (complete) path (v=undefined)\n      const nodes = filterCache.byValue.get(undefined);\n      if (nodes) {\n        // This will also dedupe so don't do that immediately\n        return unionNodesByCounter(nodes, arr);\n      }\n    }\n\n    // elemMatch can cause a node to appear in multiple buckets so we must dedupe first\n    if (wasElemMatch) {\n      expensiveDedupeInline(arr);\n    }\n\n    return arr;\n  }\n\n  if (op === `$nin`) {\n    // This is essentially the same as the $ne operator, just with multiple\n    // values to exclude.\n\n    if (!Array.isArray(filterValue)) {\n      throw new Error(`The $nin operator expects an array as value`);\n    }\n\n    const values: Set<FilterValueNullable> = new Set(filterValue);\n    const set = new Set(filterCache.meta.nodesUnordered);\n\n    // Do the action for \"$ne\" for each element in the set of values\n    values.forEach((filterValue) => {\n      removeBucketFromSet(filterValue, filterCache, set);\n    });\n\n    // TODO: there's probably a more efficient algorithm to do set\n    //       subtraction in such a way that we don't have to re-sort\n    return [...set].sort(sortByIds);\n  }\n\n  if (op === `$ne`) {\n    const set = new Set(filterCache.meta.nodesUnordered);\n\n    removeBucketFromSet(filterValue, filterCache, set);\n\n    // TODO: there's probably a more efficient algorithm to do set\n    //       subtraction in such a way that we don't have to resort here\n    return [...set].sort(sortByIds);\n  }\n\n  if (op === `$regex`) {\n    // Note: $glob is converted to $regex so $glob filters go through here, too\n    // Aside from the input pattern format, further behavior is exactly the same.\n\n    // The input to the filter must be a string (including leading/trailing slash and regex flags)\n    // By the time the filter reaches this point, the filterValue has to be a regex.\n\n    if (!(filterValue instanceof RegExp)) {\n      throw new Error(\n        `The value for the $regex comparator must be an instance of RegExp`,\n      );\n    }\n    const regex = filterValue;\n\n    const arr: Array<IGatsbyNodePartial> = [];\n    filterCache.byValue.forEach((nodes, value) => {\n      // TODO: does the value have to be a string for $regex? Can we auto-ignore any non-strings? Or does it coerce.\n      // Note: for legacy reasons partial paths should also be included for regex\n      if (value !== undefined && regex.test(String(value))) {\n        nodes.forEach((node) => arr.push(node));\n      }\n    });\n\n    // TODO: we _can_ cache this list as well. Might make sense if it turns out that $regex is mostly used with literals\n    // TODO: it may make sense to first collect all buckets and then to .concat them, or merge sort them\n\n    arr.sort(sortByIds);\n\n    // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n    if (wasElemMatch) {\n      expensiveDedupeInline(arr);\n    }\n\n    return arr;\n  }\n\n  if (filterValue == null) {\n    if (op === `$lt` || op === `$gt`) {\n      // Nothing is lt/gt null\n      return undefined;\n    }\n\n    // This is an edge case and this value should be directly indexed\n    // For `lte`/`gte` this should only return nodes for `null`, not a \"range\"\n    return filterCache.byValue.get(filterValue);\n  }\n\n  if (Array.isArray(filterValue)) {\n    throw new Error(\n      \"Array is an invalid filter value for the `\" + op + \"` comparator\",\n    );\n  }\n\n  if (filterValue instanceof RegExp) {\n    // This is most likely an internal error, although it is possible for\n    // users to talk to this API more directly.\n    throw new Error(\n      `A RegExp instance is only valid for $regex and $glob comparators`,\n    );\n  }\n\n  if (op === `$lt`) {\n    // First try a direct approach. If a value is queried that also exists then\n    // we can prevent a binary search through the whole list, O(1) vs O(log n)\n\n    const ranges = filterCache.meta.valueRangesAsc;\n    const nodes = filterCache.meta.nodesByValueAsc;\n\n    const range = ranges!.get(filterValue);\n    if (range) {\n      const arr = nodes!.slice(0, range[0]);\n      arr.sort(sortByIds);\n      // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n      if (wasElemMatch) {\n        expensiveDedupeInline(arr);\n      }\n      return arr;\n    }\n\n    // Query may ask for a value that doesn't appear in the list, like if the\n    // list is [1, 2, 5, 6] and the query is <= 3. In that case we have to\n    // apply a search (we'll do binary) to determine the offset to slice from.\n\n    // Note: for lte, the valueAsc array must be list at this point\n    const values = filterCache.meta.valuesAsc as Array<FilterValue>;\n    // It shouldn't find the targetValue (but it might) and return the index of\n    // the two value between which targetValue sits, or first/last element.\n    const point = binarySearchAsc(values, filterValue);\n    if (!point) {\n      return undefined;\n    }\n    const [pivotMin, pivotMax] = point;\n\n    // Each pivot index must have a value and a range\n    // The returned min/max index may include the lower/upper bound, so we still\n    // have to do lte checks for both values.\n    let pivotValue = values[pivotMax];\n    if (pivotValue > filterValue) {\n      pivotValue = values[pivotMin];\n    }\n\n    // Note: the pivot value _shouldnt_ match the filter value because that\n    // means the value was actually found, but those should have been indexed\n    // so should have yielded a result in the .get() above.\n\n    const [exclPivot, inclPivot] = ranges!.get(pivotValue) as [number, number];\n\n    // Note: technically, `5 <= \"5\" === true` but `5` would not be cached.\n    // So we have to consider weak comparison and may have to include the pivot\n    const until = pivotValue < filterValue ? inclPivot : exclPivot;\n    const arr = nodes!.slice(0, until);\n    arr.sort(sortByIds);\n    // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n    if (wasElemMatch) {\n      expensiveDedupeInline(arr);\n    }\n    return arr;\n  }\n\n  if (op === `$lte`) {\n    // First try a direct approach. If a value is queried that also exists then\n    // we can prevent a binary search through the whole list, O(1) vs O(log n)\n\n    const ranges = filterCache.meta.valueRangesAsc;\n    const nodes = filterCache.meta.nodesByValueAsc;\n\n    const range = ranges!.get(filterValue);\n    if (range) {\n      const arr = nodes!.slice(0, range[1]);\n      arr.sort(sortByIds);\n      // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n      if (wasElemMatch) {\n        expensiveDedupeInline(arr);\n      }\n      return arr;\n    }\n\n    // Query may ask for a value that doesn't appear in the list, like if the\n    // list is [1, 2, 5, 6] and the query is <= 3. In that case we have to\n    // apply a search (we'll do binary) to determine the offset to slice from.\n\n    // Note: for lte, the valueAsc array must be list at this point\n    const values = filterCache.meta.valuesAsc as Array<FilterValue>;\n    // It shouldn't find the targetValue (but it might) and return the index of\n    // the two value between which targetValue sits, or first/last element.\n    const point = binarySearchAsc(values, filterValue);\n    if (!point) {\n      return undefined;\n    }\n    const [pivotMin, pivotMax] = point;\n\n    // Each pivot index must have a value and a range\n    // The returned min/max index may include the lower/upper bound, so we still\n    // have to do lte checks for both values.\n    let pivotValue = values[pivotMax];\n    if (pivotValue > filterValue) {\n      pivotValue = values[pivotMin];\n    }\n\n    // Note: the pivot value _shouldnt_ match the filter value because that\n    // means the value was actually found, but those should have been indexed\n    // so should have yielded a result in the .get() above.\n\n    const [exclPivot, inclPivot] = ranges!.get(pivotValue) as [number, number];\n\n    // Note: technically, `5 <= \"5\" === true` but `5` would not be cached.\n    // So we have to consider weak comparison and may have to include the pivot\n    const until = pivotValue <= filterValue ? inclPivot : exclPivot;\n    const arr = nodes!.slice(0, until);\n    arr.sort(sortByIds);\n    // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n    if (wasElemMatch) {\n      expensiveDedupeInline(arr);\n    }\n    return arr;\n  }\n\n  if (op === `$gt`) {\n    // First try a direct approach. If a value is queried that also exists then\n    // we can prevent a binary search through the whole list, O(1) vs O(log n)\n\n    const ranges = filterCache.meta.valueRangesDesc;\n    const nodes = filterCache.meta.nodesByValueDesc;\n\n    const range = ranges!.get(filterValue);\n    if (range) {\n      const arr = nodes!.slice(0, range[0]).reverse();\n      arr.sort(sortByIds);\n      // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n      if (wasElemMatch) {\n        expensiveDedupeInline(arr);\n      }\n      return arr;\n    }\n\n    // Query may ask for a value that doesn't appear in the list, like if the\n    // list is [1, 2, 5, 6] and the query is <= 3. In that case we have to\n    // apply a search (we'll do binary) to determine the offset to slice from.\n\n    // Note: for gte, the valueDesc array must be list at this point\n    const values = filterCache.meta.valuesDesc as Array<FilterValue>;\n    // It shouldn't find the targetValue (but it might) and return the index of\n    // the two value between which targetValue sits, or first/last element.\n    const point = binarySearchDesc(values, filterValue);\n    if (!point) {\n      return undefined;\n    }\n    const [pivotMin, pivotMax] = point;\n\n    // Each pivot index must have a value and a range\n    // The returned min/max index may include the lower/upper bound, so we still\n    // have to do gte checks for both values.\n    let pivotValue = values[pivotMax];\n    if (pivotValue < filterValue) {\n      pivotValue = values[pivotMin];\n    }\n\n    // Note: the pivot value _shouldnt_ match the filter value because that\n    // means the value was actually found, but those should have been indexed\n    // so should have yielded a result in the .get() above.\n\n    const [exclPivot, inclPivot] = ranges!.get(pivotValue) as [number, number];\n\n    // Note: technically, `5 >= \"5\" === true` but `5` would not be cached.\n    // So we have to consider weak comparison and may have to include the pivot\n    const until = pivotValue > filterValue ? inclPivot : exclPivot;\n    const arr = nodes!.slice(0, until).reverse();\n    arr.sort(sortByIds);\n    // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n    if (wasElemMatch) {\n      expensiveDedupeInline(arr);\n    }\n    return arr;\n  }\n\n  if (op === `$gte`) {\n    // First try a direct approach. If a value is queried that also exists then\n    // we can prevent a binary search through the whole list, O(1) vs O(log n)\n\n    const ranges = filterCache.meta.valueRangesDesc;\n    const nodes = filterCache.meta.nodesByValueDesc;\n\n    const range = ranges!.get(filterValue);\n    if (range) {\n      const arr = nodes!.slice(0, range[1]).reverse();\n      arr.sort(sortByIds);\n      // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n      if (wasElemMatch) {\n        expensiveDedupeInline(arr);\n      }\n      return arr;\n    }\n\n    // Query may ask for a value that doesn't appear in the list, like if the\n    // list is [1, 2, 5, 6] and the query is <= 3. In that case we have to\n    // apply a search (we'll do binary) to determine the offset to slice from.\n\n    // Note: for gte, the valueDesc array must be list at this point\n    const values = filterCache.meta.valuesDesc as Array<FilterValue>;\n    // It shouldn't find the targetValue (but it might) and return the index of\n    // the two value between which targetValue sits, or first/last element.\n    const point = binarySearchDesc(values, filterValue);\n    if (!point) {\n      return undefined;\n    }\n    const [pivotMin, pivotMax] = point;\n\n    // Each pivot index must have a value and a range\n    // The returned min/max index may include the lower/upper bound, so we still\n    // have to do gte checks for both values.\n    let pivotValue = values[pivotMax];\n    if (pivotValue < filterValue) {\n      pivotValue = values[pivotMin];\n    }\n\n    // Note: the pivot value _shouldnt_ match the filter value because that\n    // means the value was actually found, but those should have been indexed\n    // so should have yielded a result in the .get() above.\n\n    const [exclPivot, inclPivot] = ranges!.get(pivotValue) as [number, number];\n\n    // Note: technically, `5 >= \"5\" === true` but `5` would not be cached.\n    // So we have to consider weak comparison and may have to include the pivot\n    const until = pivotValue >= filterValue ? inclPivot : exclPivot;\n    const arr = nodes!.slice(0, until).reverse();\n    arr.sort(sortByIds);\n    // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n    if (wasElemMatch) {\n      expensiveDedupeInline(arr);\n    }\n    return arr;\n  }\n\n  // Unreachable because we checked all values of FilterOp (which op is)\n  return undefined;\n};\n\nfunction removeBucketFromSet(\n  filterValue: FilterValueNullable,\n  filterCache: IFilterCache,\n  set: Set<IGatsbyNodePartial>,\n): void {\n  if (filterValue === null) {\n    // Edge case: $ne with `null` returns only the nodes that contain the full\n    // path and that don't resolve to null, so drop `undefined` as well.\n    let cache = filterCache.byValue.get(undefined);\n    if (cache) cache.forEach((node) => set.delete(node));\n    cache = filterCache.byValue.get(null);\n    if (cache) cache.forEach((node) => set.delete(node));\n  } else {\n    // Not excluding null so it should include undefined leafs or leafs where\n    // only the partial path exists for whatever reason.\n    const cache = filterCache.byValue.get(filterValue);\n    if (cache) cache.forEach((node) => set.delete(node));\n  }\n}\n\n/**\n * Finds the intersection of two arrays in O(n) with n = min(a.length, b.length)\n * The returned set should not contain duplicate nodes.\n *\n * The input should be ordered by node.internal.counter and it will return a\n * list that is also ordered by node.internal.counter\n */\nexport function intersectNodesByCounter(\n  a: Array<IGatsbyNodePartial>,\n  b: Array<IGatsbyNodePartial>,\n): Array<IGatsbyNodePartial> {\n  let pointerA = 0;\n  let pointerB = 0;\n  // TODO: perf check: is it helpful to init the array to min(maxA,maxB) items?\n  const result: Array<IGatsbyNodePartial> = [];\n  const maxA = a.length;\n  const maxB = b.length;\n  let lastAdded: IGatsbyNodePartial | undefined = undefined; // Used to dedupe the list\n\n  while (pointerA < maxA && pointerB < maxB) {\n    const counterA = a[pointerA].internal.counter;\n    const counterB = b[pointerB].internal.counter;\n\n    if (counterA < counterB) {\n      pointerA++;\n    } else if (counterA > counterB) {\n      pointerB++;\n    } else {\n      if (a[pointerA].id !== b[pointerB].id) {\n        throw new Error(\n          `Invariant violation: inconsistent node counters detected`,\n        );\n      }\n      // nodeA===nodeB. Make sure we didn't just add this node already.\n      // Since input arrays are sorted, the same node should be grouped\n      // back to back, so even if both input arrays contained the same node\n      // twice, this check would prevent the result from getting duplicate nodes\n      if (lastAdded !== a[pointerA]) {\n        result.push(a[pointerA]);\n        lastAdded = a[pointerA];\n      }\n      pointerA++;\n      pointerB++;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Merge two lists of nodes.\n * The returned set should not contain duplicate nodes.\n *\n * The input should be ordered by node.internal.counter and it will return a\n * list that is also ordered by node.internal.counter\n */\nexport function unionNodesByCounter(\n  a: Array<IGatsbyNodePartial>,\n  b: Array<IGatsbyNodePartial>,\n): Array<IGatsbyNodePartial> {\n  // TODO: perf check: is it helpful to init the array to max(maxA,maxB) items?\n  const arr: Array<IGatsbyNodePartial> = [];\n  let lastAdded: IGatsbyNodePartial | undefined = undefined; // Used to dedupe the list\n\n  let pointerA = 0;\n  let pointerB = 0;\n  const maxA = a.length;\n  const maxB = b.length;\n\n  while (pointerA < maxA && pointerB < maxB) {\n    const counterA = a[pointerA].internal.counter;\n    const counterB = b[pointerB].internal.counter;\n\n    if (counterA < counterB) {\n      if (lastAdded !== a[pointerA]) {\n        arr.push(a[pointerA]);\n        lastAdded = a[pointerA];\n      }\n      pointerA++;\n    } else if (counterA > counterB) {\n      if (lastAdded !== b[pointerB]) {\n        arr.push(b[pointerB]);\n        lastAdded = b[pointerB];\n      }\n      pointerB++;\n    } else {\n      if (lastAdded !== a[pointerA]) {\n        arr.push(a[pointerA]);\n        lastAdded = a[pointerA];\n      }\n      pointerA++;\n      pointerB++;\n    }\n  }\n\n  while (pointerA < maxA) {\n    if (lastAdded !== a[pointerA]) {\n      arr.push(a[pointerA]);\n      lastAdded = a[pointerA];\n    }\n    pointerA++;\n  }\n\n  while (pointerB < maxB) {\n    if (lastAdded !== b[pointerB]) {\n      arr.push(b[pointerB]);\n      lastAdded = b[pointerB];\n    }\n    pointerB++;\n  }\n\n  return arr;\n}\n\nfunction expensiveDedupeInline(arr: Array<IGatsbyNodePartial>): void {\n  // An elemMatch filter may cause duplicates to appear in a bucket.\n  // Since the bucket is sorted those should now be back to back\n  // Worst case this is a fast O(n) loop that does nothing.\n  let prev: IGatsbyNodePartial | undefined = undefined;\n\n  // We copy-on-find because a splice is expensive and we can't use Sets\n\n  let j = 0;\n  for (let i = 0; i < arr.length; ++i) {\n    const node = arr[i];\n    if (node !== prev) {\n      // Only start copying the remainder of the list once a dupe is found\n      if (i !== j) {\n        arr[j] = node;\n      }\n      ++j;\n      prev = node;\n    }\n  }\n  arr.length = j;\n}\n\nexport function getSortFieldIdentifierKeys(\n  indexFields: Array<string>,\n  resolvedFields: Record<string, any>,\n): Array<string> {\n  const dottedFields = objectToDottedField(resolvedFields);\n  const dottedFieldKeys = Object.keys(dottedFields);\n  const fieldKeys = indexFields.map((field) => {\n    if (\n      dottedFields[field] ||\n      dottedFieldKeys.some((key) => field.startsWith(key))\n    ) {\n      return `__gatsby_resolved.${field}`;\n    } else {\n      return field;\n    }\n  });\n\n  return fieldKeys;\n}\n"],"mappings":"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"}