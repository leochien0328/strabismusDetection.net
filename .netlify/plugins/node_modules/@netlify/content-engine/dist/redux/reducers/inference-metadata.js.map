{"version":3,"file":"inference-metadata.js","names":["_inferenceMetadata","require","_nodeInterface","_typeDefs","ignoredFields","Set","NodeInterfaceFields","initialTypeMetadata","incrementalReducer","state","action","type","typeDefs","Array","isArray","payload","ignoredTypes","reduce","typesWithoutInference","forEach","ignore","_state$typeName","nodes","typeName","clearExistingMetadata","ignored","initialMetadata","addNodes","types","disable","node","oldNode","internal","deleteNode","addNode","addedField","previousFields","_omit2","default","fields","dirty","Object","keys","StepsEnum","initialState","step","initialBuild","typeMap","inferenceMetadataReducer","incrementalBuild","exports"],"sources":["../../../src/redux/reducers/inference-metadata.ts"],"sourcesContent":["// Tracking structure of nodes to utilize this metadata for schema inference\n// Type descriptors stay relevant at any point in time making incremental inference trivial\nimport { omit } from \"lodash\";\nimport {\n  addNode,\n  addNodes,\n  deleteNode,\n  ignore,\n  disable,\n} from \"../../schema/infer/inference-metadata\";\nimport { NodeInterfaceFields } from \"../../schema/types/node-interface\";\nimport { typesWithoutInference } from \"../../schema/types/type-defs\";\n\nimport { IGatsbyState, ActionsUnion } from \"../types\";\n\nconst ignoredFields: Set<string> = new Set(NodeInterfaceFields);\n\nconst initialTypeMetadata = (): { ignoredFields: Set<string> } => {\n  return { ignoredFields };\n};\n\nconst incrementalReducer = (\n  state: IGatsbyState[\"inferenceMetadata\"][\"typeMap\"] = {},\n  action: ActionsUnion,\n): IGatsbyState[\"inferenceMetadata\"][\"typeMap\"] => {\n  switch (action.type) {\n    case `CREATE_TYPES`: {\n      const typeDefs = Array.isArray(action.payload)\n        ? action.payload\n        : [action.payload];\n      const ignoredTypes = typeDefs.reduce(typesWithoutInference, []);\n      ignoredTypes.forEach((type) => {\n        state[type] = ignore(state[type] || initialTypeMetadata());\n      });\n      return state;\n    }\n\n    case `BUILD_TYPE_METADATA`: {\n      // Overwrites existing metadata\n      const { nodes, typeName, clearExistingMetadata } = action.payload;\n      if (!state[typeName]?.ignored) {\n        const initialMetadata =\n          clearExistingMetadata || !state[typeName]\n            ? initialTypeMetadata()\n            : state[typeName];\n\n        state[typeName] = addNodes(initialMetadata, nodes);\n      }\n      return state;\n    }\n\n    case `DISABLE_TYPE_INFERENCE`: {\n      // Note: types disabled here will be re-enabled after BUILD_TYPE_METADATA\n      const types = action.payload;\n      types.forEach((type) => {\n        state[type] = disable(state[type] || initialTypeMetadata());\n      });\n      return state;\n    }\n\n    case `CREATE_NODE`: {\n      const { payload: node, oldNode } = action;\n      const { type } = node.internal;\n      if (oldNode) {\n        state[type] = deleteNode(state[type] || initialTypeMetadata(), oldNode);\n      }\n      state[type] = addNode(state[type] || initialTypeMetadata(), node);\n      return state;\n    }\n\n    case `DELETE_NODE`: {\n      const node = action.payload;\n      if (!node) return state;\n      const { type } = node.internal;\n      state[type] = deleteNode(state[type] || initialTypeMetadata(), node);\n      return state;\n    }\n\n    case `ADD_FIELD_TO_NODE`: {\n      const { payload: node, addedField } = action;\n      const { type } = node.internal;\n\n      // Must unregister previous fields first.\n      // Can't simply add { fields: { [addedField]: node.fields[addedField] } }\n      // because it will count `fields` key twice for the same node\n      const previousFields = omit(node.fields, [addedField]);\n      state[type] = deleteNode(state[type], {\n        ...node,\n        fields: previousFields,\n      });\n      state[type] = addNode(state[type], { ...node, fields: node.fields });\n\n      // TODO: there might be an edge case when the same field is \"added\" twice.\n      //   Then we'll count it twice in metadata. The only way to avoid it as I see it\n      //   is to pass original node before modifications along with a new node\n      //   in action payload and utilize original `node.fields` in deleteNode call above\n      return state;\n    }\n\n    case `ADD_CHILD_NODE_TO_PARENT_NODE`: {\n      // Marking parent type as dirty so that it rebuilds\n      const { type } = action.payload.internal;\n      state[type].dirty = true;\n      return state;\n    }\n\n    case `SET_SCHEMA`: {\n      Object.keys(state).forEach((type) => {\n        state[type].dirty = false;\n      });\n      return state;\n    }\n\n    default:\n      return state;\n  }\n};\n\nenum StepsEnum {\n  initialBuild = `initialBuild`,\n  incrementalBuild = `incrementalBuild`,\n}\n\nconst initialState = (): IGatsbyState[\"inferenceMetadata\"] => {\n  return {\n    step: StepsEnum.initialBuild, // `initialBuild` | `incrementalBuild`\n    typeMap: {},\n  };\n};\n\nexport const inferenceMetadataReducer = (\n  state: IGatsbyState[\"inferenceMetadata\"] = initialState(),\n  action: ActionsUnion,\n): IGatsbyState[\"inferenceMetadata\"] => {\n  switch (action.type) {\n    case `CREATE_NODE`:\n    case `DELETE_NODE`:\n    case `ADD_CHILD_NODE_TO_PARENT_NODE`:\n    case `ADD_FIELD_TO_NODE`: {\n      // Perf: disable incremental inference until the first schema build.\n      // There are plugins which create and delete lots of nodes during bootstrap,\n      // which makes this reducer to do a lot of unnecessary work.\n      // Instead we defer the initial metadata creation until the first schema build\n      // and then enable incremental updates explicitly\n      if (state.step === StepsEnum.initialBuild) {\n        return state;\n      }\n      state.typeMap = incrementalReducer(state.typeMap, action);\n      return state;\n    }\n\n    case `START_INCREMENTAL_INFERENCE`: {\n      return {\n        ...state,\n        step: StepsEnum.incrementalBuild,\n      };\n    }\n\n    case `DELETE_CACHE`: {\n      return initialState();\n    }\n\n    default: {\n      state.typeMap = incrementalReducer(state.typeMap, action);\n      return state;\n    }\n  }\n};\n"],"mappings":"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"}