"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringAssertion = exports.nullOr = exports.undefinedOr = exports.valueOr = exports.$u = exports.$a = exports.recordAssertion = exports.arrayAssertion = exports.objectAssertion = void 0;
const Assertion_1 = require("./Assertion");
const AssertionsLib_1 = require("./AssertionsLib");
/** Wraps an object assertion as a value assertion. */
function objectAssertion(objectTypeAssertion, errorContextProvider = undefined) {
    return o => (0, Assertion_1.assertObject)(o, objectTypeAssertion, errorContextProvider);
}
exports.objectAssertion = objectAssertion;
/**
 *  Creates an ValueAssertion for an array.
 *  The assertion check checks that array is defined,
 *  satisfies the `constraints` and every element of the array passes the `elementAssertion` check.
 */
function arrayAssertion(elementAssertion, constraints = {}) {
    const { minLength, maxLength } = constraints;
    (0, Assertion_1.assertTruthy)((minLength !== null && minLength !== void 0 ? minLength : 0) <= (maxLength !== null && maxLength !== void 0 ? maxLength : Infinity), `minLength must be < maxLength! minLength ${minLength}, maxLength: ${maxLength}`);
    (0, Assertion_1.assertTruthy)((minLength !== null && minLength !== void 0 ? minLength : 0) >= 0, `minLength must be a positive number: ${minLength}`);
    (0, Assertion_1.assertTruthy)((maxLength !== null && maxLength !== void 0 ? maxLength : 0) >= 0, `maxLength must be a positive number: ${maxLength}`);
    return (array, errorContextProvider = undefined) => {
        (0, Assertion_1.assertArray)(array, elementAssertion, constraints, errorContextProvider);
    };
}
exports.arrayAssertion = arrayAssertion;
/** Creates a value assertion for the record of elements where each of the elements passes `valueAssertion` check. */
function recordAssertion(valueAssertion, constraints = {}) {
    return (value, errorContextProvider = undefined) => {
        (0, Assertion_1.assertRecord)(value, valueAssertion, constraints, errorContextProvider);
    };
}
exports.recordAssertion = recordAssertion;
/**
 * Creates a new value assertion using *check* function.
 * The assertion accepts the value as valid if 'check(value)' returns true or throws an error otherwise.
 */
function $a(check, errorMessageProvider) {
    (0, Assertion_1.assertTruthy)(typeof check === 'function', `"check" is not a function: ${check}`);
    return (value, errorContextProvider = undefined) => (0, Assertion_1.assertTruthy)(check(value), () => {
        let errorContext = (0, Assertion_1.getErrorMessage)(errorContextProvider) || 'Check is failed';
        if (!errorContext.endsWith(':')) {
            errorContext += ':';
        }
        const errorMessage = (0, Assertion_1.getErrorMessage)(errorMessageProvider);
        return `${errorContext} ${errorMessage || (typeof value === 'object' ? '[object]' : `'${value}'`)}`;
    });
}
exports.$a = $a;
/**
 * Creates a new value assertion using *check* function.
 * The assertion accepts the value as valid if 'check(value)' returns true or throws an error otherwise.
 *
 * Note: same as `$a` but forces processing of the check function argument as `unknown`.
 */
function $u(check, errorMessageProvider) {
    return $a(check, errorMessageProvider);
}
exports.$u = $u;
/**
 *  Creates an assertion that makes comparison by reference with the *expectedValue* before calling *orAssertion*.
 *  If comparison with the *expectedValue* succeeds, does not call the *orAssertion*.
 */
function valueOr(expectedValue, orAssertion) {
    return (value, errorContextProvider = undefined) => {
        if (value === expectedValue)
            return;
        if (typeof orAssertion === 'object') {
            (0, Assertion_1.assertObject)(value, orAssertion, errorContextProvider);
        }
        else {
            (0, Assertion_1.callValueAssertion)(value, orAssertion, errorContextProvider);
        }
    };
}
exports.valueOr = valueOr;
/** Creates an assertion that succeeds if the value is *undefined* or calls  *orAssertion* if the value is not *undefined*. */
function undefinedOr(orAssertion) {
    return valueOr(undefined, orAssertion);
}
exports.undefinedOr = undefinedOr;
/** Creates an assertion that succeeds if the value is *null* or calls  *orAssertion* if the value is not *undefined*. */
function nullOr(orAssertion) {
    return valueOr(null, orAssertion);
}
exports.nullOr = nullOr;
const stringAssertion = (constraints) => (value, context = undefined) => {
    var _a, _b;
    (0, AssertionsLib_1.assertString)(value, context);
    (0, Assertion_1.assertTruthy)(value.length >= ((_a = constraints.minLength) !== null && _a !== void 0 ? _a : 0), `${(0, Assertion_1.getErrorMessage)(context)} length is too small: ${value.length} < ${constraints.minLength}`);
    (0, Assertion_1.assertTruthy)(value.length <= ((_b = constraints.maxLength) !== null && _b !== void 0 ? _b : Infinity), `${(0, Assertion_1.getErrorMessage)(context)} length is too large ${value.length} > ${constraints.maxLength}`);
};
exports.stringAssertion = stringAssertion;
//# sourceMappingURL=AssertionFactoriesLib.js.map