import { ArrayConstraints, Assertion, AssertionErrorProvider, ObjectAssertion, RecordConstraints, ValueAssertion } from './Assertion';
/** Wraps an object assertion as a value assertion. */
export declare function objectAssertion<ObjectType>(objectTypeAssertion: ObjectAssertion<ObjectType>, errorContextProvider?: AssertionErrorProvider | undefined): ValueAssertion<ObjectType>;
/**
 *  Creates an ValueAssertion for an array.
 *  The assertion check checks that array is defined,
 *  satisfies the `constraints` and every element of the array passes the `elementAssertion` check.
 */
export declare function arrayAssertion<T>(elementAssertion: Assertion<T>, constraints?: ArrayConstraints<T>): ValueAssertion<Array<T>>;
/** Creates a value assertion for the record of elements where each of the elements passes `valueAssertion` check. */
export declare function recordAssertion<RecordValueType>(valueAssertion: Assertion<RecordValueType>, constraints?: RecordConstraints<RecordValueType>): ValueAssertion<Record<string, RecordValueType>>;
/** Type of the checking function for *$v*. */
export type CheckFn<T> = (v: T) => boolean;
/**
 * Creates a new value assertion using *check* function.
 * The assertion accepts the value as valid if 'check(value)' returns true or throws an error otherwise.
 */
export declare function $a<T>(check: CheckFn<T> | CheckFn<unknown>, errorMessageProvider?: AssertionErrorProvider): ValueAssertion<T>;
/**
 * Creates a new value assertion using *check* function.
 * The assertion accepts the value as valid if 'check(value)' returns true or throws an error otherwise.
 *
 * Note: same as `$a` but forces processing of the check function argument as `unknown`.
 */
export declare function $u<T>(check: CheckFn<unknown>, errorMessageProvider?: AssertionErrorProvider): ValueAssertion<T>;
/**
 *  Creates an assertion that makes comparison by reference with the *expectedValue* before calling *orAssertion*.
 *  If comparison with the *expectedValue* succeeds, does not call the *orAssertion*.
 */
export declare function valueOr<T>(expectedValue: T, orAssertion: Assertion<T>): Assertion<T>;
/** Creates an assertion that succeeds if the value is *undefined* or calls  *orAssertion* if the value is not *undefined*. */
export declare function undefinedOr<T>(orAssertion: Assertion<T>): Assertion<T | undefined>;
/** Creates an assertion that succeeds if the value is *null* or calls  *orAssertion* if the value is not *undefined*. */
export declare function nullOr<T>(orAssertion: Assertion<T>): Assertion<T | null>;
export interface StringConstraints {
    /** Minimum length of the string. Inclusive. */
    minLength?: number;
    /** Maximum length of the string. Inclusive. */
    maxLength?: number;
}
export declare const stringAssertion: (constraints: StringConstraints) => ValueAssertion<string>;
