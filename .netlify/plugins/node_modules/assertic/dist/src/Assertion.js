"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.callValueAssertion = exports.assertRecord = exports.assertArray = exports.assertObject = exports.getErrorMessage = exports.getAssertionErrorFromProvider = exports.fail = exports.truthy = exports.assertTruthy = void 0;
const ChecksLib_1 = require("./ChecksLib");
const Formatter_1 = require("./Formatter");
/** Asserts that the *param* value is truthy using '!' operator or throws an Error.  */
function assertTruthy(value, error) {
    if (!value) {
        fail(error);
    }
}
exports.assertTruthy = assertTruthy;
/**
 * Casts the 'value' to a non-nullable type or throws an error.
 * Uses 'assertTruthy' to make the check.
 */
function truthy(value, error) {
    assertTruthy(value, error);
    return value;
}
exports.truthy = truthy;
function fail(error) {
    const errorMessage = getAssertionErrorFromProvider(error);
    if (typeof errorMessage === 'object') {
        throw errorMessage;
    }
    throw new Error(errorMessage || 'Assertion error');
}
exports.fail = fail;
/** Returns validation context as a string. Calls errorProvider() if needed. */
function getAssertionErrorFromProvider(errorProvider) {
    if (errorProvider === undefined) {
        return '';
    }
    if (typeof errorProvider === 'string') {
        return errorProvider;
    }
    return errorProvider();
}
exports.getAssertionErrorFromProvider = getAssertionErrorFromProvider;
/** Returns validation context as a string. Calls errorProvider() if needed. */
function getErrorMessage(errorProvider) {
    const error = getAssertionErrorFromProvider(errorProvider);
    return typeof error === 'string' ? error : error.message || '<no error message>';
}
exports.getErrorMessage = getErrorMessage;
/**
 * Asserts that the object satisfies the schema using individual field assertions.
 * Throws an error if not.
 * Works only with non-array objects: use 'assertArray' to check arrays.
 */
function assertObject(value, objectAssertion, errorContextProvider = undefined, constraints = {}) {
    const ctx = () => {
        return getErrorMessage(errorContextProvider);
    };
    const errorWithContext = (message) => {
        const context = ctx();
        return context.length === 0 ? message : `${context} ${message}`;
    };
    assertTruthy(typeof value === 'object', () => errorWithContext(`is not an object: ${typeof value}`));
    assertTruthy(value !== undefined, () => errorWithContext(`is not defined`));
    assertTruthy(value !== null, () => errorWithContext(`is null`));
    assertTruthy(!Array.isArray(value), () => errorWithContext(`is an array.`));
    const assertionEntries = Object.entries(objectAssertion);
    if (constraints.failOnUnknownFields) {
        const allowedUnknownFieldNames = constraints.allowedUnknownFieldNames || [];
        for (const objectFieldName in value) {
            const skipUnknownFieldCheck = allowedUnknownFieldNames.includes(objectFieldName);
            assertTruthy(skipUnknownFieldCheck || assertionEntries.some(([assertionFieldName]) => objectFieldName === assertionFieldName), errorWithContext(`property can't be checked: ${objectFieldName}`));
        }
    }
    let $o;
    for (const [fieldKey, fieldAssertion] of assertionEntries) {
        assertTruthy(typeof fieldAssertion === 'function' || (typeof fieldAssertion === 'object' && fieldAssertion !== null), () => `${ctx()}.${fieldKey} assertion is not an object or a function: ${typeof fieldAssertion}`);
        const fieldValue = value[fieldKey];
        const fieldCtx = () => `${ctx()}.${fieldKey}`;
        if (typeof fieldAssertion === 'object') {
            assertTruthy(!Array.isArray(fieldValue), () => `${ctx()}.${fieldCtx()} use arrayAssertion() to create a ValueAssertion for an array`);
            assertObject(fieldValue, fieldAssertion, fieldCtx);
        }
        else {
            assertTruthy(typeof fieldAssertion === 'function', () => `${ctx()}.${fieldCtx()} assertion is not a function`);
            if (fieldKey === '$o') {
                $o = fieldAssertion; // Will be run last.
            }
            else {
                const checkResult = fieldAssertion(fieldValue, fieldCtx);
                assertTruthy(checkResult === undefined, `Assertion function must assert (void) but it returns a value: ${checkResult}. Wrap with $u()?`);
            }
        }
    }
    if ($o) {
        $o(value, errorContextProvider);
    }
}
exports.assertObject = assertObject;
/**
 * Asserts that the `value` is an array and every element in the array satisfy to the *elementAssertion*.
 * Throws error if check fails.
 */
function assertArray(value, elementAssertion, constraints = {}, errorContextProvider = undefined) {
    var _a, _b;
    const ctx = createChildNodeContextProvider(errorContextProvider);
    assertTruthy(Array.isArray(value), () => `${ctx()}value is not an array: ${value}`);
    const minLength = (_a = constraints.minLength) !== null && _a !== void 0 ? _a : 0;
    const maxLength = (_b = constraints.maxLength) !== null && _b !== void 0 ? _b : Infinity;
    assertTruthy(value.length >= minLength, () => `${ctx()}array length < minLength. Array length: ${value.length}, minLength: ${minLength}`);
    assertTruthy(value.length <= maxLength, () => `${ctx()}array length > maxLength. Array length: ${value.length}, maxLength: ${maxLength}`);
    if (constraints.uniqueByIdentity) {
        assertTruthy((0, ChecksLib_1.checkArrayHasUniqueElements)(value, constraints.uniqueByIdentity), () => `${ctx()}array contains non-unique elements`);
    }
    let i = 0;
    const elementErrorProvider = () => `${ctx('no-space-separator')}[${i}]`;
    for (; i < value.length; i++) {
        const element = value[i];
        assertChildValue(element, elementAssertion, elementErrorProvider);
    }
}
exports.assertArray = assertArray;
/**
 * Asserts that the `value` is record of values of the given types.
 * Throws error if check fails.
 */
function assertRecord(value, valueAssertion, constraints = {}, errorContextProvider = undefined) {
    const ctx = createChildNodeContextProvider(errorContextProvider);
    assertTruthy(typeof value === 'object', () => `${ctx()}value is not an object: ${(0, Formatter_1.formatValue)(value)}`);
    assertTruthy(value !== null, () => `${ctx()}value is null`);
    assertTruthy(!Array.isArray(value), () => `${ctx()}the value is not a record, but is an array`);
    // Check every key and value.
    for (const [k, v] of Object.entries(value)) {
        const keyCtx = () => `${ctx('no-space-separator')}['${k}']`;
        if (constraints.keyAssertion) {
            assertChildValue(k, constraints.keyAssertion, () => `${keyCtx()}, key assertion failed:`);
        }
        assertChildValue(v, valueAssertion, keyCtx);
        const { keyField } = constraints;
        if (keyField) {
            assertTruthy(typeof v == 'object' && v !== null, () => `${keyCtx()} is not an object: ${(0, Formatter_1.formatValue)(v)}`);
            const kv = v[keyField];
            assertTruthy(kv === k, () => `${keyCtx()} key value does not match object field '${keyField}' value: ${(0, Formatter_1.formatValue)(kv)}`);
        }
    }
    // Check the whole record with a cross-field check.
    if (constraints.$o) {
        constraints.$o(value, errorContextProvider);
    }
}
exports.assertRecord = assertRecord;
/**
 * Calls the assertion.
 * Workaround for TS issue with assertion on genetic arrow function. See https://github.com/microsoft/TypeScript/issues/34523.
 */
function callValueAssertion(value, valueAssertion, errorContextProvider) {
    valueAssertion(value, errorContextProvider);
}
exports.callValueAssertion = callValueAssertion;
function createChildNodeContextProvider(errorContextProvider) {
    return (mode = 'with-space-separator') => {
        const text = getErrorMessage(errorContextProvider);
        return text ? `${text}${mode === 'with-space-separator' ? ' ' : ''}` : '';
    };
}
function assertChildValue(value, assertion, elementErrorProvider) {
    if (typeof assertion === 'object') {
        assertTruthy(!Array.isArray(value), () => `${elementErrorProvider}: use arrayAssertion() to create a ValueAssertion for an array`);
        assertObject(value, assertion, elementErrorProvider);
    }
    else {
        callValueAssertion(value, assertion, elementErrorProvider);
    }
}
//# sourceMappingURL=Assertion.js.map