/** Lazy error message provider. */
export type AssertionErrorProvider = (() => string | Error) | string;
/** Asserts that the *param* value is truthy using '!' operator or throws an Error.  */
export declare function assertTruthy(value: unknown, error?: AssertionErrorProvider): asserts value;
/**
 * Casts the 'value' to a non-nullable type or throws an error.
 * Uses 'assertTruthy' to make the check.
 */
export declare function truthy<T>(value: T, error?: AssertionErrorProvider): NonNullable<T>;
export declare function fail(error?: AssertionErrorProvider): never;
/** Returns validation context as a string. Calls errorProvider() if needed. */
export declare function getAssertionErrorFromProvider(errorProvider: AssertionErrorProvider | undefined): string | Error;
/** Returns validation context as a string. Calls errorProvider() if needed. */
export declare function getErrorMessage(errorProvider: AssertionErrorProvider | undefined): string;
export type Assertion<T> = ValueAssertion<T> | ObjectAssertion<T>;
/**
 * Checks that the `value` type is correct and throws error if not.
 * The assertion uses optional *errorProvider* to get the error message.
 */
export type ValueAssertion<ValueType> = (value: unknown, errorContextProvider?: AssertionErrorProvider) => asserts value is ValueType;
/**
 * Compile-time checked set of assertions for every object field in the type.
 * If the optional '$o' field is provided, the $o() is called after all fields assertions are finished.
 */
export type ObjectAssertion<ObjectType> = {
    [key in keyof Required<ObjectType>]: Assertion<ObjectType[key]>;
} & {
    $o?: ObjectCrossFieldAssertion<ObjectType>;
};
/**
 * Dedicated assertion type for *$o* field in *ObjectAssertion*.
 * Accepts an object with all fields individually checked and checks cross-field rules.
 * Throws an error if the check fails.
 */
export type ObjectCrossFieldAssertion<ValueType> = (value: ValueType, errorProvider?: AssertionErrorProvider) => void;
export interface ObjectAssertionConstraints {
    /**
     * Makes `assertObject()` function to fail if `value` has any properties
     * not covered by the assertions: beyond the asserted object type.
     */
    failOnUnknownFields?: boolean;
    /**
     * Allows listed field to pass `failOnUnknownFields` check.
     * Used as part of `failOnUnknownFields` check only.
     */
    allowedUnknownFieldNames?: string[];
}
/**
 * Asserts that the object satisfies the schema using individual field assertions.
 * Throws an error if not.
 * Works only with non-array objects: use 'assertArray' to check arrays.
 */
export declare function assertObject<ObjectType>(value: unknown, objectAssertion: ObjectAssertion<ObjectType>, errorContextProvider?: AssertionErrorProvider | undefined, constraints?: ObjectAssertionConstraints): asserts value is ObjectType;
export interface ArrayConstraints<T = unknown> {
    /** Minimum array length. Inclusive. */
    minLength?: number;
    /** Maximum array length. Inclusive. */
    maxLength?: number;
    /**
     * If provided, the array is checked to have only unique elements.
     * This function must return the identity of the element. See checkArrayHasUniqueElements.
     */
    uniqueByIdentity?: (element: T) => string;
}
/**
 * Asserts that the `value` is an array and every element in the array satisfy to the *elementAssertion*.
 * Throws error if check fails.
 */
export declare function assertArray<ElementType>(value: unknown, elementAssertion: Assertion<ElementType>, constraints?: ArrayConstraints<ElementType>, errorContextProvider?: AssertionErrorProvider | undefined): asserts value is Array<ElementType>;
/** Additional constraints for a value passed to `assertRecord` call. */
export interface RecordConstraints<RecordValueType = unknown> {
    /** An assertion to validate key format. */
    keyAssertion?: ValueAssertion<string>;
    /**
     * Name of the key field in the 'RecordValueType' object.
     * If present the RecordValueType[keyField] must be equal to the key this object is stored in the record.
     */
    keyField?: string;
    /** A cross field assertion called for the whole record after all per-element completed successfully. */
    $o?: ObjectCrossFieldAssertion<Record<string, RecordValueType>>;
}
/**
 * Asserts that the `value` is record of values of the given types.
 * Throws error if check fails.
 */
export declare function assertRecord<RecordValueType = unknown>(value: unknown, valueAssertion: Assertion<RecordValueType>, constraints?: RecordConstraints<RecordValueType>, errorContextProvider?: AssertionErrorProvider | undefined): asserts value is Record<string, RecordValueType>;
/**
 * Calls the assertion.
 * Workaround for TS issue with assertion on genetic arrow function. See https://github.com/microsoft/TypeScript/issues/34523.
 */
export declare function callValueAssertion<T>(value: unknown, valueAssertion: ValueAssertion<T>, errorContextProvider: AssertionErrorProvider | undefined): asserts value is T;
